From 7339786a3afce5dfac9da85d6a8fa8f5a6cc2d9c Mon Sep 17 00:00:00 2001
From: Ghislain Vaillant <ghislain.vaillant@icm-institute.org>
Date: Tue, 25 Jul 2023 10:22:40 -0400
Subject: [PATCH] Remove ANTSPATH

---
 Dockerfile                                    |   3 +-
 Scripts/ants.sh                               |  52 ++---
 Scripts/antsASLProcessing.sh                  |  54 ++---
 Scripts/antsAtroposN4.sh                      |  30 +--
 Scripts/antsBrainExtraction.sh                | 104 +++++----
 Scripts/antsCookTemplatePriors.sh             |  34 +--
 Scripts/antsCorticalThickness.sh              | 110 ++++-----
 Scripts/antsIntermodalityIntrasubject.sh      |  34 +--
 Scripts/antsIntroduction.sh                   |  96 +++-----
 Scripts/antsJointLabelFusion.sh               | 171 ++++++--------
 Scripts/antsJointLabelFusion2.sh              | 213 ++++++++----------
 Scripts/antsLongitudinalCorticalThickness.sh  |  64 +++---
 Scripts/antsLongitudinalJointLabelFusion.sh   | 171 ++++++--------
 .../antsMultivariateTemplateConstruction.sh   | 126 ++++-------
 .../antsMultivariateTemplateConstruction2.sh  | 123 ++++------
 Scripts/antsNeuroimagingBattery               |  74 +++---
 Scripts/antsRegistrationSpaceTime.sh          |  37 +--
 Scripts/antsRegistrationSyN.sh                |  39 +---
 Scripts/antsRegistrationSyNQuick.sh           |  39 +---
 Scripts/antsaffine.sh                         |  28 +--
 Scripts/antsdeformationmag.sh                 |  23 +-
 Scripts/antswithdt.sh                         |  28 +--
 Scripts/basic_ants_example.sh                 |  57 +++--
 Scripts/buildtemplateparallel.sh              | 118 ++++------
 Scripts/directlabels.sh                       |  48 ++--
 Scripts/geodesicinterpolation.sh              |  73 +++---
 Scripts/guidedregistration.sh                 |  19 +-
 Scripts/landmarkmatch.sh                      |  29 ++-
 Scripts/lohmann.sh                            |  51 ++---
 Scripts/multi_template_script.sh              |  10 +-
 Scripts/optimalsmooth.sh                      |   5 +-
 Scripts/phantomstudy.sh                       |  18 +-
 Scripts/shapeupdatetotemplate.sh              |  57 ++---
 Scripts/sliceBySliceOperation.sh              |  53 +----
 34 files changed, 878 insertions(+), 1313 deletions(-)

diff --git a/Dockerfile b/Dockerfile
index 2c585100..ce3281de 100644
--- a/Dockerfile
+++ b/Dockerfile
@@ -49,8 +49,7 @@ LABEL maintainer="ANTsX team" \
       description="ANTs is part of the ANTsX ecosystem (https://github.com/ANTsX). \
 ANTs Citation: https://pubmed.ncbi.nlm.nih.gov/24879923"
 
-ENV ANTSPATH="/opt/ants/bin/" \
-    PATH="/opt/ants/bin:$PATH" \
+ENV PATH="/opt/ants/bin:$PATH" \
     LD_LIBRARY_PATH="/opt/ants/lib:$LD_LIBRARY_PATH"
 RUN apt-get update \
     && apt install -y --no-install-recommends \
diff --git a/Scripts/ants.sh b/Scripts/ants.sh
index 81b1a843..fabacbda 100755
--- a/Scripts/ants.sh
+++ b/Scripts/ants.sh
@@ -3,12 +3,10 @@
 NUMPARAMS=$#
 
 MAXITERATIONS=30x90x20
-if [[ -z ${ANTSPATH} ]] ; then
-  echo "Environment variable ANTSPATH must be defined"
-  exit 1
-fi
-if [[ ! -f "${ANTSPATH}/ANTS" ]] ; then
-  echo "Cannot find the ANTS program. Please \(re\)define \$ANTSPATH in your environment."
+
+if ! command -v "ANTS" &> /dev/null
+then
+  echo "Cannot find the ANTS program. Please \(re\)define \$PATH in your environment."
   exit 1
 fi
 
@@ -16,7 +14,6 @@ if [ $NUMPARAMS -lt 3 ]
 then
 echo " USAGE ::  "
 echo "  sh   ants.sh  ImageDimension  fixed.ext  moving.ext  OPTIONAL-OUTPREFIX   OPTIONAL-max-iterations  OPTIONAL-Labels-In-Fixed-Image-Space-To-Deform-To-Moving-Image     Option-DoANTSQC "
-echo " be sure to set ANTSPATH environment variable "
 echo " Max-Iterations in form :    JxKxL where "
 echo "  J = max iterations at coarsest resolution (here, reduce by power of 2^2) "
 echo " K = middle resolution iterations ( here, reduce by power of 2 ) "
@@ -27,18 +24,6 @@ echo " Other parameters are updates of the defaults used in the A. Klein evaluat
 exit
 fi
 
-#ANTSPATH=YOURANTSPATH
-if [  ${#ANTSPATH} -le 0 ]
-then
-echo " Please set ANTSPATH=LocationOfYourAntsBinaries "
-echo " Either set this in your profile or directly, here in the script. "
-echo " For example : "
-echo " ANTSPATH=/home/yourname/bin/ants/ "
-exit
-else
-echo " ANTSPATH is $ANTSPATH "
-fi
-
 #initialization, here, is unbiased
 DIM=$1
 
@@ -101,7 +86,6 @@ fi
 # exit
 
 
-echo  " ANTSPATH  is $ANTSPATH     "
 echo " Mapping Parameters  :: "
 echo  " Transformation is:  $TRANSFORMATION "
 echo " MaxIterations :   $MAXITERATIONS "
@@ -116,10 +100,10 @@ echo " "
 
 
 if [[ ! -s ${OUTPUTNAME}repaired.nii.gz ]] ; then
-${ANTSPATH}/N4BiasFieldCorrection -d $DIM -i $MOVING -o ${OUTPUTNAME}repaired.nii.gz -s 2 -c [ 50x50x50x50,0.000001 ] -b [ 200 ]
-# ${ANTSPATH}/N3BiasFieldCorrection $DIM $MOVING   ${OUTPUTNAME}repaired.nii.gz  4
+N4BiasFieldCorrection -d $DIM -i $MOVING -o ${OUTPUTNAME}repaired.nii.gz -s 2 -c [ 50x50x50x50,0.000001 ] -b [ 200 ]
+# N3BiasFieldCorrection $DIM $MOVING   ${OUTPUTNAME}repaired.nii.gz  4
 fi
-exe=" ${ANTSPATH}/ANTS $DIM -m  ${METRIC}${FIXED},${OUTPUTNAME}repaired.nii.gz,${METRICPARAMS}  -t $TRANSFORMATION  -r $REGULARIZATION -o ${OUTPUTNAME}   -i $MAXITERATIONS   --use-Histogram-Matching  --number-of-affine-iterations 10000x10000x10000x10000x10000 --MI-option 32x16000  "
+exe=" ANTS $DIM -m  ${METRIC}${FIXED},${OUTPUTNAME}repaired.nii.gz,${METRICPARAMS}  -t $TRANSFORMATION  -r $REGULARIZATION -o ${OUTPUTNAME}   -i $MAXITERATIONS   --use-Histogram-Matching  --number-of-affine-iterations 10000x10000x10000x10000x10000 --MI-option 32x16000  "
 
  echo " $exe "
 
@@ -128,11 +112,11 @@ exe=" ${ANTSPATH}/ANTS $DIM -m  ${METRIC}${FIXED},${OUTPUTNAME}repaired.nii.gz,$
   #below, some affine options
   #--MI-option 16x8000 #-a InitAffine.txt --continue-affine 0
 
-    ${ANTSPATH}/WarpImageMultiTransform $DIM  ${OUTPUTNAME}repaired.nii.gz    ${OUTPUTNAME}deformed.nii.gz  ${OUTPUTNAME}Warp.nii.gz  ${OUTPUTNAME}Affine.txt  -R ${FIXED}
+    WarpImageMultiTransform $DIM  ${OUTPUTNAME}repaired.nii.gz    ${OUTPUTNAME}deformed.nii.gz  ${OUTPUTNAME}Warp.nii.gz  ${OUTPUTNAME}Affine.txt  -R ${FIXED}
 
 if  [ ${#LABELIMAGE} -gt 3 ]
 then
-      ${ANTSPATH}/WarpImageMultiTransform $DIM  $LABELIMAGE   ${OUTPUTNAME}labeled.nii.gz  -i ${OUTPUTNAME}Affine.txt ${OUTPUTNAME}InverseWarp.nii.gz   -R ${MOVING}   --use-NN
+      WarpImageMultiTransform $DIM  $LABELIMAGE   ${OUTPUTNAME}labeled.nii.gz  -i ${OUTPUTNAME}Affine.txt ${OUTPUTNAME}InverseWarp.nii.gz   -R ${MOVING}   --use-NN
 fi
 
 exit
@@ -140,19 +124,19 @@ exit
 if [ $DoANTSQC -eq 1 ] ;  then
 #  measure image similarity
 for SIM in 0 1 2 ; do
-${ANTSPATH}/MeasureImageSimilarity $DIM $SIM $FIXED ${OUTPUTNAME}deformed.nii.gz
+MeasureImageSimilarity $DIM $SIM $FIXED ${OUTPUTNAME}deformed.nii.gz
 done
 #  measure dice overlap and mds
-${ANTSPATH}/ThresholdImage $DIM $FIXED ${OUTPUTNAME}fixthresh.nii.gz Otsu 4
-${ANTSPATH}/ThresholdImage $DIM $MOVING ${OUTPUTNAME}movthresh.nii.gz Otsu 4
-${ANTSPATH}/WarpImageMultiTransform $DIM   ${OUTPUTNAME}movthresh.nii.gz  ${OUTPUTNAME}defthresh.nii.gz ${OUTPUTNAME}Warp.nii.gz  ${OUTPUTNAME}Affine.txt  -R ${FIXED}   --use-NN
-${ANTSPATH}/ImageMath $DIM ${OUTPUTNAME}dicestats.txt DiceAndMinDistSum  ${OUTPUTNAME}fixthresh.nii.gz   ${OUTPUTNAME}movthresh.nii.gz   ${OUTPUTNAME}mindistsum.nii.gz
+ThresholdImage $DIM $FIXED ${OUTPUTNAME}fixthresh.nii.gz Otsu 4
+ThresholdImage $DIM $MOVING ${OUTPUTNAME}movthresh.nii.gz Otsu 4
+WarpImageMultiTransform $DIM   ${OUTPUTNAME}movthresh.nii.gz  ${OUTPUTNAME}defthresh.nii.gz ${OUTPUTNAME}Warp.nii.gz  ${OUTPUTNAME}Affine.txt  -R ${FIXED}   --use-NN
+ImageMath $DIM ${OUTPUTNAME}dicestats.txt DiceAndMinDistSum  ${OUTPUTNAME}fixthresh.nii.gz   ${OUTPUTNAME}movthresh.nii.gz   ${OUTPUTNAME}mindistsum.nii.gz
 #  labelstats for jacobian wrt segmenation
  # below, to compose
-# ${ANTSPATH}ComposeMultiTransform $DIM   ${OUTPUTNAME}CompWarp.nii.gz   -R $FIXED ${OUTPUTNAME}Warp.nii.gz  ${OUTPUTNAME}Affine.txt
-# ${ANTSPATH}CreateJacobianDeterminantImage $DIM ${OUTPUTNAME}CompWarp.nii.gz  ${OUTPUTNAME}jacobian.nii.gz   0
-# ${ANTSPATH}ImageMath $DIM ${OUTPUTNAME}movlabstat.txt LabelStats ${OUTPUTNAME}movthresh.nii.gz ${OUTPUTNAME}movthresh.nii.gz
-# ${ANTSPATH}ImageMath $DIM ${OUTPUTNAME}jaclabstat.txt LabelStats ${OUTPUTNAME}defthresh.nii.gz ${OUTPUTNAME}jacobian.nii.gz
+# ComposeMultiTransform $DIM   ${OUTPUTNAME}CompWarp.nii.gz   -R $FIXED ${OUTPUTNAME}Warp.nii.gz  ${OUTPUTNAME}Affine.txt
+# CreateJacobianDeterminantImage $DIM ${OUTPUTNAME}CompWarp.nii.gz  ${OUTPUTNAME}jacobian.nii.gz   0
+# ImageMath $DIM ${OUTPUTNAME}movlabstat.txt LabelStats ${OUTPUTNAME}movthresh.nii.gz ${OUTPUTNAME}movthresh.nii.gz
+# ImageMath $DIM ${OUTPUTNAME}jaclabstat.txt LabelStats ${OUTPUTNAME}defthresh.nii.gz ${OUTPUTNAME}jacobian.nii.gz
 # we compare the output of these last two lines:
 #  the Volume of the movlabstat computation vs. the mass of the jaclabstat
 fi
diff --git a/Scripts/antsASLProcessing.sh b/Scripts/antsASLProcessing.sh
index be651d48..10046ff8 100755
--- a/Scripts/antsASLProcessing.sh
+++ b/Scripts/antsASLProcessing.sh
@@ -1,16 +1,16 @@
 #!/bin/bash
 
-if [[ ! -s ${ANTSPATH}/antsRegistration ]]
+if ! command -v antsRegistration &> /dev/null
 then
-  echo "Cannot find antsRegistration.  Please \(re\)define \$ANTSPATH in your environment."
+  echo "Cannot find antsRegistration.  Please \(re\)define \$PATH in your environment."
 fi
-if [[ ! -s ${ANTSPATH}/antsApplyTransforms ]]
+if ! command -v antsApplyTransforms &> /dev/null
 then
-  echo "Cannot find antsApplyTransforms.  Please \(re\)define \$ANTSPATH in your environment."
+  echo "Cannot find antsApplyTransforms.  Please \(re\)define \$PATH in your environment."
 fi
-if [[ ! -s ${ANTSPATH}/antsIntermodalityIntrasubject.sh ]]
+if ! command -v antsIntermodalityIntrasubject.sh &> /dev/null
 then
-  echo "Cannot find antsIntermodalityIntrasubject.sh script.  Please \(re\)define \$ANTSPATH in your environemnt."
+  echo "Cannot find antsIntermodalityIntrasubject.sh script.  Please \(re\)define \$PATH in your environemnt."
 fi
 
 function Usage {
@@ -258,13 +258,13 @@ then
   mkdir -p `dirname $OUTNAME`
 fi
 if [[ ! -s ${OUTNAME}/AveragePCASL.nii.gz ]] ; then
-  logCmd ${ANTSPATH}/antsMotionCorr -d 3 -a $PCASL -o ${OUTNAME}AveragePCASL.nii.gz
+  logCmd antsMotionCorr -d 3 -a $PCASL -o ${OUTNAME}AveragePCASL.nii.gz
 fi
-logCmd ${ANTSPATH}/ThresholdImage 3 ${OUTNAME}AveragePCASL.nii.gz ${OUTNAME}tmp.nii.gz 600 999999
-logCmd ${ANTSPATH}/ImageMath 3 ${OUTNAME}tmp.nii.gz ME ${OUTNAME}tmp.nii.gz 2
-logCmd ${ANTSPATH}/ImageMath 3 ${OUTNAME}tmp.nii.gz GetLargestComponent ${OUTNAME}tmp.nii.gz
-logCmd ${ANTSPATH}/ImageMath 3 ${OUTNAME}tmp.nii.gz MD ${OUTNAME}tmp.nii.gz 3
-logCmd ${ANTSPATH}/ImageMath 3 ${OUTNAME}pCASLBrain.nii.gz m ${OUTNAME}AveragePCASL.nii.gz ${OUTNAME}tmp.nii.gz
+logCmd ThresholdImage 3 ${OUTNAME}AveragePCASL.nii.gz ${OUTNAME}tmp.nii.gz 600 999999
+logCmd ImageMath 3 ${OUTNAME}tmp.nii.gz ME ${OUTNAME}tmp.nii.gz 2
+logCmd ImageMath 3 ${OUTNAME}tmp.nii.gz GetLargestComponent ${OUTNAME}tmp.nii.gz
+logCmd ImageMath 3 ${OUTNAME}tmp.nii.gz MD ${OUTNAME}tmp.nii.gz 3
+logCmd ImageMath 3 ${OUTNAME}pCASLBrain.nii.gz m ${OUTNAME}AveragePCASL.nii.gz ${OUTNAME}tmp.nii.gz
 
 INTERSUBJECT_PARAMS=" -d 3 -i ${OUTNAME}pCASLBrain.nii.gz -r $ANATOMICAL_IMAGE -x $BRAINMASK -w ${TRANSFORM_PREFIX}SubjectToTemplate -t 2 -o $OUTNAME "
 if [[ -n $LABELS ]]
@@ -272,19 +272,19 @@ then
   INTERSUBJECT_PARAMS=" ${INTERSUBJECT_PARAMS} -l $LABELS "
 fi
 
-logCmd ${ANTSPATH}/antsIntermodalityIntrasubject.sh $INTERSUBJECT_PARAMS
-logCmd ${ANTSPATH}/N4BiasFieldCorrection -d 3 -i ${OUTNAME}AveragePCASL.nii.gz -o  ${OUTNAME}AveragePCASL.nii.gz -r 1 -s 4
-logCmd ${ANTSPATH}/N4BiasFieldCorrection -d 3 -i ${OUTNAME}AveragePCASL.nii.gz -o  ${OUTNAME}AveragePCASL.nii.gz -r 1 -s 2
-logCmd ${ANTSPATH}/N4BiasFieldCorrection -d 3 -i ${OUTNAME}AveragePCASL.nii.gz -o  ${OUTNAME}AveragePCASL.nii.gz -r 1 -s 1
-logCmd ${ANTSPATH}/ThresholdImage 3 ${OUTNAME}AveragePCASL.nii.gz ${OUTNAME}OtsuMask.nii.gz Otsu 4
-logCmd ${ANTSPATH}/ThresholdImage 3 ${OUTNAME}OtsuMask.nii.gz ${OUTNAME}OtsuMask.nii.gz 2 4
-logCmd ${ANTSPATH}/ImageMath 3 ${OUTNAME}OtsuMask.nii.gz ME ${OUTNAME}OtsuMask.nii.gz 1
-logCmd ${ANTSPATH}/ImageMath 3 ${OUTNAME}OtsuMask.nii.gz MD ${OUTNAME}OtsuMask.nii.gz 1
-logCmd ${ANTSPATH}/ThresholdImage 3 ${OUTNAME}brainmask.nii.gz ${OUTNAME}BrainThresh.nii.gz 1 999
-logCmd ${ANTSPATH}/MultiplyImages 3 ${OUTNAME}OtsuMask.nii.gz ${OUTNAME}BrainThresh.nii.gz  ${OUTNAME}OtsuMask.nii.gz
+logCmd antsIntermodalityIntrasubject.sh $INTERSUBJECT_PARAMS
+logCmd N4BiasFieldCorrection -d 3 -i ${OUTNAME}AveragePCASL.nii.gz -o  ${OUTNAME}AveragePCASL.nii.gz -r 1 -s 4
+logCmd N4BiasFieldCorrection -d 3 -i ${OUTNAME}AveragePCASL.nii.gz -o  ${OUTNAME}AveragePCASL.nii.gz -r 1 -s 2
+logCmd N4BiasFieldCorrection -d 3 -i ${OUTNAME}AveragePCASL.nii.gz -o  ${OUTNAME}AveragePCASL.nii.gz -r 1 -s 1
+logCmd ThresholdImage 3 ${OUTNAME}AveragePCASL.nii.gz ${OUTNAME}OtsuMask.nii.gz Otsu 4
+logCmd ThresholdImage 3 ${OUTNAME}OtsuMask.nii.gz ${OUTNAME}OtsuMask.nii.gz 2 4
+logCmd ImageMath 3 ${OUTNAME}OtsuMask.nii.gz ME ${OUTNAME}OtsuMask.nii.gz 1
+logCmd ImageMath 3 ${OUTNAME}OtsuMask.nii.gz MD ${OUTNAME}OtsuMask.nii.gz 1
+logCmd ThresholdImage 3 ${OUTNAME}brainmask.nii.gz ${OUTNAME}BrainThresh.nii.gz 1 999
+logCmd MultiplyImages 3 ${OUTNAME}OtsuMask.nii.gz ${OUTNAME}BrainThresh.nii.gz  ${OUTNAME}OtsuMask.nii.gz
 
 if [ ! -f ${OUTNAME}_kcbf.nii.gz ]; then
-  logCmd ${ANTSPATH}/antsNetworkAnalysis.R \
+  logCmd antsNetworkAnalysis.R \
     -o $OUTNAME \
     --freq 0.01x0.1 \
     --mask ${OUTNAME}OtsuMask.nii.gz \
@@ -298,7 +298,7 @@ if [ ! -f ${OUTNAME}_kcbf.nii.gz ]; then
     --replace $SAMPLE_WITH_REPLACEMENT
 fi
 
-logCmd ${ANTSPATH}/antsApplyTransforms -d 3 \
+logCmd antsApplyTransforms -d 3 \
     -i ${OUTNAME}_kcbf.nii.gz \
     -r $TEMPLATE \
     -o ${OUTNAME}MeanCBFWarpedToTemplate.nii.gz \
@@ -308,7 +308,7 @@ logCmd ${ANTSPATH}/antsApplyTransforms -d 3 \
     -t ${OUTNAME}1Warp.nii.gz \
     -t ${OUTNAME}0GenericAffine.mat
 
-logCmd ${ANTSPATH}/antsApplyTransforms -d 3 \
+logCmd antsApplyTransforms -d 3 \
     -i $LABELS \
     -r ${OUTNAME}AveragePCASL.nii.gz \
     -o ${OUTNAME}LabelsWarpedToPCASL.nii.gz \
@@ -318,7 +318,7 @@ logCmd ${ANTSPATH}/antsApplyTransforms -d 3 \
     -t [ ${OUTNAME}0GenericAffine.mat,1 ] \
     -t ${OUTNAME}1InverseWarp.nii.gz
 
-logCmd ${ANTSPATH}/antsApplyTransforms -d 3 \
+logCmd antsApplyTransforms -d 3 \
   -i ${OUTNAME}_kcbf.nii.gz \
   -r $ANATOMICAL_IMAGE \
   -o ${OUTNAME}MeanCBFWarpedToT1.nii.gz \
@@ -326,7 +326,7 @@ logCmd ${ANTSPATH}/antsApplyTransforms -d 3 \
   -t ${OUTNAME}1Warp.nii.gz \
   -t ${OUTNAME}0GenericAffine.mat \
 
-logCmd ${ANTSPATH}/antsApplyTransforms -d 3 \
+logCmd antsApplyTransforms -d 3 \
   -i $SEGMENTATION \
   -r ${OUTNAME}AveragePCASL.nii.gz \
   -o ${OUTNAME}SegmentationWarpedToPCASL.nii.gz \
diff --git a/Scripts/antsAtroposN4.sh b/Scripts/antsAtroposN4.sh
index f3d9d466..e924b898 100755
--- a/Scripts/antsAtroposN4.sh
+++ b/Scripts/antsAtroposN4.sh
@@ -2,12 +2,14 @@
 
 VERSION="0.0"
 
-if [[ ! -s ${ANTSPATH}/N4BiasFieldCorrection ]]; then
-  echo we cant find the N4 program -- does not seem to exist.  please \(re\)define \$ANTSPATH in your environment.
+if ! command -v N4BiasFieldCorrection &> /dev/null
+then
+  echo we cant find the N4 program -- does not seem to exist.  please \(re\)define \$PATH in your environment.
   exit
 fi
-if [[ ! -s ${ANTSPATH}/Atropos ]]; then
-  echo we cant find the Atropos program -- does not seem to exist.  please \(re\)define \$ANTSPATH in your environment.
+if ! command -v Atropos &> /dev/null
+then
+  echo we cant find the Atropos program -- does not seem to exist.  please \(re\)define \$PATH in your environment.
   exit
 fi
 
@@ -46,13 +48,13 @@ DEBUG_MODE=0
 
 N4_ATROPOS_NUMBER_OF_ITERATIONS=15
 
-N4=${ANTSPATH}/N4BiasFieldCorrection
+N4=N4BiasFieldCorrection
 N4_CONVERGENCE="[ 50x50x50x50,0.0000000001 ]"
 N4_SHRINK_FACTOR=2
 N4_BSPLINE_PARAMS="[ 200 ]"
 N4_WEIGHT_MASK_POSTERIOR_LABELS=()
 
-ATROPOS=${ANTSPATH}/Atropos
+ATROPOS=Atropos
 ATROPOS_SEGMENTATION_PRIOR_WEIGHT=0.0
 ATROPOS_SEGMENTATION_LIKELIHOOD="Gaussian"
 ATROPOS_SEGMENTATION_POSTERIOR_FORMULATION="Socrates[ 1 ]"
@@ -457,10 +459,10 @@ ATROPOS_SEGMENTATION_POSTERIORS=${ATROPOS_SEGMENTATION_OUTPUT}Posteriors%${FORMA
 
 if [[ ${DENOISE_ANATOMICAL_IMAGES} -ne 0 ]];
   then
-    if [[ ! -s ${ANTSPATH}/DenoiseImage ]];
+    if [[ ! -s DenoiseImage ]];
       then
         echo "Error:  we can't find the DenoiseImage program."
-        echo "Perhaps you need to \(re\)define \$ANTSPATH in your environment or update your repository."
+        echo "Perhaps you need to \(re\)define \$PATH in your environment or update your repository."
         exit
       fi
   fi
@@ -472,10 +474,10 @@ for (( j = 0; j < ${#ANATOMICAL_IMAGES[@]}; j++ ))
   do
     SEGMENTATION_PREPROCESSED_IMAGES=( ${SEGMENTATION_PREPROCESSED_IMAGES[@]} ${ATROPOS_SEGMENTATION_OUTPUT}PreprocessedAnatomical${j}.${OUTPUT_SUFFIX} )
     # Truncate on the whole head to get outliers over the whole volume, without losing contrast in the brain
-    logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${SEGMENTATION_PREPROCESSED_IMAGES[$j]} TruncateImageIntensity ${ANATOMICAL_IMAGES[$j]} 0 0.995 256
+    logCmd ImageMath ${DIMENSION} ${SEGMENTATION_PREPROCESSED_IMAGES[$j]} TruncateImageIntensity ${ANATOMICAL_IMAGES[$j]} 0 0.995 256
     if [[ ${DENOISE_ANATOMICAL_IMAGES} -ne 0 ]];
       then
-        logCmd ${ANTSPATH}/DenoiseImage -d ${DIMENSION} -i ${SEGMENTATION_PREPROCESSED_IMAGES[$j]} -o ${SEGMENTATION_PREPROCESSED_IMAGES[$j]} --verbose 1
+        logCmd DenoiseImage -d ${DIMENSION} -i ${SEGMENTATION_PREPROCESSED_IMAGES[$j]} -o ${SEGMENTATION_PREPROCESSED_IMAGES[$j]} --verbose 1
       fi
   done
 
@@ -508,7 +510,7 @@ if [[ $INITIALIZE_WITH_KMEANS -eq 0 ]]
 
     if [[ ${#N4_WEIGHT_MASK_IMAGES[@]} -gt 0 ]];
       then
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${SEGMENTATION_WEIGHT_MASK} PureTissueN4WeightMask ${N4_WEIGHT_MASK_IMAGES[@]}
+        logCmd ImageMath ${DIMENSION} ${SEGMENTATION_WEIGHT_MASK} PureTissueN4WeightMask ${N4_WEIGHT_MASK_IMAGES[@]}
       fi
   fi
 
@@ -530,8 +532,8 @@ for (( i = 0; i < ${N4_ATROPOS_NUMBER_OF_ITERATIONS}; i++ ))
             exe_n4_correction="${exe_n4_correction} -w ${SEGMENTATION_WEIGHT_MASK}"
           fi
         logCmd $exe_n4_correction
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${SEGMENTATION_N4_IMAGES[$j]} Normalize ${SEGMENTATION_N4_IMAGES[$j]}
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${SEGMENTATION_N4_IMAGES[$j]} m ${SEGMENTATION_N4_IMAGES[$j]} 1000
+        logCmd ImageMath ${DIMENSION} ${SEGMENTATION_N4_IMAGES[$j]} Normalize ${SEGMENTATION_N4_IMAGES[$j]}
+        logCmd ImageMath ${DIMENSION} ${SEGMENTATION_N4_IMAGES[$j]} m ${SEGMENTATION_N4_IMAGES[$j]} 1000
       done
 
     ATROPOS_ANATOMICAL_IMAGES_COMMAND_LINE=''
@@ -642,7 +644,7 @@ for (( i = 0; i < ${N4_ATROPOS_NUMBER_OF_ITERATIONS}; i++ ))
 
     if [[ ${#N4_WEIGHT_MASK_IMAGES[@]} -gt 0 ]];
       then
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${SEGMENTATION_WEIGHT_MASK} PureTissueN4WeightMask ${N4_WEIGHT_MASK_IMAGES[@]}
+        logCmd ImageMath ${DIMENSION} ${SEGMENTATION_WEIGHT_MASK} PureTissueN4WeightMask ${N4_WEIGHT_MASK_IMAGES[@]}
       fi
 
   done
diff --git a/Scripts/antsBrainExtraction.sh b/Scripts/antsBrainExtraction.sh
index 3f44c6ed..13535e48 100755
--- a/Scripts/antsBrainExtraction.sh
+++ b/Scripts/antsBrainExtraction.sh
@@ -2,20 +2,24 @@
 
 VERSION="0.0"
 
-if [[ ! -s ${ANTSPATH}/N4BiasFieldCorrection ]]; then
-  echo we cant find the N4 program -- does not seem to exist.  please \(re\)define \$ANTSPATH in your environment.
+if ! command -v N4BiasFieldCorrection &> /dev/null
+then
+  echo we cant find the N4 program -- does not seem to exist.  please \(re\)define \$PATH in your environment.
   exit
 fi
-if [[ ! -s ${ANTSPATH}/Atropos ]]; then
-  echo we cant find the Atropos program -- does not seem to exist.  please \(re\)define \$ANTSPATH in your environment.
+if ! command -v Atropos &> /dev/null
+then
+  echo we cant find the Atropos program -- does not seem to exist.  please \(re\)define \$PATH in your environment.
   exit
 fi
-if [[ ! -s ${ANTSPATH}/antsRegistration ]]; then
-  echo we cant find the antsRegistration program -- does not seem to exist.  please \(re\)define \$ANTSPATH in your environment.
+if ! command -v antsRegistration &> /dev/null
+then
+  echo we cant find the antsRegistration program -- does not seem to exist.  please \(re\)define \$PATH in your environment.
   exit
 fi
-if [[ ! -s ${ANTSPATH}/antsApplyTransforms ]]; then
-  echo we cant find the antsApplyTransforms program -- does not seem to exist.  please \(re\)define \$ANTSPATH in your environment.
+if ! command -v antsApplyTransforms &> /dev/null
+then
+  echo we cant find the antsApplyTransforms program -- does not seem to exist.  please \(re\)define \$PATH in your environment.
   exit
 fi
 
@@ -53,7 +57,7 @@ USER_INITIAL_AFFINE=""
 ################################################################################
 
 
-ATROPOS=${ANTSPATH}/Atropos
+ATROPOS=Atropos
 ATROPOS_NUM_CLASSES=3
 ATROPOS_CSF_CLASS_LABEL=1
 ATROPOS_GM_CLASS_LABEL=2
@@ -62,7 +66,7 @@ ATROPOS_BRAIN_EXTRACTION_INITIALIZATION="kmeans[ ${ATROPOS_NUM_CLASSES} ]"
 ATROPOS_BRAIN_EXTRACTION_LIKELIHOOD="Gaussian"
 ATROPOS_BRAIN_EXTRACTION_CONVERGENCE="[ 3,0.0 ]"
 
-ANTS=${ANTSPATH}/antsRegistration
+ANTS=antsRegistration
 ANTS_MAX_ITERATIONS="100x100x70x20"
 ANTS_TRANSFORMATION="SyN[ 0.1,3,0 ]"
 ANTS_LINEAR_METRIC_PARAMS="1,32,Regular,0.25"
@@ -70,9 +74,9 @@ ANTS_LINEAR_CONVERGENCE="[ 1000x500x250x100,1e-8,10 ]"
 ANTS_METRIC="CC"
 ANTS_METRIC_PARAMS="1,4"
 
-WARP=${ANTSPATH}/antsApplyTransforms
+WARP=antsApplyTransforms
 
-N4=${ANTSPATH}/N4BiasFieldCorrection
+N4=N4BiasFieldCorrection
 N4_CONVERGENCE_1="[ 50x50x50x50,0.0000001 ]"
 N4_CONVERGENCE_2="[ 50x50x50x50,0.0000001 ]"
 N4_SHRINK_FACTOR_1=4
@@ -433,7 +437,7 @@ if [[ ! -f ${EXTRACTION_MASK} || ! -f ${EXTRACTION_WM} ]];
 
         if [[ ! -f ${N4_CORRECTED_IMAGE} ]];
           then
-            logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${N4_TRUNCATED_IMAGE} TruncateImageIntensity ${ANATOMICAL_IMAGES[$i]} 0.01 0.999 256
+            logCmd ImageMath ${DIMENSION} ${N4_TRUNCATED_IMAGE} TruncateImageIntensity ${ANATOMICAL_IMAGES[$i]} 0.01 0.999 256
 
             exe_n4_correction="${N4} -d ${DIMENSION} -i ${N4_TRUNCATED_IMAGE} -s ${N4_SHRINK_FACTOR_1} -c ${N4_CONVERGENCE_1} -b ${N4_BSPLINE_PARAMS} -o ${N4_CORRECTED_IMAGE} --verbose 1"
             logCmd $exe_n4_correction
@@ -477,16 +481,16 @@ if [[ ! -f ${EXTRACTION_MASK} || ! -f ${EXTRACTION_WM} ]];
         echo
 
         ## Step 1 ##
-          logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTION_LAPLACIAN} Laplacian ${N4_CORRECTED_IMAGES[0]} 1.5 1
-          logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTION_TEMPLATE_LAPLACIAN} Laplacian ${EXTRACTION_TEMPLATE} 1.5 1
+          logCmd ImageMath ${DIMENSION} ${EXTRACTION_LAPLACIAN} Laplacian ${N4_CORRECTED_IMAGES[0]} 1.5 1
+          logCmd ImageMath ${DIMENSION} ${EXTRACTION_TEMPLATE_LAPLACIAN} Laplacian ${EXTRACTION_TEMPLATE} 1.5 1
 
           if [[ ! -f "${USER_INITIAL_AFFINE}" ]]
             then
 
-              logCmd ${ANTSPATH}/ResampleImageBySpacing ${DIMENSION} ${EXTRACTION_TEMPLATE} ${EXTRACTION_INITIAL_AFFINE_FIXED} 4 4 4 1
-              logCmd ${ANTSPATH}/ResampleImageBySpacing ${DIMENSION} ${N4_CORRECTED_IMAGES[0]} ${EXTRACTION_INITIAL_AFFINE_MOVING} 4 4 4 1
+              logCmd ResampleImageBySpacing ${DIMENSION} ${EXTRACTION_TEMPLATE} ${EXTRACTION_INITIAL_AFFINE_FIXED} 4 4 4 1
+              logCmd ResampleImageBySpacing ${DIMENSION} ${N4_CORRECTED_IMAGES[0]} ${EXTRACTION_INITIAL_AFFINE_MOVING} 4 4 4 1
 
-              exe_initial_align="${ANTSPATH}/antsAI -d ${DIMENSION} -v 1"
+              exe_initial_align="antsAI -d ${DIMENSION} -v 1"
               exe_initial_align="${exe_initial_align} -m Mattes[ ${EXTRACTION_INITIAL_AFFINE_FIXED},${EXTRACTION_INITIAL_AFFINE_MOVING},32,Regular,0.2 ]"
               exe_initial_align="${exe_initial_align} -t Affine[ 0.1 ]"
               exe_initial_align="${exe_initial_align} -s [ 20,0.12 ]"
@@ -502,7 +506,7 @@ if [[ ! -f ${EXTRACTION_MASK} || ! -f ${EXTRACTION_WM} ]];
 
               logCmd $exe_initial_align
             else
-              ${ANTSPATH}/antsApplyTransforms -d ${DIMENSION} -t ${USER_INITIAL_AFFINE} -o Linear[ ${EXTRACTION_INITIAL_AFFINE}, 0 ]
+              antsApplyTransforms -d ${DIMENSION} -t ${USER_INITIAL_AFFINE} -o Linear[ ${EXTRACTION_INITIAL_AFFINE}, 0 ]
             fi
 
           basecall="${ANTS} -d ${DIMENSION} -u 1 -w [ 0.025,0.975 ] -o ${EXTRACTION_WARP_OUTPUT_PREFIX} -r ${EXTRACTION_INITIAL_AFFINE} -z 1 --float ${USE_FLOAT_PRECISION} --verbose 1"
@@ -544,9 +548,9 @@ if [[ ! -f ${EXTRACTION_MASK} || ! -f ${EXTRACTION_WM} ]];
         logCmd $exe_brain_extraction_2
 
         ## superstep 1b ##
-        logCmd ${ANTSPATH}/ThresholdImage ${DIMENSION} ${EXTRACTION_MASK_PRIOR_WARPED} ${EXTRACTION_MASK_PRIOR_WARPED} 0.5 1 1 0
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTION_MASK} MD ${EXTRACTION_MASK_PRIOR_WARPED} 2
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTION_MASK} GetLargestComponent ${EXTRACTION_MASK}
+        logCmd ThresholdImage ${DIMENSION} ${EXTRACTION_MASK_PRIOR_WARPED} ${EXTRACTION_MASK_PRIOR_WARPED} 0.5 1 1 0
+        logCmd ImageMath ${DIMENSION} ${EXTRACTION_MASK} MD ${EXTRACTION_MASK_PRIOR_WARPED} 2
+        logCmd ImageMath ${DIMENSION} ${EXTRACTION_MASK} GetLargestComponent ${EXTRACTION_MASK}
 
         ## superstep 6 ##
         ATROPOS_ANATOMICAL_IMAGES_COMMAND_LINE='';
@@ -562,50 +566,50 @@ if [[ ! -f ${EXTRACTION_MASK} || ! -f ${EXTRACTION_WM} ]];
        # Pad image here to avoid errors from dilating into the edge of the image
         padVoxels=10
 
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTION_SEGMENTATION} PadImage ${EXTRACTION_SEGMENTATION} $padVoxels
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTION_MASK_PRIOR_WARPED} PadImage ${EXTRACTION_MASK_PRIOR_WARPED} $padVoxels
+        logCmd ImageMath ${DIMENSION} ${EXTRACTION_SEGMENTATION} PadImage ${EXTRACTION_SEGMENTATION} $padVoxels
+        logCmd ImageMath ${DIMENSION} ${EXTRACTION_MASK_PRIOR_WARPED} PadImage ${EXTRACTION_MASK_PRIOR_WARPED} $padVoxels
 
-        logCmd ${ANTSPATH}/ThresholdImage ${DIMENSION} ${EXTRACTION_SEGMENTATION} ${EXTRACTION_WM} ${ATROPOS_WM_CLASS_LABEL} ${ATROPOS_WM_CLASS_LABEL} 1 0
-        logCmd ${ANTSPATH}/ThresholdImage ${DIMENSION} ${EXTRACTION_SEGMENTATION} ${EXTRACTION_GM} ${ATROPOS_GM_CLASS_LABEL} ${ATROPOS_GM_CLASS_LABEL} 1 0
-        logCmd ${ANTSPATH}/ThresholdImage ${DIMENSION} ${EXTRACTION_SEGMENTATION} ${EXTRACTION_CSF} ${ATROPOS_CSF_CLASS_LABEL} ${ATROPOS_CSF_CLASS_LABEL} 1 0
+        logCmd ThresholdImage ${DIMENSION} ${EXTRACTION_SEGMENTATION} ${EXTRACTION_WM} ${ATROPOS_WM_CLASS_LABEL} ${ATROPOS_WM_CLASS_LABEL} 1 0
+        logCmd ThresholdImage ${DIMENSION} ${EXTRACTION_SEGMENTATION} ${EXTRACTION_GM} ${ATROPOS_GM_CLASS_LABEL} ${ATROPOS_GM_CLASS_LABEL} 1 0
+        logCmd ThresholdImage ${DIMENSION} ${EXTRACTION_SEGMENTATION} ${EXTRACTION_CSF} ${ATROPOS_CSF_CLASS_LABEL} ${ATROPOS_CSF_CLASS_LABEL} 1 0
 
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTION_WM} GetLargestComponent ${EXTRACTION_WM}
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTION_GM} GetLargestComponent ${EXTRACTION_GM}
+        logCmd ImageMath ${DIMENSION} ${EXTRACTION_WM} GetLargestComponent ${EXTRACTION_WM}
+        logCmd ImageMath ${DIMENSION} ${EXTRACTION_GM} GetLargestComponent ${EXTRACTION_GM}
 
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTION_TMP} FillHoles ${EXTRACTION_GM} 2
-        logCmd ${ANTSPATH}/MultiplyImages ${DIMENSION} ${EXTRACTION_GM} ${EXTRACTION_TMP} ${EXTRACTION_GM}
+        logCmd ImageMath ${DIMENSION} ${EXTRACTION_TMP} FillHoles ${EXTRACTION_GM} 2
+        logCmd MultiplyImages ${DIMENSION} ${EXTRACTION_GM} ${EXTRACTION_TMP} ${EXTRACTION_GM}
 
-        logCmd ${ANTSPATH}/MultiplyImages ${DIMENSION} ${EXTRACTION_WM} ${ATROPOS_WM_CLASS_LABEL} ${EXTRACTION_WM}
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTION_TMP} ME ${EXTRACTION_CSF} 10
+        logCmd MultiplyImages ${DIMENSION} ${EXTRACTION_WM} ${ATROPOS_WM_CLASS_LABEL} ${EXTRACTION_WM}
+        logCmd ImageMath ${DIMENSION} ${EXTRACTION_TMP} ME ${EXTRACTION_CSF} 10
 
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTION_GM} addtozero ${EXTRACTION_GM} ${EXTRACTION_TMP}
-        logCmd ${ANTSPATH}/MultiplyImages ${DIMENSION} ${EXTRACTION_GM} ${ATROPOS_GM_CLASS_LABEL} ${EXTRACTION_GM}
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTION_SEGMENTATION} addtozero ${EXTRACTION_WM} ${EXTRACTION_GM}
+        logCmd ImageMath ${DIMENSION} ${EXTRACTION_GM} addtozero ${EXTRACTION_GM} ${EXTRACTION_TMP}
+        logCmd MultiplyImages ${DIMENSION} ${EXTRACTION_GM} ${ATROPOS_GM_CLASS_LABEL} ${EXTRACTION_GM}
+        logCmd ImageMath ${DIMENSION} ${EXTRACTION_SEGMENTATION} addtozero ${EXTRACTION_WM} ${EXTRACTION_GM}
 
         ## superstep 7 ##
-        logCmd ${ANTSPATH}/ThresholdImage ${DIMENSION} ${EXTRACTION_SEGMENTATION} ${EXTRACTION_MASK} ${ATROPOS_WM_CLASS_LABEL} ${ATROPOS_WM_CLASS_LABEL} 1 0
-        logCmd ${ANTSPATH}/ThresholdImage ${DIMENSION} ${EXTRACTION_SEGMENTATION} ${EXTRACTION_TMP} ${ATROPOS_GM_CLASS_LABEL} ${ATROPOS_GM_CLASS_LABEL} 1 0
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTION_MASK} addtozero ${EXTRACTION_MASK} ${EXTRACTION_TMP}
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTION_MASK} ME ${EXTRACTION_MASK} 2
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTION_MASK} GetLargestComponent ${EXTRACTION_MASK}
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTION_MASK} MD ${EXTRACTION_MASK} 4
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTION_MASK} FillHoles ${EXTRACTION_MASK} 2
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTION_MASK} addtozero ${EXTRACTION_MASK} ${EXTRACTION_MASK_PRIOR_WARPED}
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTION_MASK} MD ${EXTRACTION_MASK} 5
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTION_MASK} ME ${EXTRACTION_MASK} 5
+        logCmd ThresholdImage ${DIMENSION} ${EXTRACTION_SEGMENTATION} ${EXTRACTION_MASK} ${ATROPOS_WM_CLASS_LABEL} ${ATROPOS_WM_CLASS_LABEL} 1 0
+        logCmd ThresholdImage ${DIMENSION} ${EXTRACTION_SEGMENTATION} ${EXTRACTION_TMP} ${ATROPOS_GM_CLASS_LABEL} ${ATROPOS_GM_CLASS_LABEL} 1 0
+        logCmd ImageMath ${DIMENSION} ${EXTRACTION_MASK} addtozero ${EXTRACTION_MASK} ${EXTRACTION_TMP}
+        logCmd ImageMath ${DIMENSION} ${EXTRACTION_MASK} ME ${EXTRACTION_MASK} 2
+        logCmd ImageMath ${DIMENSION} ${EXTRACTION_MASK} GetLargestComponent ${EXTRACTION_MASK}
+        logCmd ImageMath ${DIMENSION} ${EXTRACTION_MASK} MD ${EXTRACTION_MASK} 4
+        logCmd ImageMath ${DIMENSION} ${EXTRACTION_MASK} FillHoles ${EXTRACTION_MASK} 2
+        logCmd ImageMath ${DIMENSION} ${EXTRACTION_MASK} addtozero ${EXTRACTION_MASK} ${EXTRACTION_MASK_PRIOR_WARPED}
+        logCmd ImageMath ${DIMENSION} ${EXTRACTION_MASK} MD ${EXTRACTION_MASK} 5
+        logCmd ImageMath ${DIMENSION} ${EXTRACTION_MASK} ME ${EXTRACTION_MASK} 5
 
         # De-pad
         for img in ${EXTRACTION_SEGMENTATION} ${EXTRACTION_MASK} ${EXTRACTION_WM} ${EXTRACTION_GM} ${EXTRACTION_CSF} ${EXTRACTION_MASK_PRIOR_WARPED}
           do
-            logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${img} PadImage ${img} -$padVoxels
+            logCmd ImageMath ${DIMENSION} ${img} PadImage ${img} -$padVoxels
           done
 
 
-        logCmd ${ANTSPATH}/MultiplyImages ${DIMENSION} ${N4_CORRECTED_IMAGES[0]} ${EXTRACTION_MASK} ${EXTRACTION_BRAIN}
+        logCmd MultiplyImages ${DIMENSION} ${N4_CORRECTED_IMAGES[0]} ${EXTRACTION_MASK} ${EXTRACTION_BRAIN}
 
         # Copy header information from original image into output
-        logCmd ${ANTSPATH}/CopyImageHeaderInformation ${ANATOMICAL_IMAGES[0]} ${EXTRACTION_BRAIN} ${EXTRACTION_BRAIN} 1 1 1 0
-        logCmd ${ANTSPATH}/CopyImageHeaderInformation ${ANATOMICAL_IMAGES[0]} ${EXTRACTION_MASK} ${EXTRACTION_MASK} 1 1 1 0
+        logCmd CopyImageHeaderInformation ${ANATOMICAL_IMAGES[0]} ${EXTRACTION_BRAIN} ${EXTRACTION_BRAIN} 1 1 1 0
+        logCmd CopyImageHeaderInformation ${ANATOMICAL_IMAGES[0]} ${EXTRACTION_MASK} ${EXTRACTION_MASK} 1 1 1 0
 
 
     if [[ ! -f ${EXTRACTION_MASK} ]];
diff --git a/Scripts/antsCookTemplatePriors.sh b/Scripts/antsCookTemplatePriors.sh
index c00695f4..2d435821 100644
--- a/Scripts/antsCookTemplatePriors.sh
+++ b/Scripts/antsCookTemplatePriors.sh
@@ -9,20 +9,20 @@ SCRIPTS_DEPENDENCIES=( 'antsCorticalThickness.sh' 'antsBrainExtraction.sh' 'ants
 
 for D in ${PROGRAM_DEPENDENCIES[@]};
   do
-    if [[ ! -s ${ANTSPATH}/${D} ]];
+    if ! command -v ${D} &> /dev/null
       then
         echo "Error:  we can't find the $D program."
-        echo "Perhaps you need to \(re\)define \$ANTSPATH in your environment."
+        echo "Perhaps you need to \(re\)define \$PATH in your environment."
         exit
       fi
   done
 
 for D in ${SCRIPT_DEPENDENCIES[@]};
   do
-    if [[ ! -s ${ANTSPATH}/${D} ]];
+    if ! command -v ${D} &> /dev/null
       then
         echo "We can't find the $D script."
-        echo "Perhaps you need to \(re\)define \$ANTSPATH in your environment."
+        echo "Perhaps you need to \(re\)define \$PATH in your environment."
         exit
       fi
   done
@@ -498,7 +498,7 @@ fi
 
 if [[ ! -f ${TEMPLATE_CORTICAL_THICKNESS} ]];
   then
-    logCmd ${ANTSPATH}/antsCorticalThickness.sh \
+    logCmd antsCorticalThickness.sh \
       -d ${DIMENSION} \
       -q ${RUN_FAST_ANTSCT_TO_GROUP_TEMPLATE} \
       $TEMPLATE_IMAGES_LIST \
@@ -543,9 +543,9 @@ if [[ ${TEMPLATE_POSTERIORS_EXIST} -eq 0 ]];
     exit 1
   fi
 
-logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${TEMPLATE_SKULL_STRIPPED} m ${TEMPLATE_IMAGES[0]} ${TEMPLATE_EXTRACTION_MASK}
-logCmd ${ANTSPATH}/SmoothImage ${DIMENSION} ${TEMPLATE_EXTRACTION_MASK} 1 ${TEMPLATE_EXTRACTION_PRIOR} 1
-logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${TEMPLATE_EXTRACTION_REGISTRATION_MASK} MD ${TEMPLATE_EXTRACTION_MASK} 40
+logCmd ImageMath ${DIMENSION} ${TEMPLATE_SKULL_STRIPPED} m ${TEMPLATE_IMAGES[0]} ${TEMPLATE_EXTRACTION_MASK}
+logCmd SmoothImage ${DIMENSION} ${TEMPLATE_EXTRACTION_MASK} 1 ${TEMPLATE_EXTRACTION_PRIOR} 1
+logCmd ImageMath ${DIMENSION} ${TEMPLATE_EXTRACTION_REGISTRATION_MASK} MD ${TEMPLATE_EXTRACTION_MASK} 40
 
 if [[ ${TEMPLATE_PRIORS_EXIST} -eq 0 ]];
   then
@@ -559,7 +559,7 @@ if [[ ${TEMPLATE_PRIORS_EXIST} -eq 0 ]];
         for j in ${TEMPLATE_POSTERIORS[@]}
           do
             PRIOR=${j/BrainSegmentationPosteriors/Priors}
-            logCmd ${ANTSPATH}/SmoothImage ${DIMENSION} $j 1 $PRIOR 1
+            logCmd SmoothImage ${DIMENSION} $j 1 $PRIOR 1
           done
 
       else
@@ -579,7 +579,7 @@ if [[ ${TEMPLATE_PRIORS_EXIST} -eq 0 ]];
 
         if [[ ! -f ${TEMPLATE_MALF_LABELS} ]];
           then
-            logCmd ${ANTSPATH}/antsJointLabelFusion.sh \
+            logCmd antsJointLabelFusion.sh \
               -d ${DIMENSION} \
               -q ${RUN_FAST_MALF_COOKING} \
               -x ${TEMPLATE_EXTRACTION_MASK} \
@@ -598,24 +598,24 @@ if [[ ${TEMPLATE_PRIORS_EXIST} -eq 0 ]];
             TEMPLATE_PRIORS[$j]=${POSTERIOR/BrainSegmentationPosteriors/Priors}
 
             let PRIOR_LABEL=$j+1
-            logCmd ${ANTSPATH}/ThresholdImage ${DIMENSION} ${TEMPLATE_MALF_LABELS} ${TEMPLATE_PRIORS[$j]} ${PRIOR_LABEL} ${PRIOR_LABEL} 1 0
-            logCmd ${ANTSPATH}/SmoothImage ${DIMENSION} ${TEMPLATE_PRIORS[$j]} 1 ${TEMPLATE_PRIORS[$j]} 1
+            logCmd ThresholdImage ${DIMENSION} ${TEMPLATE_MALF_LABELS} ${TEMPLATE_PRIORS[$j]} ${PRIOR_LABEL} ${PRIOR_LABEL} 1 0
+            logCmd SmoothImage ${DIMENSION} ${TEMPLATE_PRIORS[$j]} 1 ${TEMPLATE_PRIORS[$j]} 1
           done
 
         TMP_CSF_POSTERIOR=${OUTPUT_PREFIX}BrainSegmentationCsfPosteriorTmp.${OUTPUT_SUFFIX}
-        logCmd ${ANTSPATH}/SmoothImage ${DIMENSION} ${TEMPLATE_POSTERIORS[0]} 1 ${TMP_CSF_POSTERIOR} 1
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${TEMPLATE_PRIORS[0]} max ${TEMPLATE_PRIORS[0]} ${TMP_CSF_POSTERIOR}
+        logCmd SmoothImage ${DIMENSION} ${TEMPLATE_POSTERIORS[0]} 1 ${TMP_CSF_POSTERIOR} 1
+        logCmd ImageMath ${DIMENSION} ${TEMPLATE_PRIORS[0]} max ${TEMPLATE_PRIORS[0]} ${TMP_CSF_POSTERIOR}
         # Clip priors to remove precision errors
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${TEMPLATE_PRIORS[0]} WindowImage ${TEMPLATE_PRIORS[0]} 0 1 0 1
+        logCmd ImageMath ${DIMENSION} ${TEMPLATE_PRIORS[0]} WindowImage ${TEMPLATE_PRIORS[0]} 0 1 0 1
 
         # Brian's finishing touches on "cooking"---subtract out CSF from all other priors
         for (( j = 1; j < ${#TEMPLATE_PRIORS[@]}; j++ ))
           do
             let PRIOR_LABEL=$j+1
 
-            logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${TEMPLATE_PRIORS[$j]} - ${TEMPLATE_PRIORS[$j]} ${TEMPLATE_PRIORS[0]}
+            logCmd ImageMath ${DIMENSION} ${TEMPLATE_PRIORS[$j]} - ${TEMPLATE_PRIORS[$j]} ${TEMPLATE_PRIORS[0]}
             # Clip priors to range [0,1]
-            logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${TEMPLATE_PRIORS[$j]} WindowImage ${TEMPLATE_PRIORS[$j]} 0 1 0 1
+            logCmd ImageMath ${DIMENSION} ${TEMPLATE_PRIORS[$j]} WindowImage ${TEMPLATE_PRIORS[$j]} 0 1 0 1
           done
 
         logCmd rm -f $TMP_CSF_POSTERIOR
diff --git a/Scripts/antsCorticalThickness.sh b/Scripts/antsCorticalThickness.sh
index ee4f7a48..aa5540a9 100755
--- a/Scripts/antsCorticalThickness.sh
+++ b/Scripts/antsCorticalThickness.sh
@@ -9,20 +9,20 @@ SCRIPTS_DEPENDENCIES=( 'antsBrainExtraction.sh' 'antsAtroposN4.sh' )
 
 for D in ${PROGRAM_DEPENDENCIES[@]};
   do
-    if [[ ! -s ${ANTSPATH}/${D} ]];
+    if ! command -v ${D} &> /dev/null 
       then
         echo "Error:  we can't find the $D program."
-        echo "Perhaps you need to \(re\)define \$ANTSPATH in your environment."
+        echo "Perhaps you need to \(re\)define \$PATH in your environment."
         exit
       fi
   done
 
 for D in ${SCRIPT_DEPENDENCIES[@]};
   do
-    if [[ ! -s ${ANTSPATH}/${D} ]];
+    if ! command -v ${D} &> /dev/null 
       then
         echo "We can't find the $D script."
-        echo "Perhaps you need to \(re\)define \$ANTSPATH in your environment."
+        echo "Perhaps you need to \(re\)define \$PATH in your environment."
         exit
       fi
   done
@@ -370,7 +370,7 @@ ATROPOS_SEGMENTATION_PRIOR_WEIGHT=0.25
 #
 ################################################################################
 
-ANTS=${ANTSPATH}/antsRegistration
+ANTS=antsRegistration
 ANTS_MAX_ITERATIONS="100x100x70x20"
 ANTS_TRANSFORMATION="SyN[ 0.1,3,0 ]"
 ANTS_LINEAR_METRIC_PARAMS="1,32,Regular,0.25"
@@ -378,16 +378,16 @@ ANTS_LINEAR_CONVERGENCE="[ 1000x500x250x100,1e-8,10 ]"
 ANTS_METRIC="CC"
 ANTS_METRIC_PARAMS="1,4"
 
-WARP=${ANTSPATH}/antsApplyTransforms
+WARP=antsApplyTransforms
 
-N4=${ANTSPATH}/N4BiasFieldCorrection
+N4=N4BiasFieldCorrection
 N4_CONVERGENCE_1="[ 50x50x50x50,0.0000001 ]"
 N4_CONVERGENCE_2="[ 50x50x50x50,0.0000001 ]"
 N4_SHRINK_FACTOR_1=4
 N4_SHRINK_FACTOR_2=2
 N4_BSPLINE_PARAMS="[ 200 ]"
 
-ATROPOS=${ANTSPATH}/Atropos
+ATROPOS=Atropos
 
 ATROPOS_SEGMENTATION_INITIALIZATION="PriorProbabilityImages"
 ATROPOS_SEGMENTATION_LIKELIHOOD="Gaussian"
@@ -397,7 +397,7 @@ ATROPOS_SEGMENTATION_NUMBER_OF_ITERATIONS=3
 ATROPOS_SEGMENTATION_INTERNAL_ITERATIONS=5 # to be backward compatible but i like 25
 ATROPOS_SEGMENTATION_LABEL_PROPAGATION=()
 
-DIRECT=${ANTSPATH}/KellyKapowski
+DIRECT=KellyKapowski
 DIRECT_CONVERGENCE="[ 45,0.0,10 ]"
 DIRECT_THICKNESS_PRIOR="10"
 DIRECT_GRAD_STEP_SIZE="0.025"
@@ -746,7 +746,7 @@ if [[ ! -f ${BRAIN_EXTRACTION_MASK} ]];
 
     if [[ -f ${EXTRACTION_REGISTRATION_MASK} ]]
       then
-        logCmd ${ANTSPATH}/antsBrainExtraction.sh \
+        logCmd antsBrainExtraction.sh \
           -d ${DIMENSION} \
           -a ${ANATOMICAL_IMAGES[0]} \
           -e ${BRAIN_TEMPLATE} \
@@ -759,7 +759,7 @@ if [[ ! -f ${BRAIN_EXTRACTION_MASK} ]];
           -u ${USE_RANDOM_SEEDING} \
           -z ${DEBUG_MODE}
       else
-        logCmd ${ANTSPATH}/antsBrainExtraction.sh \
+        logCmd antsBrainExtraction.sh \
           -d ${DIMENSION} \
           -a ${ANATOMICAL_IMAGES[0]} \
           -e ${BRAIN_TEMPLATE} \
@@ -776,7 +776,7 @@ if [[ ! -f ${BRAIN_EXTRACTION_MASK} ]];
 
 if [[ ! -f ${EXTRACTED_SEGMENTATION_BRAIN} ]];
   then
-    logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTED_SEGMENTATION_BRAIN} m ${ANATOMICAL_IMAGES[0]} ${BRAIN_EXTRACTION_MASK}
+    logCmd ImageMath ${DIMENSION} ${EXTRACTED_SEGMENTATION_BRAIN} m ${ANATOMICAL_IMAGES[0]} ${BRAIN_EXTRACTION_MASK}
 
     # Do a quick N4 on the brain before registration
     logCmd $N4 -d ${DIMENSION} -i ${EXTRACTED_SEGMENTATION_BRAIN} -s ${N4_SHRINK_FACTOR_1} -c ${N4_CONVERGENCE_1} -o ${EXTRACTED_SEGMENTATION_BRAIN} -x ${BRAIN_EXTRACTION_MASK} -b ${N4_BSPLINE_PARAMS}
@@ -785,8 +785,8 @@ if [[ ! -f ${EXTRACTED_SEGMENTATION_BRAIN} ]];
 
 if [[ -f ${BRAIN_TEMPLATE} ]] && [[ ! -f ${EXTRACTED_BRAIN_TEMPLATE} ]];
   then
-    logCmd ${ANTSPATH}/ThresholdImage ${DIMENSION} ${EXTRACTION_PRIOR} ${EXTRACTED_BRAIN_TEMPLATE} 0.1 1.01 1 0
-    logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTED_BRAIN_TEMPLATE} m ${BRAIN_TEMPLATE} ${EXTRACTED_BRAIN_TEMPLATE}
+    logCmd ThresholdImage ${DIMENSION} ${EXTRACTION_PRIOR} ${EXTRACTED_BRAIN_TEMPLATE} 0.1 1.01 1 0
+    logCmd ImageMath ${DIMENSION} ${EXTRACTED_BRAIN_TEMPLATE} m ${BRAIN_TEMPLATE} ${EXTRACTED_BRAIN_TEMPLATE}
   fi
 echo ${OUTPUT_PREFIX}ACTStage1Complete.txt > ${OUTPUT_PREFIX}ACTStage1Complete.txt
 fi # BAStages
@@ -860,14 +860,14 @@ if [[ ! -s ${OUTPUT_PREFIX}ACTStage2Complete.txt ]]  && \
 
         if [[ ! -f ${SEGMENTATION_WARP} ]];
           then
-            logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${SEGMENTATION_MASK_DILATED} MD ${BRAIN_EXTRACTION_MASK} 20
+            logCmd ImageMath ${DIMENSION} ${SEGMENTATION_MASK_DILATED} MD ${BRAIN_EXTRACTION_MASK} 20
 
             basecall=''
             if [[ ${RUN_QUICK} -ne 0 ]];
               then
                 TMP_FILES=( ${TMP_FILES[@]} "${SEGMENTATION_WARP_OUTPUT_PREFIX}Warped.nii.gz" "${SEGMENTATION_WARP_OUTPUT_PREFIX}InverseWarped.nii.gz" )
 
-                basecall="${ANTSPATH}/antsRegistrationSyNQuick.sh -d ${DIMENSION} -f ${EXTRACTED_SEGMENTATION_BRAIN}"
+                basecall="antsRegistrationSyNQuick.sh -d ${DIMENSION} -f ${EXTRACTED_SEGMENTATION_BRAIN}"
                 basecall="${basecall} -m ${EXTRACTED_BRAIN_TEMPLATE} -o ${SEGMENTATION_WARP_OUTPUT_PREFIX} -j 1"
                 if [[ ${USE_FLOAT_PRECISION} -ne 0 ]];
                   then
@@ -897,7 +897,7 @@ if [[ ! -s ${OUTPUT_PREFIX}ACTStage2Complete.txt ]]  && \
             # a perfect copy. But hopefully close enough
             for img in ${BRAIN_EXTRACTION_MASK} ${EXTRACTED_SEGMENTATION_BRAIN} ${SEGMENTATION_MASK_DILATED};
               do
-                logCmd ${ANTSPATH}/CopyImageHeaderInformation ${ANATOMICAL_IMAGES[0]} ${img} ${img} 1 1 1
+                logCmd CopyImageHeaderInformation ${ANATOMICAL_IMAGES[0]} ${img} ${img} 1 1 1
               done
 
             logCmd $exe_brain_segmentation_1
@@ -974,7 +974,7 @@ if [[ ! -s ${OUTPUT_PREFIX}ACTStage3Complete.txt ]] && \
         N4_INCLUDE_PRIORS_COMMAND_LINE="${N4_INCLUDE_PRIORS_COMMAND_LINE} -y $j";
       done
 
-    logCmd ${ANTSPATH}/antsAtroposN4.sh \
+    logCmd antsAtroposN4.sh \
       -d ${DIMENSION} \
       -b "${ATROPOS_SEGMENTATION_POSTERIOR_FORMULATION}" \
       ${ATROPOS_ANATOMICAL_IMAGES_COMMAND_LINE} \
@@ -1000,7 +1000,7 @@ if [[ ! -s ${OUTPUT_PREFIX}ACTStage3Complete.txt ]] && \
       done
 
     ## Don't de-noise a second time
-    logCmd ${ANTSPATH}/antsAtroposN4.sh \
+    logCmd antsAtroposN4.sh \
       -d ${DIMENSION} \
       -b "${ATROPOS_SEGMENTATION_POSTERIOR_FORMULATION}" \
       ${ATROPOS_ANATOMICAL_IMAGES_COMMAND_LINE} \
@@ -1093,7 +1093,7 @@ if [[ -f ${REGISTRATION_TEMPLATE} ]] && [[ ! -f $REGISTRATION_LOG_JACOBIAN ]];
     echo "--------------------------------------------------------------------------------------"
     echo
 
-    logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTED_SEGMENTATION_BRAIN_N4_IMAGE} m ${HEAD_N4_IMAGE} ${BRAIN_EXTRACTION_MASK}
+    logCmd ImageMath ${DIMENSION} ${EXTRACTED_SEGMENTATION_BRAIN_N4_IMAGE} m ${HEAD_N4_IMAGE} ${BRAIN_EXTRACTION_MASK}
 
     TMP_FILES=( ${TMP_FILES[@]} ${EXTRACTED_SEGMENTATION_BRAIN_N4_IMAGE} )
 
@@ -1104,7 +1104,7 @@ if [[ -f ${REGISTRATION_TEMPLATE} ]] && [[ ! -f $REGISTRATION_LOG_JACOBIAN ]];
       then
         TMP_FILES=( ${TMP_FILES[@]} "${REGISTRATION_TEMPLATE_OUTPUT_PREFIX}Warped.nii.gz" "${REGISTRATION_TEMPLATE_OUTPUT_PREFIX}InverseWarped.nii.gz" )
 
-        basecall="${ANTSPATH}/antsRegistrationSyNQuick.sh -d ${DIMENSION} -f ${REGISTRATION_TEMPLATE}"
+        basecall="antsRegistrationSyNQuick.sh -d ${DIMENSION} -f ${REGISTRATION_TEMPLATE}"
         basecall="${basecall} -m ${EXTRACTED_SEGMENTATION_BRAIN_N4_IMAGE} -o ${REGISTRATION_TEMPLATE_OUTPUT_PREFIX} -j 1"
         if [[ ${USE_FLOAT_PRECISION} -ne 0 ]];
           then
@@ -1148,7 +1148,7 @@ if [[ -f ${REGISTRATION_TEMPLATE} ]] && [[ ! -f $REGISTRATION_LOG_JACOBIAN ]];
       echo "The transform file ${REGISTRATION_SUBJECT_WARP} does not exist."
       exit 1
     fi
-    logCmd ${ANTSPATH}/antsApplyTransforms -d ${DIMENSION} -o Linear[ $REGISTRATION_SUBJECT_GENERIC_AFFINE,1 ] -t $REGISTRATION_TEMPLATE_GENERIC_AFFINE --verbose 1
+    logCmd antsApplyTransforms -d ${DIMENSION} -o Linear[ $REGISTRATION_SUBJECT_GENERIC_AFFINE,1 ] -t $REGISTRATION_TEMPLATE_GENERIC_AFFINE --verbose 1
 
     time_end_template_registration=`date +%s`
     time_elapsed_template_registration=$((time_end_template_registration - time_start_template_registration))
@@ -1171,7 +1171,7 @@ if [[ -f ${REGISTRATION_TEMPLATE} ]] && [[ ! -f $REGISTRATION_LOG_JACOBIAN ]];
               fi
           done
       fi
-  logCmd ${ANTSPATH}/CreateJacobianDeterminantImage ${DIMENSION} ${REGISTRATION_TEMPLATE_WARP} ${REGISTRATION_LOG_JACOBIAN} 1 1
+  logCmd CreateJacobianDeterminantImage ${DIMENSION} ${REGISTRATION_TEMPLATE_WARP} ${REGISTRATION_LOG_JACOBIAN} 1 1
   fi # if registration template & jacobian check
   if [[ -s ${REGISTRATION_LOG_JACOBIAN} ]] ; then
     echo ${OUTPUT_PREFIX}ACTStage4Complete.txt > ${OUTPUT_PREFIX}ACTStage4Complete.txt
@@ -1224,8 +1224,8 @@ if [[ ! -f ${CORTICAL_THICKNESS_IMAGE} ]];
         OTHER_LABEL_FORMAT=${ROOT}${OTHER_LABEL}
         BRAIN_SEGMENTATION_OTHER_LABEL=${BRAIN_SEGMENTATION_OUTPUT}Posteriors${OTHER_LABEL_FORMAT}.${OUTPUT_SUFFIX}
 
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${CORTICAL_THICKNESS_GM} + ${CORTICAL_THICKNESS_GM} ${BRAIN_SEGMENTATION_OTHER_LABEL}
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${CORTICAL_THICKNESS_SEGMENTATION} ReplaceVoxelValue ${BRAIN_SEGMENTATION} ${OTHER_LABEL} ${OTHER_LABEL} ${GRAY_MATTER_LABEL}
+        logCmd ImageMath ${DIMENSION} ${CORTICAL_THICKNESS_GM} + ${CORTICAL_THICKNESS_GM} ${BRAIN_SEGMENTATION_OTHER_LABEL}
+        logCmd ImageMath ${DIMENSION} ${CORTICAL_THICKNESS_SEGMENTATION} ReplaceVoxelValue ${BRAIN_SEGMENTATION} ${OTHER_LABEL} ${OTHER_LABEL} ${GRAY_MATTER_LABEL}
       done
 
     logCmd cp ${BRAIN_SEGMENTATION_WM} ${CORTICAL_THICKNESS_WM}
@@ -1241,8 +1241,8 @@ if [[ ! -f ${CORTICAL_THICKNESS_IMAGE} ]];
         OTHER_LABEL_FORMAT=${ROOT}${OTHER_LABEL}
         BRAIN_SEGMENTATION_OTHER_LABEL=${BRAIN_SEGMENTATION_OUTPUT}Posteriors${OTHER_LABEL_FORMAT}.${OUTPUT_SUFFIX}
 
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${CORTICAL_THICKNESS_WM} + ${CORTICAL_THICKNESS_WM} ${BRAIN_SEGMENTATION_OTHER_LABEL}
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${CORTICAL_THICKNESS_SEGMENTATION} ReplaceVoxelValue ${BRAIN_SEGMENTATION} ${OTHER_LABEL} ${OTHER_LABEL} ${WHITE_MATTER_LABEL}
+        logCmd ImageMath ${DIMENSION} ${CORTICAL_THICKNESS_WM} + ${CORTICAL_THICKNESS_WM} ${BRAIN_SEGMENTATION_OTHER_LABEL}
+        logCmd ImageMath ${DIMENSION} ${CORTICAL_THICKNESS_SEGMENTATION} ReplaceVoxelValue ${BRAIN_SEGMENTATION} ${OTHER_LABEL} ${OTHER_LABEL} ${WHITE_MATTER_LABEL}
       done
 
     # Check inputs
@@ -1276,12 +1276,12 @@ if [[ ! -f ${CORTICAL_THICKNESS_IMAGE} ]];
     if [[ -f ${CORTICAL_LABEL_IMAGE} ]] && [[ -f $REGISTRATION_SUBJECT_WARP ]] && [[ -f $REGISTRATION_SUBJECT_GENERIC_AFFINE ]] ;
       then
         # Calculate ATITH and multiply by a heuristically derived scalar factor
-#        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${CORTICAL_LABEL_THICKNESS_PRIOR} LabelThickness2 ${CORTICAL_LABEL_IMAGE}
-#        logCmd ${ANTSPATH}/ThresholdImage ${DIMENSION} ${CORTICAL_THICKNESS_SEGMENTATION} ${CORTICAL_THICKNESS_GM_SEGMENTATION} 2 2 1 0
-#        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${CORTICAL_LABEL_THICKNESS_PRIOR} m ${CORTICAL_LABEL_THICKNESS_PRIOR} ${CORTICAL_THICKNESS_GM_SEGMENTATION}
-#        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${CORTICAL_LABEL_THICKNESS_PRIOR} m ${CORTICAL_LABEL_THICKNESS_PRIOR} 2.0
+#        logCmd ImageMath ${DIMENSION} ${CORTICAL_LABEL_THICKNESS_PRIOR} LabelThickness2 ${CORTICAL_LABEL_IMAGE}
+#        logCmd ThresholdImage ${DIMENSION} ${CORTICAL_THICKNESS_SEGMENTATION} ${CORTICAL_THICKNESS_GM_SEGMENTATION} 2 2 1 0
+#        logCmd ImageMath ${DIMENSION} ${CORTICAL_LABEL_THICKNESS_PRIOR} m ${CORTICAL_LABEL_THICKNESS_PRIOR} ${CORTICAL_THICKNESS_GM_SEGMENTATION}
+#        logCmd ImageMath ${DIMENSION} ${CORTICAL_LABEL_THICKNESS_PRIOR} m ${CORTICAL_LABEL_THICKNESS_PRIOR} 2.0
 
-    	   logCmd ${ANTSPATH}/antsApplyTransforms -d ${DIMENSION} -i ${CORTICAL_LABEL_IMAGE} -o ${CORTICAL_LABEL_THICKNESS_PRIOR} \
+    	   logCmd antsApplyTransforms -d ${DIMENSION} -i ${CORTICAL_LABEL_IMAGE} -o ${CORTICAL_LABEL_THICKNESS_PRIOR} \
 	         -t $REGISTRATION_SUBJECT_GENERIC_AFFINE -t $REGISTRATION_SUBJECT_WARP -r ${ANATOMICAL_IMAGES[0]} --verbose 1
 
         exe_direct="${exe_direct} -a ${CORTICAL_LABEL_THICKNESS_PRIOR}"
@@ -1350,31 +1350,31 @@ if [[ -f ${REGISTRATION_TEMPLATE_WARP} ]];
 
     REGISTRATION_TEMPLATE_BRAIN_MASK=${OUTPUT_PREFIX}RegistrationTemplateBrainMask.${OUTPUT_SUFFIX}
 
-    logCmd ${ANTSPATH}/ThresholdImage 3 ${REGISTRATION_TEMPLATE} ${REGISTRATION_TEMPLATE_BRAIN_MASK} 1E-6 Inf
+    logCmd ThresholdImage 3 ${REGISTRATION_TEMPLATE} ${REGISTRATION_TEMPLATE_BRAIN_MASK} 1E-6 Inf
 
     EXTRACTED_SEGMENTATION_BRAIN_N4_IMAGE=${OUTPUT_PREFIX}ExtractedBrain0N4.${OUTPUT_SUFFIX}
 
-    logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${EXTRACTED_SEGMENTATION_BRAIN_N4_IMAGE} m ${HEAD_N4_IMAGE} ${BRAIN_EXTRACTION_MASK}
+    logCmd ImageMath ${DIMENSION} ${EXTRACTED_SEGMENTATION_BRAIN_N4_IMAGE} m ${HEAD_N4_IMAGE} ${BRAIN_EXTRACTION_MASK}
 
     TMP_FILES=( ${TMP_FILES[@]} ${EXTRACTED_SEGMENTATION_BRAIN_N4_IMAGE} ${EXTRACTED_SEGMENTATION_BRAIN_DEFORMED} ${REGISTRATION_TEMPLATE_BRAIN_MASK} )
 
     logCmd ${WARP} -d ${DIMENSION} -i ${EXTRACTED_SEGMENTATION_BRAIN_N4_IMAGE} -o ${EXTRACTED_SEGMENTATION_BRAIN_DEFORMED} -r ${REGISTRATION_TEMPLATE} -n Linear -t ${REGISTRATION_TEMPLATE_WARP}  -t ${REGISTRATION_TEMPLATE_GENERIC_AFFINE} --float ${USE_FLOAT_PRECISION} --verbose 1
   fi
 
-ccmetric=`${ANTSPATH}/ImageMath ${DIMENSION} a PearsonCorrelation ${REGISTRATION_TEMPLATE} ${EXTRACTED_SEGMENTATION_BRAIN_DEFORMED} ${REGISTRATION_TEMPLATE_BRAIN_MASK}`
-bvol=`${ANTSPATH}/ImageMath ${DIMENSION} a total ${BRAIN_EXTRACTION_MASK}  | cut -d ':' -f 3 | cut -d ' ' -f 2 `
-gvol=`${ANTSPATH}/ImageMath ${DIMENSION} a total ${BRAIN_SEGMENTATION_GM}  | cut -d ':' -f 3 | cut -d ' ' -f 2 `
-wvol=`${ANTSPATH}/ImageMath ${DIMENSION} a total ${BRAIN_SEGMENTATION_WM}  | cut -d ':' -f 3 | cut -d ' ' -f 2 `
-thks=`${ANTSPATH}/ImageMath ${DIMENSION} a total ${CORTICAL_THICKNESS_IMAGE} | cut -d ':' -f 3 | cut -d ' ' -f 2 `
+ccmetric=`ImageMath ${DIMENSION} a PearsonCorrelation ${REGISTRATION_TEMPLATE} ${EXTRACTED_SEGMENTATION_BRAIN_DEFORMED} ${REGISTRATION_TEMPLATE_BRAIN_MASK}`
+bvol=`ImageMath ${DIMENSION} a total ${BRAIN_EXTRACTION_MASK}  | cut -d ':' -f 3 | cut -d ' ' -f 2 `
+gvol=`ImageMath ${DIMENSION} a total ${BRAIN_SEGMENTATION_GM}  | cut -d ':' -f 3 | cut -d ' ' -f 2 `
+wvol=`ImageMath ${DIMENSION} a total ${BRAIN_SEGMENTATION_WM}  | cut -d ':' -f 3 | cut -d ' ' -f 2 `
+thks=`ImageMath ${DIMENSION} a total ${CORTICAL_THICKNESS_IMAGE} | cut -d ':' -f 3 | cut -d ' ' -f 2 `
 echo "PearsonCorrelation,BVOL,GVol,WVol,ThicknessSum" >   ${OUTPUT_PREFIX}brainvols.csv
 echo "${ccmetric},${bvol},${gvol},${wvol},${thks}" >>  ${OUTPUT_PREFIX}brainvols.csv
-if [[ -f ${ANTSPATH}/GetMeshAndTopology ]] && [[ ${DIMENSION} -eq 3 ]] ; then
-  ${ANTSPATH}/ThresholdImage ${DIMENSION} ${BRAIN_SEGMENTATION} ${OUTPUT_PREFIX}temp.${OUTPUT_SUFFIX} 3 3
-  ${ANTSPATH}/ImageMath ${DIMENSION} ${OUTPUT_PREFIX}temp.${OUTPUT_SUFFIX} ME ${OUTPUT_PREFIX}temp.${OUTPUT_SUFFIX} 1
-  ${ANTSPATH}/ImageMath ${DIMENSION} ${OUTPUT_PREFIX}temp.${OUTPUT_SUFFIX} GetLargestComponent ${OUTPUT_PREFIX}temp.${OUTPUT_SUFFIX} 1
-  ${ANTSPATH}/ImageMath ${DIMENSION} ${OUTPUT_PREFIX}temp.${OUTPUT_SUFFIX} MD ${OUTPUT_PREFIX}temp.${OUTPUT_SUFFIX} 2
-  ${ANTSPATH}/SmoothImage 3 ${CORTICAL_THICKNESS_IMAGE} 1 ${OUTPUT_PREFIX}temp2.${OUTPUT_SUFFIX}
-  #          ${ANTSPATH}/GetMeshAndTopology ${OUTPUT_PREFIX}temp.${OUTPUT_SUFFIX} ${OUTPUT_PREFIX}temp2.${OUTPUT_SUFFIX} ${OUTPUT_PREFIX}.vtk thickness   0.3 0.001 ${OUTPUT_PREFIX}_Thickness.png
+if [[ -f GetMeshAndTopology ]] && [[ ${DIMENSION} -eq 3 ]] ; then
+  ThresholdImage ${DIMENSION} ${BRAIN_SEGMENTATION} ${OUTPUT_PREFIX}temp.${OUTPUT_SUFFIX} 3 3
+  ImageMath ${DIMENSION} ${OUTPUT_PREFIX}temp.${OUTPUT_SUFFIX} ME ${OUTPUT_PREFIX}temp.${OUTPUT_SUFFIX} 1
+  ImageMath ${DIMENSION} ${OUTPUT_PREFIX}temp.${OUTPUT_SUFFIX} GetLargestComponent ${OUTPUT_PREFIX}temp.${OUTPUT_SUFFIX} 1
+  ImageMath ${DIMENSION} ${OUTPUT_PREFIX}temp.${OUTPUT_SUFFIX} MD ${OUTPUT_PREFIX}temp.${OUTPUT_SUFFIX} 2
+  SmoothImage 3 ${CORTICAL_THICKNESS_IMAGE} 1 ${OUTPUT_PREFIX}temp2.${OUTPUT_SUFFIX}
+  #          GetMeshAndTopology ${OUTPUT_PREFIX}temp.${OUTPUT_SUFFIX} ${OUTPUT_PREFIX}temp2.${OUTPUT_SUFFIX} ${OUTPUT_PREFIX}.vtk thickness   0.3 0.001 ${OUTPUT_PREFIX}_Thickness.png
   rm -f ${OUTPUT_PREFIX}temp.${OUTPUT_SUFFIX} ${OUTPUT_PREFIX}temp2.${OUTPUT_SUFFIX}
 fi
 echo "--------------------------------------------------------------------------------------"
@@ -1407,10 +1407,10 @@ if [[ ! -f ${CORTICAL_THICKNESS_MOSAIC} || ! -f ${BRAIN_SEGMENTATION_MOSAIC} ]];
 
     # Resample images
 
-    resample0="${ANTSPATH}/ResampleImage ${DIMENSION} ${BRAIN_EXTRACTION_MASK} ${BRAIN_EXTRACTION_MASK_RESAMPLED}"
-    resample1="${ANTSPATH}/ResampleImage ${DIMENSION} ${HEAD_N4_IMAGE} ${HEAD_N4_IMAGE_RESAMPLED}"
-    resample2="${ANTSPATH}/ResampleImage ${DIMENSION} ${CORTICAL_THICKNESS_IMAGE} ${CORTICAL_THICKNESS_IMAGE_RESAMPLED}"
-    resample3="${ANTSPATH}/ResampleImage ${DIMENSION} ${BRAIN_SEGMENTATION} ${BRAIN_SEGMENTATION_IMAGE_RESAMPLED}"
+    resample0="ResampleImage ${DIMENSION} ${BRAIN_EXTRACTION_MASK} ${BRAIN_EXTRACTION_MASK_RESAMPLED}"
+    resample1="ResampleImage ${DIMENSION} ${HEAD_N4_IMAGE} ${HEAD_N4_IMAGE_RESAMPLED}"
+    resample2="ResampleImage ${DIMENSION} ${CORTICAL_THICKNESS_IMAGE} ${CORTICAL_THICKNESS_IMAGE_RESAMPLED}"
+    resample3="ResampleImage ${DIMENSION} ${BRAIN_SEGMENTATION} ${BRAIN_SEGMENTATION_IMAGE_RESAMPLED}"
 
     if [[ ${DIMENSION} -eq 3 ]];
       then
@@ -1431,14 +1431,14 @@ if [[ ! -f ${CORTICAL_THICKNESS_MOSAIC} || ! -f ${BRAIN_SEGMENTATION_MOSAIC} ]];
 
     # Cortical thickness
 
-    mask="${ANTSPATH}/ThresholdImage ${DIMENSION} ${CORTICAL_THICKNESS_IMAGE_RESAMPLED} ${CORTICAL_THICKNESS_MASK} 0 0 0 1"
+    mask="ThresholdImage ${DIMENSION} ${CORTICAL_THICKNESS_IMAGE_RESAMPLED} ${CORTICAL_THICKNESS_MASK} 0 0 0 1"
     logCmd $mask
 
-    conversion="${ANTSPATH}/ConvertScalarImageToRGB ${DIMENSION} ${CORTICAL_THICKNESS_IMAGE_RESAMPLED}"
+    conversion="ConvertScalarImageToRGB ${DIMENSION} ${CORTICAL_THICKNESS_IMAGE_RESAMPLED}"
     conversion="${conversion} ${CORTICAL_THICKNESS_IMAGE_RGB} none hot none 0 ${DIRECT_THICKNESS_PRIOR}"
     logCmd $conversion
 
-    mosaic="${ANTSPATH}/CreateTiledMosaic -i ${HEAD_N4_IMAGE_RESAMPLED} -r ${CORTICAL_THICKNESS_IMAGE_RGB}"
+    mosaic="CreateTiledMosaic -i ${HEAD_N4_IMAGE_RESAMPLED} -r ${CORTICAL_THICKNESS_IMAGE_RGB}"
     mosaic="${mosaic} -o ${CORTICAL_THICKNESS_MOSAIC} -a 1.0 -t -1x-1 -d z -p mask"
     mosaic="${mosaic} -s [ 2,mask,mask ] -x ${CORTICAL_THICKNESS_MASK}"
     logCmd $mosaic
@@ -1449,11 +1449,11 @@ if [[ ! -f ${CORTICAL_THICKNESS_MOSAIC} || ! -f ${BRAIN_SEGMENTATION_MOSAIC} ]];
     echo "0 0 1 0 1 1 0" >> $ITKSNAP_COLORMAP
     echo "0 0 0 1 0 1 1" >> $ITKSNAP_COLORMAP
 
-    conversion="${ANTSPATH}/ConvertScalarImageToRGB ${DIMENSION} ${BRAIN_SEGMENTATION_IMAGE_RESAMPLED}"
+    conversion="ConvertScalarImageToRGB ${DIMENSION} ${BRAIN_SEGMENTATION_IMAGE_RESAMPLED}"
     conversion="${conversion} ${BRAIN_SEGMENTATION_IMAGE_RGB} none custom $ITKSNAP_COLORMAP 0 6"
     logCmd $conversion
 
-    mosaic="${ANTSPATH}/CreateTiledMosaic -i ${HEAD_N4_IMAGE_RESAMPLED} -r ${BRAIN_SEGMENTATION_IMAGE_RGB}"
+    mosaic="CreateTiledMosaic -i ${HEAD_N4_IMAGE_RESAMPLED} -r ${BRAIN_SEGMENTATION_IMAGE_RGB}"
     mosaic="${mosaic} -o ${BRAIN_SEGMENTATION_MOSAIC} -a 0.3 -t -1x-1 -d 2 -p mask"
     mosaic="${mosaic} -s [ 2,mask,mask ] -x ${BRAIN_EXTRACTION_MASK_RESAMPLED}"
     logCmd $mosaic
diff --git a/Scripts/antsIntermodalityIntrasubject.sh b/Scripts/antsIntermodalityIntrasubject.sh
index d0d5c4b2..39bad8b7 100755
--- a/Scripts/antsIntermodalityIntrasubject.sh
+++ b/Scripts/antsIntermodalityIntrasubject.sh
@@ -2,12 +2,12 @@
 
 VERSION="0.0"
 
-if [[ ! -s ${ANTSPATH}/antsRegistration ]]; then
-  echo we cant find the antsRegistration program -- does not seem to exist.  please \(re\)define \$ANTSPATH in your environment.
+if ! command -v antsRegistration &> /dev/null
+  echo we cant find the antsRegistration program -- does not seem to exist.  please \(re\)define \$PATH in your environment.
   exit
 fi
-if [[ ! -s ${ANTSPATH}/antsApplyTransforms ]]; then
-  echo we cant find the antsApplyTransforms program -- does not seem to exist.  please \(re\)define \$ANTSPATH in your environment.
+if ! command -v antsApplyTransforms &> /dev/null
+  echo we cant find the antsApplyTransforms program -- does not seem to exist.  please \(re\)define \$PATH in your environment.
   exit
 fi
 
@@ -115,8 +115,8 @@ TEMPLATE=""
 #
 ################################################################################
 
-ANTS=${ANTSPATH}/antsRegistration
-WARP=${ANTSPATH}/antsApplyTransforms
+ANTS=antsRegistration
+WARP=antsApplyTransforms
 
 if [[ $# -lt 3 ]] ; then
   Usage >&2
@@ -286,7 +286,7 @@ if [[ ${TRANSFORM_TYPE} -gt 1 ]] ; then
 fi
 globalparams=" -z 1 --winsorize-image-intensities [ 0.005, 0.995 ] "
 
-cmd="${ANTSPATH}/antsRegistration -d $DIMENSION $stage1 $stage2 $globalparams -o ${OUTPUT_PREFIX}"
+cmd="antsRegistration -d $DIMENSION $stage1 $stage2 $globalparams -o ${OUTPUT_PREFIX}"
 echo $cmd
 if [[ ! -s ${OUTPUT_PREFIX}0GenericAffine.mat ]] ; then
   $cmd
@@ -302,12 +302,12 @@ then
   warp="-t ${OUTPUT_PREFIX}1Warp.nii.gz"
   iwarp="-t ${OUTPUT_PREFIX}1InverseWarp.nii.gz"
 fi
-${ANTSPATH}/antsApplyTransforms -d $DIMENSION -i $BRAIN -o ${OUTPUT_PREFIX}anatomical.nii.gz -r $ANATOMICAL_SPACE $warp -t ${OUTPUT_PREFIX}0GenericAffine.mat -n Linear
+antsApplyTransforms -d $DIMENSION -i $BRAIN -o ${OUTPUT_PREFIX}anatomical.nii.gz -r $ANATOMICAL_SPACE $warp -t ${OUTPUT_PREFIX}0GenericAffine.mat -n Linear
 if  [[ ! -s ${TEMPLATE_TRANSFORM}1Warp.nii.gz ]] ; then
   echo ${TEMPLATE_TRANSFORM}1Warp.nii.gz does not exist - please specify in order to proceed to steps that map to the template
   exit
 fi
-cmd="${ANTSPATH}/antsApplyTransforms -d $DIMENSION -i $BRAIN -o ${OUTPUT_PREFIX}template.nii.gz -r ${TEMPLATE} -t ${TEMPLATE_TRANSFORM}1Warp.nii.gz -t ${TEMPLATE_TRANSFORM}0GenericAffine.mat $warp -t ${OUTPUT_PREFIX}0GenericAffine.mat -n Linear"
+cmd="antsApplyTransforms -d $DIMENSION -i $BRAIN -o ${OUTPUT_PREFIX}template.nii.gz -r ${TEMPLATE} -t ${TEMPLATE_TRANSFORM}1Warp.nii.gz -t ${TEMPLATE_TRANSFORM}0GenericAffine.mat $warp -t ${OUTPUT_PREFIX}0GenericAffine.mat -n Linear"
 $cmd
 
 echo "AUX IMAGES"
@@ -317,9 +317,9 @@ for (( i = 0; i < ${#AUX_IMAGES[@]}; i++ ))
     # FIXME - how to name these reasonably
     AUXO=`basename ${AUX_IMAGES[$i]} .nii.gz`
     #AUXO=${OUTPUT_PREFIX}_aux_${i}_warped.nii.gz
-    ${ANTSPATH}/antsApplyTransforms -d $DIMENSION -i ${AUX_IMAGES[$i]} -r $ANATOMICAL_SPACE $warp -n Linear -o ${OUTPUT_DIR}/${AUXO}_anatomical.nii.gz $warp -t ${OUTPUT_PREFIX}0GenericAffine.mat
+    antsApplyTransforms -d $DIMENSION -i ${AUX_IMAGES[$i]} -r $ANATOMICAL_SPACE $warp -n Linear -o ${OUTPUT_DIR}/${AUXO}_anatomical.nii.gz $warp -t ${OUTPUT_PREFIX}0GenericAffine.mat
 
-    ${ANTSPATH}/antsApplyTransforms -d $DIMENSION -i ${AUX_IMAGES[$i]} -r ${TEMPLATE} -n Linear -o ${OUTPUT_DIR}/${AUXO}_template.nii.gz -t ${TEMPLATE_TRANSFORM}1Warp.nii.gz -t ${TEMPLATE_TRANSFORM}0GenericAffine.mat $warp -t ${OUTPUT_PREFIX}0GenericAffine.mat
+    antsApplyTransforms -d $DIMENSION -i ${AUX_IMAGES[$i]} -r ${TEMPLATE} -n Linear -o ${OUTPUT_DIR}/${AUXO}_template.nii.gz -t ${TEMPLATE_TRANSFORM}1Warp.nii.gz -t ${TEMPLATE_TRANSFORM}0GenericAffine.mat $warp -t ${OUTPUT_PREFIX}0GenericAffine.mat
 
 done
 
@@ -327,18 +327,18 @@ echo "DTI"
 # warp DT image to t1
 if [[ -f $DTI ]];
 then
-    ${ANTSPATH}/antsApplyTransforms -d $DIMENSION -i ${DTI} -r $ANATOMICAL_SPACE $warp -t ${OUTPUT_PREFIX}0GenericAffine.mat -n Linear -o ${OUTPUT_PREFIX}dt_anatomical.nii.gz -e 2
+    antsApplyTransforms -d $DIMENSION -i ${DTI} -r $ANATOMICAL_SPACE $warp -t ${OUTPUT_PREFIX}0GenericAffine.mat -n Linear -o ${OUTPUT_PREFIX}dt_anatomical.nii.gz -e 2
 
-   ${ANTSPATH}/antsApplyTransforms -d $DIMENSION -e 2 -i ${DTI} -r ${TEMPLATE} -n Linear -o ${OUTPUT_PREFIX}dt_template.nii.gz -t ${TEMPLATE_TRANSFORM}1Warp.nii.gz -t ${TEMPLATE_TRANSFORM}0GenericAffine.mat $warp -t ${OUTPUT_PREFIX}0GenericAffine.mat
+   antsApplyTransforms -d $DIMENSION -e 2 -i ${DTI} -r ${TEMPLATE} -n Linear -o ${OUTPUT_PREFIX}dt_template.nii.gz -t ${TEMPLATE_TRANSFORM}1Warp.nii.gz -t ${TEMPLATE_TRANSFORM}0GenericAffine.mat $warp -t ${OUTPUT_PREFIX}0GenericAffine.mat
 
-   ${ANTSPATH}/ImageMath 3 ${OUTPUT_PREFIX}fa_template.nii.gz TensorFA ${OUTPUT_PREFIX}dt_template.nii.gz
-   ${ANTSPATH}/ImageMath 3 ${OUTPUT_PREFIX}md_template.nii.gz TensorMeanDiffusion ${OUTPUT_PREFIX}dt_template.nii.gz
+   ImageMath 3 ${OUTPUT_PREFIX}fa_template.nii.gz TensorFA ${OUTPUT_PREFIX}dt_template.nii.gz
+   ImageMath 3 ${OUTPUT_PREFIX}md_template.nii.gz TensorMeanDiffusion ${OUTPUT_PREFIX}dt_template.nii.gz
 
 fi
 
 # warp brainmask from anatomy to subject
 if [[ -f $TEMPLATE_MASK ]]; then
-    ${ANTSPATH}/antsApplyTransforms -d $DIMENSION -i $TEMPLATE_MASK -o ${OUTPUT_PREFIX}brainmask.nii.gz \
+    antsApplyTransforms -d $DIMENSION -i $TEMPLATE_MASK -o ${OUTPUT_PREFIX}brainmask.nii.gz \
 	-r $BRAIN  -n NearestNeighbor \
 	-t [ ${OUTPUT_PREFIX}0GenericAffine.mat, 1 ]       \
 	$iwarp
@@ -346,7 +346,7 @@ fi
 
 # warp Labels from template to subject (if passed)
 if [[ -f $TEMPLATE_LABELS ]]; then
-    ${ANTSPATH}/antsApplyTransforms -d $DIMENSION -i $TEMPLATE_LABELS -o ${OUTPUT_PREFIX}labels.nii.gz \
+    antsApplyTransforms -d $DIMENSION -i $TEMPLATE_LABELS -o ${OUTPUT_PREFIX}labels.nii.gz \
 	-r $BRAIN  -n NearestNeighbor \
 	-t [ ${OUTPUT_PREFIX}0GenericAffine.mat, 1 ]       \
 	$iwarp           \
diff --git a/Scripts/antsIntroduction.sh b/Scripts/antsIntroduction.sh
index f7c960db..8c3ed323 100755
--- a/Scripts/antsIntroduction.sh
+++ b/Scripts/antsIntroduction.sh
@@ -5,37 +5,9 @@ VERSION="0.0.8 dev"
 # trap keyboard interrupt (control-c)
 trap control_c SIGINT
 
-function setPath {
-    cat <<SETPATH
-
---------------------------------------------------------------------------------------
-Error locating ANTS
---------------------------------------------------------------------------------------
-It seems that the ANTSPATH environment variable is not set. Please add the ANTSPATH
-variable. This can be achieved by editing the .bash_profile in the home directory.
-Add:
-
-ANTSPATH=/home/yourname/bin/ants/
-
-Or the correct location of the ANTS binaries.
-
-Alternatively, edit this script ( `basename $0` ) to set up this parameter correctly.
-
-SETPATH
-    exit 1
-}
-
-# Uncomment the line below in case you have not set the ANTSPATH variable in your environment.
-# export ANTSPATH=${ANTSPATH:="$HOME/bin/ants/"} # EDIT THIS
-
-#ANTSPATH=YOURANTSPATH
-if [  ${#ANTSPATH} -le 3 ]
-    then
-    setPath >&2
-fi
-
-if [ ! -s ${ANTSPATH}/ANTS ] ; then
-  echo "ANTS program can't be found. Please (re)define \$ANTSPATH in your environment."
+if ! command -v ANTS &> /dev/null
+then
+  echo "ANTS program can't be found. Please (re)define \$PATH in your environment."
   exit
 fi
 
@@ -231,8 +203,6 @@ function reportMappingParameters {
 --------------------------------------------------------------------------------------
 Mapping parameters
 --------------------------------------------------------------------------------------
-ANTSPATH is $ANTSPATH
-
 Dimensionality:				$DIM
 Fixed image:				$FIXED
 Moving image:				$MOVING
@@ -257,7 +227,7 @@ Data integrity check failed
 There seems to be a problem with the header definitions of the input files. This
 script has tried to repair this issue automatically by invoking:
 
-${ANTSPATH}/ImageMath $DIM ${OUTPUTNAME}repaired.nii.gz CompareHeadersAndImages $FIXED $MOVING
+ImageMath $DIM ${OUTPUTNAME}repaired.nii.gz CompareHeadersAndImages $FIXED $MOVING
 
 The repaired image is:
 
@@ -404,7 +374,7 @@ fi
 
 # check the image headers
 echo "input files: checking"
-compareheaders=`${ANTSPATH}/ImageMath $DIM ${OUTPUTNAME}repaired.nii.gz CompareHeadersAndImages $FIXED $MOVING  | grep FailureState | cut -d ' ' -f 4 `
+compareheaders=`ImageMath $DIM ${OUTPUTNAME}repaired.nii.gz CompareHeadersAndImages $FIXED $MOVING  | grep FailureState | cut -d ' ' -f 4 `
 
 if [[ $compareheaders -ne 0 ]] ; then
   dataCheck
@@ -561,7 +531,7 @@ AFFINEITERATIONS=10000x10000x10000x10000x10000
 if  [ ${N4CORRECT} -eq 0 ] && [ ${RIGID} -eq 0 ]
 then
 # Apply ANTS mapping command without N4BiasFieldCorrection
-exe="${ANTSPATH}/ANTS $DIM -m  ${METRIC}${FIXED},${MOVING},${METRICPARAMS} -t $TRANSFORMATION -r $REGULARIZATION -o ${OUTPUTNAME} -i $MAXITERATIONS --use-Histogram-Matching  --number-of-affine-iterations $AFFINEITERATIONS --MI-option 32x16000 "
+exe="ANTS $DIM -m  ${METRIC}${FIXED},${MOVING},${METRICPARAMS} -t $TRANSFORMATION -r $REGULARIZATION -o ${OUTPUTNAME} -i $MAXITERATIONS --use-Histogram-Matching  --number-of-affine-iterations $AFFINEITERATIONS --MI-option 32x16000 "
 echo
 echo "--------------------------------------------------------------------------------------"
 echo "ANTS command:"
@@ -575,8 +545,8 @@ echo
 echo "--------------------------------------------------------------------------------------"
 echo "Applying forward transformation to ${MOVING}"
 echo "--------------------------------------------------------------------------------------"
-${ANTSPATH}/WarpImageMultiTransform $DIM ${MOVING} ${OUTPUTNAME}deformed.nii.gz ${OUTPUTNAME}Warp.nii.gz ${OUTPUTNAME}Affine.txt -R ${FIXED}
-echo "warpfw=${ANTSPATH}/WarpImageMultiTransform $DIM ${MOVING} ${OUTPUTNAME}deformed.nii.gz ${OUTPUTNAME}Warp.nii.gz ${OUTPUTNAME}Affine.txt -R ${FIXED}" >> ${MOVINGBASE}.cfg
+WarpImageMultiTransform $DIM ${MOVING} ${OUTPUTNAME}deformed.nii.gz ${OUTPUTNAME}Warp.nii.gz ${OUTPUTNAME}Affine.txt -R ${FIXED}
+echo "warpfw=WarpImageMultiTransform $DIM ${MOVING} ${OUTPUTNAME}deformed.nii.gz ${OUTPUTNAME}Warp.nii.gz ${OUTPUTNAME}Affine.txt -R ${FIXED}" >> ${MOVINGBASE}.cfg
 
 
 # Apply inverse transformation to FIXED
@@ -592,16 +562,16 @@ echo "--------------------------------------------------------------------------
 echo "Applying inverse transformation to ${FIXED}"
 echo "--------------------------------------------------------------------------------------"
 FIXEDBASE=` echo ${FIXED} | cut -d '.' -f 1 `
-${ANTSPATH}/WarpImageMultiTransform $DIM ${FIXED} ${FIXEDBASE}_InverseWarp.nii.gz -R ${MOVING} -i ${OUTPUTNAME}Affine.txt ${OUTPUTNAME}InverseWarp.nii.gz
-echo "warpinv=${ANTSPATH}/WarpImageMultiTransform $DIM ${FIXED} ${FIXEDBASE}_InverseWarp.nii.gz -R ${MOVING} -i ${OUTPUTNAME}Affine.txt ${OUTPUTNAME}InverseWarp.nii.gz" >> ${MOVINGBASE}.cfg
+WarpImageMultiTransform $DIM ${FIXED} ${FIXEDBASE}_InverseWarp.nii.gz -R ${MOVING} -i ${OUTPUTNAME}Affine.txt ${OUTPUTNAME}InverseWarp.nii.gz
+echo "warpinv=WarpImageMultiTransform $DIM ${FIXED} ${FIXEDBASE}_InverseWarp.nii.gz -R ${MOVING} -i ${OUTPUTNAME}Affine.txt ${OUTPUTNAME}InverseWarp.nii.gz" >> ${MOVINGBASE}.cfg
 fi
 
 elif [ ${N4CORRECT} -eq 1 ] && [ ${RIGID} -eq 0 ]
 then
 # Apply N4BiasFieldCorrection
 #Uncomment/comment below to switch between N3 and N4 bias field correction binaries
-#exe="${ANTSPATH}/N3BiasFieldCorrection $DIM $MOVING ${OUTPUTNAME}.nii.gz 4"
-exe="${ANTSPATH}/N4BiasFieldCorrection -d $DIM -i $MOVING -o ${OUTPUTNAME}.nii.gz -b [ 200 ] -s 3 -c [ 50x50x30x20,1e-6 ]"
+#exe="N3BiasFieldCorrection $DIM $MOVING ${OUTPUTNAME}.nii.gz 4"
+exe="N4BiasFieldCorrection -d $DIM -i $MOVING -o ${OUTPUTNAME}.nii.gz -b [ 200 ] -s 3 -c [ 50x50x30x20,1e-6 ]"
 echo
 echo "--------------------------------------------------------------------------------------"
 echo "N4BiasFieldCorrection command:"
@@ -611,7 +581,7 @@ $exe
 echo "execN4=$exe" >> ${MOVINGBASE}.cfg
 
 # Apply ANTS mapping command on N3 corrected image
-exe="${ANTSPATH}/ANTS $DIM -m  ${METRIC}${FIXED},${OUTPUTNAME}.nii.gz,${METRICPARAMS} -t $TRANSFORMATION -r $REGULARIZATION -o ${OUTPUTNAME} -i $MAXITERATIONS --use-Histogram-Matching  --number-of-affine-iterations $AFFINEITERATIONS --MI-option 32x16000  "
+exe="ANTS $DIM -m  ${METRIC}${FIXED},${OUTPUTNAME}.nii.gz,${METRICPARAMS} -t $TRANSFORMATION -r $REGULARIZATION -o ${OUTPUTNAME} -i $MAXITERATIONS --use-Histogram-Matching  --number-of-affine-iterations $AFFINEITERATIONS --MI-option 32x16000  "
 echo
 echo "--------------------------------------------------------------------------------------"
 echo "ANTS command:"
@@ -625,8 +595,8 @@ echo
 echo "--------------------------------------------------------------------------------------"
 echo "Applying forward transformation to ${MOVING}"
 echo "--------------------------------------------------------------------------------------"
-${ANTSPATH}/WarpImageMultiTransform $DIM ${OUTPUTNAME}.nii.gz ${OUTPUTNAME}deformed.nii.gz ${OUTPUTNAME}Warp.nii.gz ${OUTPUTNAME}Affine.txt -R ${FIXED}
-echo "warpfw=${ANTSPATH}/WarpImageMultiTransform $DIM ${OUTPUTNAME}.nii.gz ${OUTPUTNAME}deformed.nii.gz ${OUTPUTNAME}Warp.nii.gz ${OUTPUTNAME}Affine.txt -R ${FIXED}" >> ${MOVINGBASE}.cfg
+WarpImageMultiTransform $DIM ${OUTPUTNAME}.nii.gz ${OUTPUTNAME}deformed.nii.gz ${OUTPUTNAME}Warp.nii.gz ${OUTPUTNAME}Affine.txt -R ${FIXED}
+echo "warpfw=WarpImageMultiTransform $DIM ${OUTPUTNAME}.nii.gz ${OUTPUTNAME}deformed.nii.gz ${OUTPUTNAME}Warp.nii.gz ${OUTPUTNAME}Affine.txt -R ${FIXED}" >> ${MOVINGBASE}.cfg
 
 # Apply inverse transformation to FIXED
 if [ "${TRANSFORMATIONTYPE}" == "EL" ]
@@ -641,13 +611,13 @@ echo "--------------------------------------------------------------------------
 echo "Applying inverse transformation to ${FIXED}"
 echo "--------------------------------------------------------------------------------------"
 FIXEDBASE=` echo ${FIXED} | cut -d '.' -f 1 `
-${ANTSPATH}/WarpImageMultiTransform $DIM ${FIXED} ${FIXEDBASE}_InverseWarp.nii.gz -i ${OUTPUTNAME}Affine.txt ${OUTPUTNAME}InverseWarp.nii.gz -R ${OUTPUTNAME}.nii.gz
-echo "warpinv=${ANTSPATH}/WarpImageMultiTransform $DIM ${FIXED} ${FIXEDBASE}_InverseWarp.nii.gz -R ${OUTPUTNAME}.nii.gz -i ${OUTPUTNAME}Affine.txt ${OUTPUTNAME}InverseWarp.nii.gz" >> ${MOVINGBASE}.cfg
+WarpImageMultiTransform $DIM ${FIXED} ${FIXEDBASE}_InverseWarp.nii.gz -i ${OUTPUTNAME}Affine.txt ${OUTPUTNAME}InverseWarp.nii.gz -R ${OUTPUTNAME}.nii.gz
+echo "warpinv=WarpImageMultiTransform $DIM ${FIXED} ${FIXEDBASE}_InverseWarp.nii.gz -R ${OUTPUTNAME}.nii.gz -i ${OUTPUTNAME}Affine.txt ${OUTPUTNAME}InverseWarp.nii.gz" >> ${MOVINGBASE}.cfg
 fi
 
 elif  [ ${N4CORRECT} -eq 0 ] && [ ${RIGID} -eq 1 ]
 then
-exe=" ${ANTSPATH}/ANTS $DIM -m ${METRIC}${FIXED},${MOVING},${METRICPARAMS} -o ${OUTPUTNAME}.nii.gz -i 0 --use-Histogram-Matching --number-of-affine-iterations $AFFINEITERATIONS --MI-option 32x16000 ${RIGIDTRANSF} "
+exe=" ANTS $DIM -m ${METRIC}${FIXED},${MOVING},${METRICPARAMS} -o ${OUTPUTNAME}.nii.gz -i 0 --use-Histogram-Matching --number-of-affine-iterations $AFFINEITERATIONS --MI-option 32x16000 ${RIGIDTRANSF} "
 echo
 echo "--------------------------------------------------------------------------------------"
 echo "ANTS command:"
@@ -661,14 +631,14 @@ echo
 echo "--------------------------------------------------------------------------------------"
 echo "Applying rigid transformation to ${MOVING}"
 echo "--------------------------------------------------------------------------------------"
-${ANTSPATH}/WarpImageMultiTransform $DIM ${MOVING} ${OUTPUTNAME}deformed.nii.gz ${OUTPUTNAME}Affine.txt -R ${FIXED}
+WarpImageMultiTransform $DIM ${MOVING} ${OUTPUTNAME}deformed.nii.gz ${OUTPUTNAME}Affine.txt -R ${FIXED}
 
 elif  [ ${N4CORRECT} -eq 1 ] && [ ${RIGID} -eq 1 ]
 then
 # Apply N4BiasFieldCorrection
 #Uncomment/comment below to switch between N3 and N4 bias field correction binaries
-#exe="${ANTSPATH}/N3BiasFieldCorrection $DIM $MOVING ${OUTPUTNAME}.nii.gz 4"
-exe="${ANTSPATH}/N4BiasFieldCorrection -d $DIM -i $MOVING -o ${OUTPUTNAME}.nii.gz -b [ 200 ] -s 3 -c [ 50x50x30x20,1e-6 ]"
+#exe="N3BiasFieldCorrection $DIM $MOVING ${OUTPUTNAME}.nii.gz 4"
+exe="N4BiasFieldCorrection -d $DIM -i $MOVING -o ${OUTPUTNAME}.nii.gz -b [ 200 ] -s 3 -c [ 50x50x30x20,1e-6 ]"
 echo
 echo "--------------------------------------------------------------------------------------"
 echo "N4BiasFieldCorrection command:"
@@ -677,7 +647,7 @@ echo "--------------------------------------------------------------------------
 $exe
 echo "execN4=$exe" >> ${MOVINGBASE}.cfg
 
-exe=" ${ANTSPATH}/ANTS $DIM -m MI[ ${FIXED},${MOVING},1,32 ] -o ${OUTPUTNAME}.nii.gz -i 0 --use-Histogram-Matching --number-of-affine-iterations $AFFINEITERATIONS --MI-option 32x16000 ${RIGIDTRANSF} "
+exe=" ANTS $DIM -m MI[ ${FIXED},${MOVING},1,32 ] -o ${OUTPUTNAME}.nii.gz -i 0 --use-Histogram-Matching --number-of-affine-iterations $AFFINEITERATIONS --MI-option 32x16000 ${RIGIDTRANSF} "
 echo
 echo "--------------------------------------------------------------------------------------"
 echo "ANTS command:"
@@ -691,7 +661,7 @@ echo
 echo "--------------------------------------------------------------------------------------"
 echo "Applying rigid transformation to ${MOVING}"
 echo "--------------------------------------------------------------------------------------"
-${ANTSPATH}/WarpImageMultiTransform $DIM ${MOVING} ${OUTPUTNAME}deformed.nii.gz ${OUTPUTNAME}Affine.txt -R ${FIXED}
+WarpImageMultiTransform $DIM ${MOVING} ${OUTPUTNAME}deformed.nii.gz ${OUTPUTNAME}Affine.txt -R ${FIXED}
 
 
 fi
@@ -699,30 +669,30 @@ fi
 # Apply transformation on labeled image?
 if  [ ${#LABELIMAGE} -gt 3 ]
 then
-${ANTSPATH}/WarpImageMultiTransform $DIM  $LABELIMAGE ${OUTPUTNAME}labeled.nii.gz -i ${OUTPUTNAME}Affine.txt ${OUTPUTNAME}InverseWarp.nii.gz  -R ${MOVING}   --use-NN
+WarpImageMultiTransform $DIM  $LABELIMAGE ${OUTPUTNAME}labeled.nii.gz -i ${OUTPUTNAME}Affine.txt ${OUTPUTNAME}InverseWarp.nii.gz  -R ${MOVING}   --use-NN
 fi
 
 if [ $DoANTSQC -eq 1 ]
 then
 #  measure image similarity - 0 = intensity difference, 1 = correlation , 2 = mutual information
 for SIM in 0 1 2 ; do
-${ANTSPATH}/MeasureImageSimilarity $DIM $SIM $FIXED ${OUTPUTNAME}deformed.nii.gz
+MeasureImageSimilarity $DIM $SIM $FIXED ${OUTPUTNAME}deformed.nii.gz
 done
 
 # the lines below  measure dice overlap and min-dist-sum from the approximately segmented brain (3 tissues and background)
-${ANTSPATH}/ThresholdImage $DIM $FIXED ${OUTPUTNAME}fixthresh.nii.gz Otsu 4
-${ANTSPATH}/ThresholdImage $DIM $MOVING ${OUTPUTNAME}movthresh.nii.gz Otsu 4
+ThresholdImage $DIM $FIXED ${OUTPUTNAME}fixthresh.nii.gz Otsu 4
+ThresholdImage $DIM $MOVING ${OUTPUTNAME}movthresh.nii.gz Otsu 4
 
-${ANTSPATH}/WarpImageMultiTransform $DIM ${OUTPUTNAME}movthresh.nii.gz ${OUTPUTNAME}defthresh.nii.gz ${OUTPUTNAME}Warp.nii.gz ${OUTPUTNAME}Affine.txt -R ${FIXED} --use-NN
+WarpImageMultiTransform $DIM ${OUTPUTNAME}movthresh.nii.gz ${OUTPUTNAME}defthresh.nii.gz ${OUTPUTNAME}Warp.nii.gz ${OUTPUTNAME}Affine.txt -R ${FIXED} --use-NN
 
-${ANTSPATH}/ImageMath $DIM ${OUTPUTNAME}dicestats.txt DiceAndMinDistSum  ${OUTPUTNAME}fixthresh.nii.gz   ${OUTPUTNAME}movthresh.nii.gz ${OUTPUTNAME}mindistsum.nii.gz
+ImageMath $DIM ${OUTPUTNAME}dicestats.txt DiceAndMinDistSum  ${OUTPUTNAME}fixthresh.nii.gz   ${OUTPUTNAME}movthresh.nii.gz ${OUTPUTNAME}mindistsum.nii.gz
 
 # below not used unless you want to compare segmentation volumes to those estimated by the jacobian
 # labelstats for jacobian wrt segmenation below, to compose
-# ${ANTSPATH}/ComposeMultiTransform $DIM   ${OUTPUTNAME}CompWarp.nii.gz  -R $FIXED ${OUTPUTNAME}Warp.nii.gz ${OUTPUTNAME}Affine.txt
-# ${ANTSPATH}/CreateJacobianDeterminantImage $DIM ${OUTPUTNAME}CompWarp.nii.gz ${OUTPUTNAME}jacobian.nii.gz  0
-# ${ANTSPATH}/ImageMath $DIM ${OUTPUTNAME}movlabstat.txt LabelStats ${OUTPUTNAME}movthresh.nii.gz ${OUTPUTNAME}movthresh.nii.gz
-# ${ANTSPATH}/ImageMath $DIM ${OUTPUTNAME}jaclabstat.txt LabelStats ${OUTPUTNAME}defthresh.nii.gz ${OUTPUTNAME}jacobian.nii.gz
+# ComposeMultiTransform $DIM   ${OUTPUTNAME}CompWarp.nii.gz  -R $FIXED ${OUTPUTNAME}Warp.nii.gz ${OUTPUTNAME}Affine.txt
+# CreateJacobianDeterminantImage $DIM ${OUTPUTNAME}CompWarp.nii.gz ${OUTPUTNAME}jacobian.nii.gz  0
+# ImageMath $DIM ${OUTPUTNAME}movlabstat.txt LabelStats ${OUTPUTNAME}movthresh.nii.gz ${OUTPUTNAME}movthresh.nii.gz
+# ImageMath $DIM ${OUTPUTNAME}jaclabstat.txt LabelStats ${OUTPUTNAME}defthresh.nii.gz ${OUTPUTNAME}jacobian.nii.gz
 # we compare the output of these last two lines:
 #  the Volume of the movlabstat computation vs. the mass of the jaclabstat
 fi
diff --git a/Scripts/antsJointLabelFusion.sh b/Scripts/antsJointLabelFusion.sh
index 74bfd69e..8bed30c0 100755
--- a/Scripts/antsJointLabelFusion.sh
+++ b/Scripts/antsJointLabelFusion.sh
@@ -5,50 +5,21 @@ VERSION="0.0.0"
 # trap keyboard interrupt (control-c)
 trap control_c SIGINT
 
-function setPath {
-    cat <<SETPATH
-
---------------------------------------------------------------------------------------
-Error locating ANTS
---------------------------------------------------------------------------------------
-It seems that the ANTSPATH environment variable is not set. Please add the ANTSPATH
-variable. This can be achieved by editing the .bash_profile in the home directory.
-Add:
-
-ANTSPATH=/home/yourname/bin/ants/
-
-Or the correct location of the ANTS binaries.
-
-Alternatively, edit this script ( `basename $0` ) to set up this parameter correctly.
-
-SETPATH
-    exit 1
-}
-
-# Uncomment the line below in case you have not set the ANTSPATH variable in your environment.
-# export ANTSPATH=${ANTSPATH:="$HOME/bin/ants/"} # EDIT THIS
-
-#ANTSPATH=YOURANTSPATH
-if [[ ${#ANTSPATH} -le 3 ]];
-  then
-    setPath >&2
-  fi
-
 # Test availability of helper scripts.
 # No need to test this more than once. Can reside outside of the main loop.
-ANTS=${ANTSPATH}/antsRegistration
-WARP=${ANTSPATH}/antsApplyTransforms
-JLF=${ANTSPATH}/antsJointFusion
-PEXEC=${ANTSPATH}/ANTSpexec.sh
-SGE=${ANTSPATH}/waitForSGEQJobs.pl
-PBS=${ANTSPATH}/waitForPBSQJobs.pl
-XGRID=${ANTSPATH}/waitForXGridJobs.pl
-SLURM=${ANTSPATH}/waitForSlurmJobs.pl
+ANTS=antsRegistration
+WARP=antsApplyTransforms
+JLF=antsJointFusion
+PEXEC=ANTSpexec.sh
+SGE=waitForSGEQJobs.pl
+PBS=waitForPBSQJobs.pl
+XGRID=waitForXGridJobs.pl
+SLURM=waitForSlurmJobs.pl
 
 fle_error=0
 for FLE in $JLF $ANTS $WARP $PEXEC $SGE $XGRID $PBS $SLURM
   do
-  if [[ ! -x $FLE ]];
+  if ! command -v $FLE &> /dev/null
     then
       echo
       echo "--------------------------------------------------------------------------------------"
@@ -275,7 +246,7 @@ Optional arguments:
 
 Requirements:
 
-This scripts relies on the following scripts in your $ANTSPATH directory. The script
+This scripts relies on the following scripts in your $PATH. The script
 will terminate prematurely if these files are not present or are not executable.
 - pexec.sh
 - waitForSGEQJobs.pl (only for use with Sun Grid Engine)
@@ -322,8 +293,6 @@ function reportParameters {
 --------------------------------------------------------------------------------------
  Parameters
 --------------------------------------------------------------------------------------
- ANTSPATH is $ANTSPATH
-
  Dimensionality:           $DIM
  Output prefix:            $OUTPUT_PREFIX
  Posteriors format:        $OUTPUT_POSTERIORS_FORMAT
@@ -568,10 +537,10 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
         continue
       fi
 
-    regcall=${ANTSPATH}/antsRegistrationSyN.sh
+    regcall=antsRegistrationSyN.sh
     if [[ $RUNQUICK -eq 1 ]];
       then
-        regcall=${ANTSPATH}/antsRegistrationSyNQuick.sh
+        regcall=antsRegistrationSyNQuick.sh
       fi
     registrationCall="$regcall \
                           -d ${DIM} \
@@ -582,7 +551,7 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
                           -m ${ATLAS_IMAGES[$i]} \
                           -o ${OUTPUT_PREFIX}${BASENAME}_${i}_ > ${OUTPUT_PREFIX}${BASENAME}_${i}_log.txt"
 
-    labelXfrmCall="${ANTSPATH}/antsApplyTransforms \
+    labelXfrmCall="antsApplyTransforms \
                           -d ${DIM} \
                           --float 1 \
                           -i ${ATLAS_LABELS[$i]} \
@@ -592,12 +561,12 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
                           -t ${OUTPUT_PREFIX}${BASENAME}_${i}_1Warp.nii.gz \
                           -t ${OUTPUT_PREFIX}${BASENAME}_${i}_0GenericAffine.mat >> ${OUTPUT_PREFIX}${BASENAME}_${i}_log.txt"
 
-    copyImageHeaderCall="${ANTSPATH}/CopyImageHeaderInformation \
+    copyImageHeaderCall="CopyImageHeaderInformation \
                          ${TARGET_IMAGE} \
                          ${OUTPUT_PREFIX}${BASENAME}_${i}_Warped.nii.gz \
                          ${OUTPUT_PREFIX}${BASENAME}_${i}_Warped.nii.gz 1 1 1"
 
-    copyLabelsHeaderCall="${ANTSPATH}/CopyImageHeaderInformation \
+    copyLabelsHeaderCall="CopyImageHeaderInformation \
                           ${TARGET_IMAGE} \
                           ${OUTPUT_PREFIX}${BASENAME}_${i}_WarpedLabels.nii.gz \
                           ${OUTPUT_PREFIX}${BASENAME}_${i}_WarpedLabels.nii.gz 1 1 1"
@@ -617,12 +586,12 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
 
     if [[ $DOQSUB -eq 1 ]];
       then
-        id=`qsub -cwd -S /bin/bash -N antsJlfReg -v ANTSPATH=$ANTSPATH $QSUB_OPTS $qscript | awk '{print $3}'`
+        id=`qsub -cwd -S /bin/bash -N antsJlfReg $QSUB_OPTS $qscript | awk '{print $3}'`
         jobIDs="$jobIDs $id"
         sleep 0.5
     elif [[ $DOQSUB -eq 4 ]];
       then
-        id=`qsub -N antsJlfReg -v ANTSPATH=$ANTSPATH $QSUB_OPTS -q nopreempt -l nodes=1:ppn=1 -l mem=${REGISTRATION_MEMORY} -l walltime=${REGISTRATION_WALLTIME} $qscript | awk '{print $1}'`
+        id=`qsub -N antsJlfReg $QSUB_OPTS -q nopreempt -l nodes=1:ppn=1 -l mem=${REGISTRATION_MEMORY} -l walltime=${REGISTRATION_WALLTIME} $qscript | awk '{print $1}'`
         jobIDs="$jobIDs $id"
         sleep 0.5
     elif [[ $DOQSUB -eq 3 ]];
@@ -631,7 +600,7 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
         jobIDs="$jobIDs $id"
     elif [[ $DOQSUB -eq 5 ]];
       then
-        id=`sbatch --job-name=antsJlfReg${i} --export=ANTSPATH=$ANTSPATH $QSUB_OPTS --nodes=1 --cpus-per-task=1 --time=${REGISTRATION_WALLTIME} --mem=${REGISTRATION_MEMORY} $qscript | rev | cut -f1 -d\ | rev`
+        id=`sbatch --job-name=antsJlfReg${i} $QSUB_OPTS --nodes=1 --cpus-per-task=1 --time=${REGISTRATION_WALLTIME} --mem=${REGISTRATION_MEMORY} $qscript | rev | cut -f1 -d\ | rev`
         jobIDs="$jobIDs $id"
         sleep 0.5
     elif [[ $DOQSUB -eq 0 ]];
@@ -651,7 +620,7 @@ if [[ $DOQSUB -eq 2 ]];
     $PEXEC -j ${CORES} "sh" ${OUTPUT_DIR}/job_*.sh
   fi
 
-jlfCall="${ANTSPATH}/antsJointFusion -d ${DIM} -t $TARGET_IMAGE --verbose 1 "
+jlfCall="antsJointFusion -d ${DIM} -t $TARGET_IMAGE --verbose 1 "
 
 if [[ $DOQSUB -eq 0 ]];
   then
@@ -687,7 +656,7 @@ if [[ $DOQSUB -eq 0 ]];
 
     if [[ $MAJORITYVOTE -eq 1 ]];
       then
-        jlfCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
+        jlfCall="ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
       else
 
         for (( i = 0; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
@@ -705,7 +674,7 @@ if [[ $DOQSUB -eq 0 ]];
         if [[ ${TARGET_MASK_IMAGE} == 'otsu' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOtsu.nii.gz"
-            maskCall="${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
+            maskCall="ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
 
@@ -713,17 +682,17 @@ if [[ $DOQSUB -eq 0 ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOr.nii.gz"
 
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_LABELS[0]} ${EXISTING_WARPED_ATLAS_LABELS[1]};"
+            maskCall="ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_LABELS[0]} ${EXISTING_WARPED_ATLAS_LABELS[1]};"
             for (( i = 2; i < ${#EXISTING_WARPED_ATLAS_LABELS[@]}; i++ ))
               do
-                maskCall="${maskCall} ${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_LABELS[$i]};"
+                maskCall="${maskCall} ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_LABELS[$i]};"
               done
-            maskCall="${maskCall} ${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
+            maskCall="${maskCall} ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
 
         elif [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
           then
             MAJORITY_VOTING_IMAGE="${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${MAJORITY_VOTING_IMAGE} MajorityVoting 0.8 ${EXISTING_WARPED_ATLAS_LABELS[@]};"
+            maskCall="ImageMath ${DIM} ${MAJORITY_VOTING_IMAGE} MajorityVoting 0.8 ${EXISTING_WARPED_ATLAS_LABELS[@]};"
             jlfCall="${jlfCall} -x ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting_Mask.nii.gz"
 
         elif [[ -f ${TARGET_MASK_IMAGE} ]];
@@ -739,7 +708,7 @@ if [[ $DOQSUB -eq 0 ]];
 
     if [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
       then
-        combineCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
+        combineCall="ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
         echo "$combineCall" >> $qscript2
       fi
 
@@ -754,7 +723,7 @@ if [[ $DOQSUB -eq 1 ]];
     echo " Starting JLF on SGE cluster. "
     echo "--------------------------------------------------------------------------------------"
 
-    ${ANTSPATH}/waitForSGEQJobs.pl 1 600 $jobIDs
+    waitForSGEQJobs.pl 1 600 $jobIDs
 
     # Returns 1 if there are errors
     if [[ ! $? -eq 0 ]];
@@ -789,7 +758,7 @@ if [[ $DOQSUB -eq 1 ]];
 
     if [[ $MAJORITYVOTE -eq 1 ]];
       then
-        jlfCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
+        jlfCall="ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
       else
 
         for (( i = 0; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
@@ -807,7 +776,7 @@ if [[ $DOQSUB -eq 1 ]];
         if [[ ${TARGET_MASK_IMAGE} == 'otsu' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOtsu.nii.gz"
-            maskCall="${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
+            maskCall="ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
 
@@ -815,12 +784,12 @@ if [[ $DOQSUB -eq 1 ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOr.nii.gz"
 
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_IMAGES[0]} ${EXISTING_WARPED_ATLAS_IMAGES[1]};"
+            maskCall="ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_IMAGES[0]} ${EXISTING_WARPED_ATLAS_IMAGES[1]};"
             for (( i = 2; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
               do
-                maskCall="${maskCall} ${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_IMAGES[$i]};"
+                maskCall="${maskCall} ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_IMAGES[$i]};"
               done
-            maskCall="${maskCall} ${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
+            maskCall="${maskCall} ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
         elif [[ -f ${TARGET_MASK_IMAGE} ]];
@@ -836,12 +805,12 @@ if [[ $DOQSUB -eq 1 ]];
 
     if [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
       then
-        combineCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
+        combineCall="ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
         echo "$combineCall" >> $qscript2
       fi
 
-    jobIDs=`qsub -cwd -S /bin/bash -N antsJlf -v ANTSPATH=$ANTSPATH $QSUB_OPTS $qscript2 | awk '{print $3}'`
-    ${ANTSPATH}/waitForSGEQJobs.pl 1 600 $jobIDs
+    jobIDs=`qsub -cwd -S /bin/bash -N antsJlf $QSUB_OPTS $qscript2 | awk '{print $3}'`
+    waitForSGEQJobs.pl 1 600 $jobIDs
   fi
 if [[ $DOQSUB -eq 4 ]];
   then
@@ -851,7 +820,7 @@ if [[ $DOQSUB -eq 4 ]];
     echo " Starting JLF on PBS cluster. "
     echo "--------------------------------------------------------------------------------------"
 
-    ${ANTSPATH}/waitForPBSQJobs.pl 1 600 $jobIDs
+    waitForPBSQJobs.pl 1 600 $jobIDs
     # Returns 1 if there are errors
     if [[ ! $? -eq 0 ]];
       then
@@ -885,7 +854,7 @@ if [[ $DOQSUB -eq 4 ]];
 
     if [[ $MAJORITYVOTE -eq 1 ]];
       then
-        jlfCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
+        jlfCall="ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
       else
 
         for (( i = 0; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
@@ -903,7 +872,7 @@ if [[ $DOQSUB -eq 4 ]];
         if [[ ${TARGET_MASK_IMAGE} == 'otsu' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOtsu.nii.gz"
-            maskCall="${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
+            maskCall="ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
 
@@ -911,17 +880,17 @@ if [[ $DOQSUB -eq 4 ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOr.nii.gz"
 
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_LABELS[0]} ${EXISTING_WARPED_ATLAS_LABELS[1]};"
+            maskCall="ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_LABELS[0]} ${EXISTING_WARPED_ATLAS_LABELS[1]};"
             for (( i = 2; i < ${#EXISTING_WARPED_ATLAS_LABELS[@]}; i++ ))
               do
-                maskCall="${maskCall} ${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_LABELS[$i]};"
+                maskCall="${maskCall} ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_LABELS[$i]};"
               done
-            maskCall="${maskCall} ${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
+            maskCall="${maskCall} ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
 
         elif [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
           then
             MAJORITY_VOTING_IMAGE="${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${MAJORITY_VOTING_IMAGE} MajorityVoting 0.8 ${EXISTING_WARPED_ATLAS_LABELS[@]};"
+            maskCall="ImageMath ${DIM} ${MAJORITY_VOTING_IMAGE} MajorityVoting 0.8 ${EXISTING_WARPED_ATLAS_LABELS[@]};"
             jlfCall="${jlfCall} -x ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting_Mask.nii.gz"
 
         elif [[ -f ${TARGET_MASK_IMAGE} ]];
@@ -937,12 +906,12 @@ if [[ $DOQSUB -eq 4 ]];
 
     if [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
       then
-        combineCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
+        combineCall="ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
         echo "$combineCall" >> $qscript2
       fi
 
-    jobIDs=`qsub -N antsJlf -v ANTSPATH=$ANTSPATH $QSUB_OPTS -q nopreempt -l nodes=1:ppn=1 -l mem=${JLF_MEMORY} -l walltime=${JLF_WALLTIME} $qscript2 | awk '{print $1}'`
-    ${ANTSPATH}/waitForPBSQJobs.pl 1 600 $jobIDs
+    jobIDs=`qsub -N antsJlf $QSUB_OPTS -q nopreempt -l nodes=1:ppn=1 -l mem=${JLF_MEMORY} -l walltime=${JLF_WALLTIME} $qscript2 | awk '{print $1}'`
+    waitForPBSQJobs.pl 1 600 $jobIDs
   fi
 
 if [[ $DOQSUB -eq 2 ]];
@@ -973,7 +942,7 @@ if [[ $DOQSUB -eq 2 ]];
 
     if [[ $MAJORITYVOTE -eq 1 ]];
       then
-        jlfCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
+        jlfCall="ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
       else
 
         for (( i = 0; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
@@ -991,7 +960,7 @@ if [[ $DOQSUB -eq 2 ]];
         if [[ ${TARGET_MASK_IMAGE} == 'otsu' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOtsu.nii.gz"
-            maskCall="${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
+            maskCall="ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
 
@@ -999,17 +968,17 @@ if [[ $DOQSUB -eq 2 ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOr.nii.gz"
 
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_LABELS[0]} ${EXISTING_WARPED_ATLAS_LABELS[1]};"
+            maskCall="ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_LABELS[0]} ${EXISTING_WARPED_ATLAS_LABELS[1]};"
             for (( i = 2; i < ${#EXISTING_WARPED_ATLAS_LABELS[@]}; i++ ))
               do
-                maskCall="${maskCall} ${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_LABELS[$i]};"
+                maskCall="${maskCall} ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_LABELS[$i]};"
               done
-            maskCall="${maskCall} ${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
+            maskCall="${maskCall} ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
 
         elif [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
           then
             MAJORITY_VOTING_IMAGE="${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${MAJORITY_VOTING_IMAGE} MajorityVoting 0.8 ${EXISTING_WARPED_ATLAS_LABELS[@]};"
+            maskCall="ImageMath ${DIM} ${MAJORITY_VOTING_IMAGE} MajorityVoting 0.8 ${EXISTING_WARPED_ATLAS_LABELS[@]};"
             jlfCall="${jlfCall} -x ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting_Mask.nii.gz"
 
         elif [[ -f ${TARGET_MASK_IMAGE} ]];
@@ -1025,7 +994,7 @@ if [[ $DOQSUB -eq 2 ]];
 
     if [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
       then
-        combineCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
+        combineCall="ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
         echo "$combineCall" >> $qscript2
       fi
 
@@ -1039,7 +1008,7 @@ if [[ $DOQSUB -eq 3 ]];
     echo " Starting JLF on XGrid cluster. Submitted $count jobs "
     echo "--------------------------------------------------------------------------------------"
 
-    ${ANTSPATH}/waitForXGridJobs.pl -xgridflags "$XGRID_OPTS" -verbose -delay 30 $jobIDs
+    waitForXGridJobs.pl -xgridflags "$XGRID_OPTS" -verbose -delay 30 $jobIDs
     # Returns 1 if there are errors
     if [[ ! $? -eq 0 ]];
       then
@@ -1073,7 +1042,7 @@ if [[ $DOQSUB -eq 3 ]];
 
     if [[ $MAJORITYVOTE -eq 1 ]];
       then
-        jlfCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
+        jlfCall="ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
       else
 
         for (( i = 0; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
@@ -1091,7 +1060,7 @@ if [[ $DOQSUB -eq 3 ]];
         if [[ ${TARGET_MASK_IMAGE} == 'otsu' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOtsu.nii.gz"
-            maskCall="${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
+            maskCall="ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
 
@@ -1099,17 +1068,17 @@ if [[ $DOQSUB -eq 3 ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOr.nii.gz"
 
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_LABELS[0]} ${EXISTING_WARPED_ATLAS_LABELS[1]};"
+            maskCall="ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_LABELS[0]} ${EXISTING_WARPED_ATLAS_LABELS[1]};"
             for (( i = 2; i < ${#EXISTING_WARPED_ATLAS_LABELS[@]}; i++ ))
               do
-                maskCall="${maskCall} ${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_LABELS[$i]};"
+                maskCall="${maskCall} ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_LABELS[$i]};"
               done
-            maskCall="${maskCall} ${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
+            maskCall="${maskCall} ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
 
         elif [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
           then
             MAJORITY_VOTING_IMAGE="${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${MAJORITY_VOTING_IMAGE} MajorityVoting 0.8 ${EXISTING_WARPED_ATLAS_LABELS[@]};"
+            maskCall="ImageMath ${DIM} ${MAJORITY_VOTING_IMAGE} MajorityVoting 0.8 ${EXISTING_WARPED_ATLAS_LABELS[@]};"
             jlfCall="${jlfCall} -x ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting_Mask.nii.gz"
 
         elif [[ -f ${TARGET_MASK_IMAGE} ]];
@@ -1125,7 +1094,7 @@ if [[ $DOQSUB -eq 3 ]];
 
     if [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
       then
-        combineCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
+        combineCall="ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
         echo "$combineCall" >> $qscript2
       fi
 
@@ -1139,7 +1108,7 @@ if [[ $DOQSUB -eq 5 ]];
     echo " Starting JLF on SLURM cluster. "
     echo "--------------------------------------------------------------------------------------"
 
-    ${ANTSPATH}/waitForSlurmJobs.pl 1 600 $jobIDs
+    waitForSlurmJobs.pl 1 600 $jobIDs
     # Returns 1 if there are errors
     if [[ ! $? -eq 0 ]];
       then
@@ -1176,7 +1145,7 @@ if [[ $DOQSUB -eq 5 ]];
 
     if [[ $MAJORITYVOTE -eq 1 ]];
       then
-        jlfCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
+        jlfCall="ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
       else
 
         for (( i = 0; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
@@ -1194,7 +1163,7 @@ if [[ $DOQSUB -eq 5 ]];
         if [[ ${TARGET_MASK_IMAGE} == 'otsu' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOtsu.nii.gz"
-            maskCall="${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
+            maskCall="ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
 
@@ -1202,17 +1171,17 @@ if [[ $DOQSUB -eq 5 ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOr.nii.gz"
 
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_LABELS[0]} ${EXISTING_WARPED_ATLAS_LABELS[1]};"
+            maskCall="ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_LABELS[0]} ${EXISTING_WARPED_ATLAS_LABELS[1]};"
             for (( i = 2; i < ${#EXISTING_WARPED_ATLAS_LABELS[@]}; i++ ))
               do
-                maskCall="${maskCall} ${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_LABELS[$i]};"
+                maskCall="${maskCall} ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_LABELS[$i]};"
               done
-            maskCall="${maskCall} ${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
+            maskCall="${maskCall} ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
 
         elif [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
           then
             MAJORITY_VOTING_IMAGE="${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${MAJORITY_VOTING_IMAGE} MajorityVoting 0.8 ${EXISTING_WARPED_ATLAS_LABELS[@]};"
+            maskCall="ImageMath ${DIM} ${MAJORITY_VOTING_IMAGE} MajorityVoting 0.8 ${EXISTING_WARPED_ATLAS_LABELS[@]};"
             jlfCall="${jlfCall} -x ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting_Mask.nii.gz"
 
         elif [[ -f ${TARGET_MASK_IMAGE} ]];
@@ -1229,12 +1198,12 @@ if [[ $DOQSUB -eq 5 ]];
 
     if [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
       then
-        combineCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
+        combineCall="ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
         echo "$combineCall" >> $qscript2
       fi
 
-    jobIDs=`sbatch --job-name=antsJlf --export=ANTSPATH=$ANTSPATH $QSUB_OPTS --nodes=1 --cpus-per-task=1 --time=${JLF_WALLTIME} --mem=${JLF_MEMORY} $qscript2 | rev | cut -f1 -d\ | rev`
-    ${ANTSPATH}/waitForSlurmJobs.pl 1 600 $jobIDs
+    jobIDs=`sbatch --job-name=antsJlf $QSUB_OPTS --nodes=1 --cpus-per-task=1 --time=${JLF_WALLTIME} --mem=${JLF_MEMORY} $qscript2 | rev | cut -f1 -d\ | rev`
+    waitForSlurmJobs.pl 1 600 $jobIDs
   fi
 
 # clean up
diff --git a/Scripts/antsJointLabelFusion2.sh b/Scripts/antsJointLabelFusion2.sh
index 5ae7742a..d7e374ec 100755
--- a/Scripts/antsJointLabelFusion2.sh
+++ b/Scripts/antsJointLabelFusion2.sh
@@ -5,51 +5,22 @@ VERSION="0.0.0"
 # trap keyboard interrupt (control-c)
 trap control_c SIGINT
 
-function setPath {
-    cat <<SETPATH
-
---------------------------------------------------------------------------------------
-Error locating ANTS
---------------------------------------------------------------------------------------
-It seems that the ANTSPATH environment variable is not set. Please add the ANTSPATH
-variable. This can be achieved by editing the .bash_profile in the home directory.
-Add:
-
-ANTSPATH=/home/yourname/bin/ants/
-
-Or the correct location of the ANTS binaries.
-
-Alternatively, edit this script ( `basename $0` ) to set up this parameter correctly.
-
-SETPATH
-    exit 1
-}
-
-# Uncomment the line below in case you have not set the ANTSPATH variable in your environment.
-# export ANTSPATH=${ANTSPATH:="$HOME/bin/ants/"} # EDIT THIS
-
-#ANTSPATH=YOURANTSPATH
-if [[ ${#ANTSPATH} -le 3 ]];
-  then
-    setPath >&2
-  fi
-
 # Test availability of helper scripts.
 # No need to test this more than once. Can reside outside of the main loop.
-JLF=${ANTSPATH}/antsJointFusion
-ANTS=${ANTSPATH}/antsRegistration
-WARP=${ANTSPATH}/antsApplyTransforms
-SMOOTH=${ANTSPATH}/SmoothDisplacementField
-PEXEC=${ANTSPATH}/ANTSpexec.sh
-SGE=${ANTSPATH}/waitForSGEQJobs.pl
-PBS=${ANTSPATH}/waitForPBSQJobs.pl
-XGRID=${ANTSPATH}/waitForXGridJobs.pl
-SLURM=${ANTSPATH}/waitForSlurmJobs.pl
+JLF=antsJointFusion
+ANTS=antsRegistration
+WARP=antsApplyTransforms
+SMOOTH=SmoothDisplacementField
+PEXEC=ANTSpexec.sh
+SGE=waitForSGEQJobs.pl
+PBS=waitForPBSQJobs.pl
+XGRID=waitForXGridJobs.pl
+SLURM=waitForSlurmJobs.pl
 
 fle_error=0
 for FLE in $JLF $ANTS $WARP $SMOOTH $PEXEC $SGE $XGRID $PBS $SLURM
   do
-  if [[ ! -x $FLE ]];
+  if ! command -v $FLE &> /dev/null
     then
       echo
       echo "--------------------------------------------------------------------------------------"
@@ -329,7 +300,7 @@ Optional arguments:
 
 Requirements:
 
-This scripts relies on the following scripts in your $ANTSPATH directory. The script
+This scripts relies on the following scripts in your $PATH directory. The script
 will terminate prematurely if these files are not present or are not executable.
 - pexec.sh
 - waitForSGEQJobs.pl (only for use with Sun Grid Engine)
@@ -376,8 +347,6 @@ function reportParameters {
 --------------------------------------------------------------------------------------
  Parameters
 --------------------------------------------------------------------------------------
- ANTSPATH is $ANTSPATH
-
  Dimensionality:           $DIM
  Output prefix:            $OUTPUT_PREFIX
  Posteriors format:        $OUTPUT_POSTERIORS_FORMAT
@@ -699,10 +668,10 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
         continue
       fi
 
-    regcall=${ANTSPATH}/antsRegistrationSyN.sh
+    regcall=antsRegistrationSyN.sh
     if [[ $RUNQUICK -eq 1 ]];
       then
-        regcall=${ANTSPATH}/antsRegistrationSyNQuick.sh
+        regcall=antsRegistrationSyNQuick.sh
       fi
 
     if [[ ${#PIECEWISE_LABELS[@]} -eq 0 ]];
@@ -722,7 +691,7 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
                               -m ${ATLAS_IMAGES[$i]} \
                               -o ${OUTPUT_PREFIX}${BASENAME}_${i}_ > ${OUTPUT_PREFIX}${BASENAME}_${i}_log.txt"
 
-        labelXfrmCall="${ANTSPATH}/antsApplyTransforms \
+        labelXfrmCall="antsApplyTransforms \
                               -d ${DIM} \
                               --float 1 \
                               -i ${ATLAS_LABELS[$i]} \
@@ -732,12 +701,12 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
                               -t ${OUTPUT_PREFIX}${BASENAME}_${i}_1Warp.nii.gz \
                               -t ${OUTPUT_PREFIX}${BASENAME}_${i}_0GenericAffine.mat >> ${OUTPUT_PREFIX}${BASENAME}_${i}_log.txt"
 
-        copyImageHeaderCall="${ANTSPATH}/CopyImageHeaderInformation \
+        copyImageHeaderCall="CopyImageHeaderInformation \
                              ${TARGET_IMAGE} \
                              ${OUTPUT_PREFIX}${BASENAME}_${i}_Warped.nii.gz \
                              ${OUTPUT_PREFIX}${BASENAME}_${i}_Warped.nii.gz 1 1 1"
 
-        copyLabelsHeaderCall="${ANTSPATH}/CopyImageHeaderInformation \
+        copyLabelsHeaderCall="CopyImageHeaderInformation \
                               ${TARGET_IMAGE} \
                               ${OUTPUT_PREFIX}${BASENAME}_${i}_WarpedLabels.nii.gz \
                               ${OUTPUT_PREFIX}${BASENAME}_${i}_WarpedLabels.nii.gz 1 1 1"
@@ -776,12 +745,12 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
 
             PIECEWISE_MASKS[$j]="${PIECEWISE_OUTPUT_PREFIX}${PIECEWISE_LABELS[$j]}.nii.gz"
             PIECEWISE_DILATED_MASKS[$j]="${PIECEWISE_OUTPUT_PREFIX}Dilated${PIECEWISE_LABELS[$j]}.nii.gz"
-            thresholdCall="${ANTSPATH}/ThresholdImage ${DIM} ${ATLAS_LABELS[$i]} ${PIECEWISE_MASKS[$j]} ${PIECEWISE_LABELS[$j]} ${PIECEWISE_LABELS[$j]} 1 0"
+            thresholdCall="ThresholdImage ${DIM} ${ATLAS_LABELS[$i]} ${PIECEWISE_MASKS[$j]} ${PIECEWISE_LABELS[$j]} ${PIECEWISE_LABELS[$j]} 1 0"
 
             echo "$thresholdCall" >> $qscript
 
-            distanceCall="${ANTSPATH}/ImageMath ${DIM} ${PIECEWISE_DILATED_MASKS[$j]} MaurerDistance ${PIECEWISE_MASKS[$j]} 1"
-            thresholdCall="${ANTSPATH}/ThresholdImage ${DIM} ${PIECEWISE_DILATED_MASKS[$j]} ${PIECEWISE_DILATED_MASKS[$j]} -1000000 ${PIECEWISE_DILATION_RADII[$j]} 1 0"
+            distanceCall="ImageMath ${DIM} ${PIECEWISE_DILATED_MASKS[$j]} MaurerDistance ${PIECEWISE_MASKS[$j]} 1"
+            thresholdCall="ThresholdImage ${DIM} ${PIECEWISE_DILATED_MASKS[$j]} ${PIECEWISE_DILATED_MASKS[$j]} -1000000 ${PIECEWISE_DILATION_RADII[$j]} 1 0"
 
             echo "$distanceCall" >> $qscript
             echo "$thresholdCall" >> $qscript
@@ -790,7 +759,7 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
               then
                 echo "cp ${PIECEWISE_DILATED_MASKS[$j]} ${CONFIDENCE_DILATED_MASK}" >> $qscript
               else
-                addCall="${ANTSPATH}/ImageMath ${DIM} ${CONFIDENCE_DILATED_MASK} max ${CONFIDENCE_DILATED_MASK} ${PIECEWISE_DILATED_MASKS[$j]}"
+                addCall="ImageMath ${DIM} ${CONFIDENCE_DILATED_MASK} max ${CONFIDENCE_DILATED_MASK} ${PIECEWISE_DILATED_MASKS[$j]}"
                 echo "$addCall" >> $qscript
               fi
 
@@ -814,14 +783,14 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
                 echo "cp ${PIECEWISE_MASKS[$j]} ${SUBSET_CONFIDENCE_MASK}" >> $qscript
                 INITIAL_LABEL_IS_SPECIFIED=1
               else
-                addCall="${ANTSPATH}/ImageMath ${DIM} ${SUBSET_CONFIDENCE_MASK} max ${SUBSET_CONFIDENCE_MASK} ${PIECEWISE_MASKS[$j]}"
+                addCall="ImageMath ${DIM} ${SUBSET_CONFIDENCE_MASK} max ${SUBSET_CONFIDENCE_MASK} ${PIECEWISE_MASKS[$j]}"
                 echo "$addCall" >> $qscript
               fi
           done
 
         if [[ ${ISOTROPIC_RESAMPLING} != 'NA' ]];
           then
-            resampleCall="${ANTSPATH}/ResampleImage ${DIM} ${SUBSET_CONFIDENCE_MASK} ${SUBSET_CONFIDENCE_MASK} $ISOTROPIC_RESAMPLING_VECTOR 0 1"
+            resampleCall="ResampleImage ${DIM} ${SUBSET_CONFIDENCE_MASK} ${SUBSET_CONFIDENCE_MASK} $ISOTROPIC_RESAMPLING_VECTOR 0 1"
             echo "$resampleCall" >> $qscript
           fi
 
@@ -833,7 +802,7 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
 
         INIT_OUTPUT_PREFIX=${OUTPUT_PREFIX}${BASENAME}_${i}_Init
 
-        registrationCallInit="${ANTSPATH}/antsRegistration -d 3 -v 1 -o $INIT_OUTPUT_PREFIX -r [ ${ATLAS_IMAGES[$i]},${TARGET_IMAGE},0 ]"
+        registrationCallInit="antsRegistration -d 3 -v 1 -o $INIT_OUTPUT_PREFIX -r [ ${ATLAS_IMAGES[$i]},${TARGET_IMAGE},0 ]"
         registrationCallInit="$registrationCallInit -t Rigid[ 0.15 ] -m MI[ ${ATLAS_IMAGES[$i]},${TARGET_IMAGE},1,32,Regular,0.25 ] -c [ 100x40x10,1e-6,10 ] -f 6x4x3 -s 3x2x1"
         registrationCallInit="$registrationCallInit -t Similarity[ 0.15 ] -m MI[ ${ATLAS_IMAGES[$i]},${TARGET_IMAGE},1,32,Regular,0.25 ] -c [ 100x40x10,1e-6,10 ] -f 6x4x3 -s 3x2x1"
         registrationCallInit="$registrationCallInit -t Affine[ 0.15 ] -m MI[ ${ATLAS_IMAGES[$i]},${TARGET_IMAGE},1,32,Regular,0.25 ] -c [ 100x40x10,1e-6,10 ] -f 6x4x3 -s 3x2x1  >> $logFile"
@@ -864,7 +833,7 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
 
             PIECEWISE_OUTPUT_PREFIX=${OUTPUT_PREFIX}${BASENAME}_${i}_PiecewiseLabel${PIECEWISE_LABELS[$j]}_
 
-            registrationCallPiecewise="${ANTSPATH}/antsRegistration -d 3 -v 1 -z 0 -o $PIECEWISE_OUTPUT_PREFIX -r ${INIT_OUTPUT_PREFIX}0GenericAffine.mat -x ${PIECEWISE_DILATED_MASKS[$j]}"
+            registrationCallPiecewise="antsRegistration -d 3 -v 1 -z 0 -o $PIECEWISE_OUTPUT_PREFIX -r ${INIT_OUTPUT_PREFIX}0GenericAffine.mat -x ${PIECEWISE_DILATED_MASKS[$j]}"
             registrationCallPiecewise="$registrationCallPiecewise -t Rigid[ 0.15 ] -m MI[ ${ATLAS_IMAGES[$i]},${TARGET_IMAGE},1,32,Regular,0.25 ] -c [ 100x100x50,1e-6,10 ] -f 6x4x3 -s 3x2x1"
             registrationCallPiecewise="$registrationCallPiecewise -t Similarity[ 0.15 ] -m MI[ ${ATLAS_IMAGES[$i]},${TARGET_IMAGE},1,32,Regular,0.25 ] -c [ 100x100x50,1e-6,10 ] -f 6x4x3 -s 3x2x1"
             registrationCallPiecewise="$registrationCallPiecewise -t Affine[ 0.15 ] -m MI[ ${ATLAS_IMAGES[$i]},${TARGET_IMAGE},1,32,Regular,0.25 ] -c [ 100x100x50,1e-6,10 ] -f 6x4x3 -s 3x2x1"
@@ -890,25 +859,25 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
             TMP_FILES=( ${TMP_FILES[@]} ${PIECEWISE_OUTPUT_PREFIX}4InverseWarp.nii.gz )
             TMP_FILES=( ${TMP_FILES[@]} ${PIECEWISE_OUTPUT_PREFIX}TotalWarp.nii.gz )
 
-            componentCall="${ANTSPATH}/ConvertImage ${DIM} ${PIECEWISE_OUTPUT_PREFIX}TotalWarp.nii.gz ${PIECEWISE_OUTPUT_PREFIX}TotalWarp 10"
+            componentCall="ConvertImage ${DIM} ${PIECEWISE_OUTPUT_PREFIX}TotalWarp.nii.gz ${PIECEWISE_OUTPUT_PREFIX}TotalWarp 10"
             echo "$componentCall" >> $qscript
 
             components=( 'xvec' 'yvec' 'zvec' )
             for (( d = 0; d < ${DIM}; d++ ))
               do
-                maskingCall="${ANTSPATH}/ImageMath 3 ${PIECEWISE_OUTPUT_PREFIX}TotalWarp${components[$d]}.nii.gz m ${PIECEWISE_OUTPUT_PREFIX}TotalWarp${components[$d]}.nii.gz ${PIECEWISE_MASKS[$j]}"
+                maskingCall="ImageMath 3 ${PIECEWISE_OUTPUT_PREFIX}TotalWarp${components[$d]}.nii.gz m ${PIECEWISE_OUTPUT_PREFIX}TotalWarp${components[$d]}.nii.gz ${PIECEWISE_MASKS[$j]}"
                 echo "$maskingCall" >> $qscript
 
                 if [[ ${ISOTROPIC_RESAMPLING} != 'NA' ]];
                   then
-                    resampleCall="${ANTSPATH}/ResampleImage 3 ${PIECEWISE_OUTPUT_PREFIX}TotalWarp${components[$d]}.nii.gz ${PIECEWISE_OUTPUT_PREFIX}TotalWarp${components[$d]}.nii.gz $ISOTROPIC_RESAMPLING_VECTOR 0 0"
+                    resampleCall="ResampleImage 3 ${PIECEWISE_OUTPUT_PREFIX}TotalWarp${components[$d]}.nii.gz ${PIECEWISE_OUTPUT_PREFIX}TotalWarp${components[$d]}.nii.gz $ISOTROPIC_RESAMPLING_VECTOR 0 0"
                     echo "$resampleCall" >> $qscript
                   fi
 
                 TMP_FILES=( ${TMP_FILES[@]} ${PIECEWISE_OUTPUT_PREFIX}TotalWarp${components[$d]}.nii.gz )
               done
 
-            componentCall="${ANTSPATH}/ConvertImage ${DIM} ${PIECEWISE_OUTPUT_PREFIX}TotalWarp ${PIECEWISE_OUTPUT_PREFIX}TotalWarp.nii.gz 9"
+            componentCall="ConvertImage ${DIM} ${PIECEWISE_OUTPUT_PREFIX}TotalWarp ${PIECEWISE_OUTPUT_PREFIX}TotalWarp.nii.gz 9"
             echo "$componentCall" >> $qscript
 
             PIECEWISE_TRANSFORM_WARPS="${PIECEWISE_TRANSFORM_WARPS} -t ${PIECEWISE_OUTPUT_PREFIX}TotalWarp.nii.gz"
@@ -925,9 +894,9 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
 
         # Smooth the displacement field and estimate the inverse
 
-        smoothCall="${ANTSPATH}/SmoothDisplacementField ${DIM} ${OUTPUT_PREFIX}${BASENAME}_${i}_TotalWarp.nii.gz ${OUTPUT_PREFIX}${BASENAME}_${i}_TotalWarp.nii.gz 4x4x4 5 3 0 ${SUBSET_CONFIDENCE_MASK} >> $logFile"
+        smoothCall="SmoothDisplacementField ${DIM} ${OUTPUT_PREFIX}${BASENAME}_${i}_TotalWarp.nii.gz ${OUTPUT_PREFIX}${BASENAME}_${i}_TotalWarp.nii.gz 4x4x4 5 3 0 ${SUBSET_CONFIDENCE_MASK} >> $logFile"
         echo "$smoothCall" >> $qscript
-        inverseSmoothCall="${ANTSPATH}/SmoothDisplacementField ${DIM} ${OUTPUT_PREFIX}${BASENAME}_${i}_TotalWarp.nii.gz ${OUTPUT_PREFIX}${BASENAME}_${i}_TotalInverseWarp.nii.gz 4x4x4 5 3 1 >> $logFile"
+        inverseSmoothCall="SmoothDisplacementField ${DIM} ${OUTPUT_PREFIX}${BASENAME}_${i}_TotalWarp.nii.gz ${OUTPUT_PREFIX}${BASENAME}_${i}_TotalInverseWarp.nii.gz 4x4x4 5 3 1 >> $logFile"
         echo "$inverseSmoothCall" >> $qscript
 
         # Resample to the full size
@@ -946,12 +915,12 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
 
         # Now do a more refined registration
 
-        registrationCallRefined="${ANTSPATH}/antsRegistration -d 3 -v 1 -z 0 -o ${OUTPUT_PREFIX}${BASENAME}_${i}_ -r ${OUTPUT_PREFIX}${BASENAME}_${i}_TotalWarp.nii.gz -r ${INIT_OUTPUT_PREFIX}0GenericAffine.mat -x ${CONFIDENCE_DILATED_MASK}"
+        registrationCallRefined="antsRegistration -d 3 -v 1 -z 0 -o ${OUTPUT_PREFIX}${BASENAME}_${i}_ -r ${OUTPUT_PREFIX}${BASENAME}_${i}_TotalWarp.nii.gz -r ${INIT_OUTPUT_PREFIX}0GenericAffine.mat -x ${CONFIDENCE_DILATED_MASK}"
         registrationCallRefined="$registrationCallRefined -t BSplineSyN[ 0.15,40,0 ] -m CC[ ${ATLAS_IMAGES[$i]},${TARGET_IMAGE},1,2 ] -c [ 100x40x0,1e-6,10 ] -f 6x4x1 -s 2x1x0 >> $logFile"
 
         echo "$registrationCallRefined" >> $qscript
 
-        atlasXfrmCall="${ANTSPATH}/antsApplyTransforms \
+        atlasXfrmCall="antsApplyTransforms \
                               -d ${DIM} \
                               --float 1 \
                               -i ${ATLAS_IMAGES[$i]} \
@@ -963,7 +932,7 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
                               -t ${OUTPUT_PREFIX}${BASENAME}_${i}_2InverseWarp.nii.gz >> ${OUTPUT_PREFIX}${BASENAME}_${i}_log.txt"
         echo "$atlasXfrmCall" >> $qscript
 
-        labelXfrmCall="${ANTSPATH}/antsApplyTransforms \
+        labelXfrmCall="antsApplyTransforms \
                               -d ${DIM} \
                               --float 1 \
                               -i ${ATLAS_LABELS[$i]} \
@@ -979,13 +948,13 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
         TMP_FILES=( ${TMP_FILES[@]} ${OUTPUT_PREFIX}${BASENAME}_${i}_TotalWarp.nii.gz ${OUTPUT_PREFIX}${BASENAME}_${i}_TotalInverseWarp.nii.gz )
         TMP_FILES=( ${TMP_FILES[@]} ${OUTPUT_PREFIX}${BASENAME}_${i}_2Warp.nii.gz ${OUTPUT_PREFIX}${BASENAME}_${i}_2InverseWarp.nii.gz )
 
-        copyImageHeaderCall="${ANTSPATH}/CopyImageHeaderInformation \
+        copyImageHeaderCall="CopyImageHeaderInformation \
                              ${TARGET_IMAGE} \
                              ${OUTPUT_PREFIX}${BASENAME}_${i}_Warped.nii.gz \
                              ${OUTPUT_PREFIX}${BASENAME}_${i}_Warped.nii.gz 1 1 1"
         echo "$copyImageHeaderCall" >> $qscript
 
-        copyLabelsHeaderCall="${ANTSPATH}/CopyImageHeaderInformation \
+        copyLabelsHeaderCall="CopyImageHeaderInformation \
                               ${TARGET_IMAGE} \
                               ${OUTPUT_PREFIX}${BASENAME}_${i}_WarpedLabels.nii.gz \
                               ${OUTPUT_PREFIX}${BASENAME}_${i}_WarpedLabels.nii.gz 1 1 1"
@@ -1003,12 +972,12 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
 
     if [[ $DOQSUB -eq 1 ]];
       then
-        id=`qsub -cwd -S /bin/bash -N antsJlfReg -v ANTSPATH=$ANTSPATH $QSUB_OPTS $qscript | awk '{print $3}'`
+        id=`qsub -cwd -S /bin/bash -N antsJlfReg  $QSUB_OPTS $qscript | awk '{print $3}'`
         jobIDs="$jobIDs $id"
         sleep 0.5
     elif [[ $DOQSUB -eq 4 ]];
       then
-        id=`qsub -N antsJlfReg -v ANTSPATH=$ANTSPATH $QSUB_OPTS -q nopreempt -l nodes=1:ppn=1 -l mem=${REGISTRATION_MEMORY} -l walltime=${REGISTRATION_WALLTIME} $qscript | awk '{print $1}'`
+        id=`qsub -N antsJlfReg  $QSUB_OPTS -q nopreempt -l nodes=1:ppn=1 -l mem=${REGISTRATION_MEMORY} -l walltime=${REGISTRATION_WALLTIME} $qscript | awk '{print $1}'`
         jobIDs="$jobIDs $id"
         sleep 0.5
     elif [[ $DOQSUB -eq 3 ]];
@@ -1017,7 +986,7 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
         jobIDs="$jobIDs $id"
     elif [[ $DOQSUB -eq 5 ]];
       then
-        id=`sbatch --job-name=antsJlfReg${i} --export=ANTSPATH=$ANTSPATH $QSUB_OPTS --nodes=1 --cpus-per-task=1 --time=${REGISTRATION_WALLTIME} --mem=${REGISTRATION_MEMORY} $qscript | rev | cut -f1 -d\ | rev`
+        id=`sbatch --job-name=antsJlfReg${i}  $QSUB_OPTS --nodes=1 --cpus-per-task=1 --time=${REGISTRATION_WALLTIME} --mem=${REGISTRATION_MEMORY} $qscript | rev | cut -f1 -d\ | rev`
         jobIDs="$jobIDs $id"
         sleep 0.5
     elif [[ $DOQSUB -eq 0 ]];
@@ -1037,7 +1006,7 @@ if [[ $DOQSUB -eq 2 ]];
     $PEXEC -j ${CORES} "sh" ${OUTPUT_DIR}/job_*.sh
   fi
 
-jlfCall="${ANTSPATH}/antsJointFusion -d ${DIM} -t $TARGET_IMAGE --verbose 1 "
+jlfCall="antsJointFusion -d ${DIM} -t $TARGET_IMAGE --verbose 1 "
 
 if [[ $DOQSUB -eq 0 ]];
   then
@@ -1073,7 +1042,7 @@ if [[ $DOQSUB -eq 0 ]];
 
     if [[ $MAJORITYVOTE -eq 1 ]];
       then
-        jlfCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
+        jlfCall="ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
       else
 
         for (( i = 0; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
@@ -1091,7 +1060,7 @@ if [[ $DOQSUB -eq 0 ]];
         if [[ ${TARGET_MASK_IMAGE} == 'otsu' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOtsu.nii.gz"
-            maskCall="${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
+            maskCall="ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
 
@@ -1099,17 +1068,17 @@ if [[ $DOQSUB -eq 0 ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOr.nii.gz"
 
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_LABELS[0]} ${EXISTING_WARPED_ATLAS_LABELS[1]};"
+            maskCall="ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_LABELS[0]} ${EXISTING_WARPED_ATLAS_LABELS[1]};"
             for (( i = 2; i < ${#EXISTING_WARPED_ATLAS_LABELS[@]}; i++ ))
               do
-                maskCall="${maskCall} ${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_LABELS[$i]};"
+                maskCall="${maskCall} ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_LABELS[$i]};"
               done
-            maskCall="${maskCall} ${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
+            maskCall="${maskCall} ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
 
         elif [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
           then
             MAJORITY_VOTING_IMAGE="${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${MAJORITY_VOTING_IMAGE} MajorityVoting 0.8 ${EXISTING_WARPED_ATLAS_LABELS[@]};"
+            maskCall="ImageMath ${DIM} ${MAJORITY_VOTING_IMAGE} MajorityVoting 0.8 ${EXISTING_WARPED_ATLAS_LABELS[@]};"
             jlfCall="${jlfCall} -x ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting_Mask.nii.gz"
 
         elif [[ -f ${TARGET_MASK_IMAGE} ]];
@@ -1125,7 +1094,7 @@ if [[ $DOQSUB -eq 0 ]];
 
     if [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
       then
-        combineCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
+        combineCall="ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
         echo "$combineCall" >> $qscript2
       fi
 
@@ -1140,7 +1109,7 @@ if [[ $DOQSUB -eq 1 ]];
     echo " Starting JLF on SGE cluster. "
     echo "--------------------------------------------------------------------------------------"
 
-    ${ANTSPATH}/waitForSGEQJobs.pl 1 600 $jobIDs
+    waitForSGEQJobs.pl 1 600 $jobIDs
 
     # Returns 1 if there are errors
     if [[ ! $? -eq 0 ]];
@@ -1175,7 +1144,7 @@ if [[ $DOQSUB -eq 1 ]];
 
     if [[ $MAJORITYVOTE -eq 1 ]];
       then
-        jlfCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
+        jlfCall="ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
       else
 
         for (( i = 0; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
@@ -1193,7 +1162,7 @@ if [[ $DOQSUB -eq 1 ]];
         if [[ ${TARGET_MASK_IMAGE} == 'otsu' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOtsu.nii.gz"
-            maskCall="${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
+            maskCall="ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
 
@@ -1201,17 +1170,17 @@ if [[ $DOQSUB -eq 1 ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOr.nii.gz"
 
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_LABELS[0]} ${EXISTING_WARPED_ATLAS_LABELS[1]};"
+            maskCall="ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_LABELS[0]} ${EXISTING_WARPED_ATLAS_LABELS[1]};"
             for (( i = 2; i < ${#EXISTING_WARPED_ATLAS_LABELS[@]}; i++ ))
               do
-                maskCall="${maskCall} ${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_LABELS[$i]};"
+                maskCall="${maskCall} ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_LABELS[$i]};"
               done
-            maskCall="${maskCall} ${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
+            maskCall="${maskCall} ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
 
         elif [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
           then
             MAJORITY_VOTING_IMAGE="${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${MAJORITY_VOTING_IMAGE} MajorityVoting 0.8 ${EXISTING_WARPED_ATLAS_LABELS[@]};"
+            maskCall="ImageMath ${DIM} ${MAJORITY_VOTING_IMAGE} MajorityVoting 0.8 ${EXISTING_WARPED_ATLAS_LABELS[@]};"
             jlfCall="${jlfCall} -x ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting_Mask.nii.gz"
 
         elif [[ -f ${TARGET_MASK_IMAGE} ]];
@@ -1227,12 +1196,12 @@ if [[ $DOQSUB -eq 1 ]];
 
     if [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
       then
-        combineCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
+        combineCall="ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
         echo "$combineCall" >> $qscript2
       fi
 
-    jobIDs=`qsub -cwd -S /bin/bash -N antsJlf -v ANTSPATH=$ANTSPATH $QSUB_OPTS $qscript2 | awk '{print $3}'`
-    ${ANTSPATH}/waitForSGEQJobs.pl 1 600 $jobIDs
+    jobIDs=`qsub -cwd -S /bin/bash -N antsJlf  $QSUB_OPTS $qscript2 | awk '{print $3}'`
+    waitForSGEQJobs.pl 1 600 $jobIDs
   fi
 if [[ $DOQSUB -eq 4 ]];
   then
@@ -1242,7 +1211,7 @@ if [[ $DOQSUB -eq 4 ]];
     echo " Starting JLF on PBS cluster. "
     echo "--------------------------------------------------------------------------------------"
 
-    ${ANTSPATH}/waitForPBSQJobs.pl 1 600 $jobIDs
+    waitForPBSQJobs.pl 1 600 $jobIDs
     # Returns 1 if there are errors
     if [[ ! $? -eq 0 ]];
       then
@@ -1276,7 +1245,7 @@ if [[ $DOQSUB -eq 4 ]];
 
     if [[ $MAJORITYVOTE -eq 1 ]];
       then
-        jlfCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
+        jlfCall="ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
       else
 
         for (( i = 0; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
@@ -1294,7 +1263,7 @@ if [[ $DOQSUB -eq 4 ]];
         if [[ ${TARGET_MASK_IMAGE} == 'otsu' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOtsu.nii.gz"
-            maskCall="${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
+            maskCall="ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
 
@@ -1302,17 +1271,17 @@ if [[ $DOQSUB -eq 4 ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOr.nii.gz"
 
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_LABELS[0]} ${EXISTING_WARPED_ATLAS_LABELS[1]};"
+            maskCall="ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_LABELS[0]} ${EXISTING_WARPED_ATLAS_LABELS[1]};"
             for (( i = 2; i < ${#EXISTING_WARPED_ATLAS_LABELS[@]}; i++ ))
               do
-                maskCall="${maskCall} ${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_LABELS[$i]};"
+                maskCall="${maskCall} ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_LABELS[$i]};"
               done
-            maskCall="${maskCall} ${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
+            maskCall="${maskCall} ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
 
         elif [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
           then
             MAJORITY_VOTING_IMAGE="${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${MAJORITY_VOTING_IMAGE} MajorityVoting 0.8 ${EXISTING_WARPED_ATLAS_LABELS[@]};"
+            maskCall="ImageMath ${DIM} ${MAJORITY_VOTING_IMAGE} MajorityVoting 0.8 ${EXISTING_WARPED_ATLAS_LABELS[@]};"
             jlfCall="${jlfCall} -x ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting_Mask.nii.gz"
 
         elif [[ -f ${TARGET_MASK_IMAGE} ]];
@@ -1328,12 +1297,12 @@ if [[ $DOQSUB -eq 4 ]];
 
     if [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
       then
-        combineCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
+        combineCall="ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
         echo "$combineCall" >> $qscript2
       fi
 
-    jobIDs=`qsub -N antsJlf -v ANTSPATH=$ANTSPATH $QSUB_OPTS -q nopreempt -l nodes=1:ppn=1 -l mem=${JLF_MEMORY} -l walltime=${JLF_WALLTIME} $qscript2 | awk '{print $1}'`
-    ${ANTSPATH}/waitForPBSQJobs.pl 1 600 $jobIDs
+    jobIDs=`qsub -N antsJlf  $QSUB_OPTS -q nopreempt -l nodes=1:ppn=1 -l mem=${JLF_MEMORY} -l walltime=${JLF_WALLTIME} $qscript2 | awk '{print $1}'`
+    waitForPBSQJobs.pl 1 600 $jobIDs
   fi
 
 if [[ $DOQSUB -eq 2 ]];
@@ -1364,7 +1333,7 @@ if [[ $DOQSUB -eq 2 ]];
 
     if [[ $MAJORITYVOTE -eq 1 ]];
       then
-        jlfCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
+        jlfCall="ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
       else
 
         for (( i = 0; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
@@ -1382,7 +1351,7 @@ if [[ $DOQSUB -eq 2 ]];
         if [[ ${TARGET_MASK_IMAGE} == 'otsu' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOtsu.nii.gz"
-            maskCall="${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
+            maskCall="ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
 
@@ -1390,17 +1359,17 @@ if [[ $DOQSUB -eq 2 ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOr.nii.gz"
 
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_LABELS[0]} ${EXISTING_WARPED_ATLAS_LABELS[1]};"
+            maskCall="ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_LABELS[0]} ${EXISTING_WARPED_ATLAS_LABELS[1]};"
             for (( i = 2; i < ${#EXISTING_WARPED_ATLAS_LABELS[@]}; i++ ))
               do
-                maskCall="${maskCall} ${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_LABELS[$i]};"
+                maskCall="${maskCall} ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_LABELS[$i]};"
               done
-            maskCall="${maskCall} ${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
+            maskCall="${maskCall} ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
 
         elif [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
           then
             MAJORITY_VOTING_IMAGE="${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${MAJORITY_VOTING_IMAGE} MajorityVoting 0.8 ${EXISTING_WARPED_ATLAS_LABELS[@]};"
+            maskCall="ImageMath ${DIM} ${MAJORITY_VOTING_IMAGE} MajorityVoting 0.8 ${EXISTING_WARPED_ATLAS_LABELS[@]};"
             jlfCall="${jlfCall} -x ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting_Mask.nii.gz"
 
         elif [[ -f ${TARGET_MASK_IMAGE} ]];
@@ -1416,7 +1385,7 @@ if [[ $DOQSUB -eq 2 ]];
 
     if [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
       then
-        combineCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
+        combineCall="ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
         echo "$combineCall" >> $qscript2
       fi
 
@@ -1430,7 +1399,7 @@ if [[ $DOQSUB -eq 3 ]];
     echo " Starting JLF on XGrid cluster. Submitted $count jobs "
     echo "--------------------------------------------------------------------------------------"
 
-    ${ANTSPATH}/waitForXGridJobs.pl -xgridflags "$XGRID_OPTS" -verbose -delay 30 $jobIDs
+    waitForXGridJobs.pl -xgridflags "$XGRID_OPTS" -verbose -delay 30 $jobIDs
     # Returns 1 if there are errors
     if [[ ! $? -eq 0 ]];
       then
@@ -1464,7 +1433,7 @@ if [[ $DOQSUB -eq 3 ]];
 
     if [[ $MAJORITYVOTE -eq 1 ]];
       then
-        jlfCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
+        jlfCall="ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
       else
 
         for (( i = 0; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
@@ -1482,7 +1451,7 @@ if [[ $DOQSUB -eq 3 ]];
         if [[ ${TARGET_MASK_IMAGE} == 'otsu' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOtsu.nii.gz"
-            maskCall="${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
+            maskCall="ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
 
@@ -1490,17 +1459,17 @@ if [[ $DOQSUB -eq 3 ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOr.nii.gz"
 
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_LABELS[0]} ${EXISTING_WARPED_ATLAS_LABELS[1]};"
+            maskCall="ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_LABELS[0]} ${EXISTING_WARPED_ATLAS_LABELS[1]};"
             for (( i = 2; i < ${#EXISTING_WARPED_ATLAS_LABELS[@]}; i++ ))
               do
-                maskCall="${maskCall} ${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_LABELS[$i]};"
+                maskCall="${maskCall} ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_LABELS[$i]};"
               done
-            maskCall="${maskCall} ${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
+            maskCall="${maskCall} ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
 
         elif [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
           then
             MAJORITY_VOTING_IMAGE="${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${MAJORITY_VOTING_IMAGE} MajorityVoting 0.8 ${EXISTING_WARPED_ATLAS_LABELS[@]};"
+            maskCall="ImageMath ${DIM} ${MAJORITY_VOTING_IMAGE} MajorityVoting 0.8 ${EXISTING_WARPED_ATLAS_LABELS[@]};"
             jlfCall="${jlfCall} -x ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting_Mask.nii.gz"
 
         elif [[ -f ${TARGET_MASK_IMAGE} ]];
@@ -1516,7 +1485,7 @@ if [[ $DOQSUB -eq 3 ]];
 
     if [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
       then
-        combineCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
+        combineCall="ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
         echo "$combineCall" >> $qscript2
       fi
 
@@ -1530,7 +1499,7 @@ if [[ $DOQSUB -eq 5 ]];
     echo " Starting JLF on SLURM cluster. "
     echo "--------------------------------------------------------------------------------------"
 
-    ${ANTSPATH}/waitForSlurmJobs.pl 1 600 $jobIDs
+    waitForSlurmJobs.pl 1 600 $jobIDs
     # Returns 1 if there are errors
     if [[ ! $? -eq 0 ]];
       then
@@ -1567,7 +1536,7 @@ if [[ $DOQSUB -eq 5 ]];
 
     if [[ $MAJORITYVOTE -eq 1 ]];
       then
-        jlfCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
+        jlfCall="ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
       else
 
         for (( i = 0; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
@@ -1585,7 +1554,7 @@ if [[ $DOQSUB -eq 5 ]];
         if [[ ${TARGET_MASK_IMAGE} == 'otsu' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOtsu.nii.gz"
-            maskCall="${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
+            maskCall="ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
 
@@ -1593,17 +1562,17 @@ if [[ $DOQSUB -eq 5 ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOr.nii.gz"
 
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_LABELS[0]} ${EXISTING_WARPED_ATLAS_LABELS[1]};"
+            maskCall="ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_LABELS[0]} ${EXISTING_WARPED_ATLAS_LABELS[1]};"
             for (( i = 2; i < ${#EXISTING_WARPED_ATLAS_LABELS[@]}; i++ ))
               do
-                maskCall="${maskCall} ${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_LABELS[$i]};"
+                maskCall="${maskCall} ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_LABELS[$i]};"
               done
-            maskCall="${maskCall} ${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
+            maskCall="${maskCall} ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
 
         elif [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
           then
             MAJORITY_VOTING_IMAGE="${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${MAJORITY_VOTING_IMAGE} MajorityVoting 0.8 ${EXISTING_WARPED_ATLAS_LABELS[@]};"
+            maskCall="ImageMath ${DIM} ${MAJORITY_VOTING_IMAGE} MajorityVoting 0.8 ${EXISTING_WARPED_ATLAS_LABELS[@]};"
             jlfCall="${jlfCall} -x ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting_Mask.nii.gz"
 
         elif [[ -f ${TARGET_MASK_IMAGE} ]];
@@ -1620,12 +1589,12 @@ if [[ $DOQSUB -eq 5 ]];
 
     if [[ ${TARGET_MASK_IMAGE} == 'majorityvoting' ]];
       then
-        combineCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
+        combineCall="ImageMath ${DIM} ${OUTPUT_PREFIX}Labels.nii.gz max ${OUTPUT_PREFIX}Labels.nii.gz ${OUTPUT_PREFIX}TargetMaskImageMajorityVoting.nii.gz"
         echo "$combineCall" >> $qscript2
       fi
 
-    jobIDs=`sbatch --job-name=antsJlf --export=ANTSPATH=$ANTSPATH $QSUB_OPTS --nodes=1 --cpus-per-task=1 --time=${JLF_WALLTIME} --mem=${JLF_MEMORY} $qscript2 | rev | cut -f1 -d\ | rev`
-    ${ANTSPATH}/waitForSlurmJobs.pl 1 600 $jobIDs
+    jobIDs=`sbatch --job-name=antsJlf  $QSUB_OPTS --nodes=1 --cpus-per-task=1 --time=${JLF_WALLTIME} --mem=${JLF_MEMORY} $qscript2 | rev | cut -f1 -d\ | rev`
+    waitForSlurmJobs.pl 1 600 $jobIDs
   fi
 
 # clean up
diff --git a/Scripts/antsLongitudinalCorticalThickness.sh b/Scripts/antsLongitudinalCorticalThickness.sh
index 03ba1c6f..b5f0cbcd 100755
--- a/Scripts/antsLongitudinalCorticalThickness.sh
+++ b/Scripts/antsLongitudinalCorticalThickness.sh
@@ -9,20 +9,20 @@ SCRIPTS_DEPENDENCIES=( 'antsBrainExtraction.sh' 'antsAtroposN4.sh' 'antsMultivar
 
 for D in ${PROGRAM_DEPENDENCIES[@]};
   do
-    if [[ ! -s ${ANTSPATH}/${D} ]];
+    if ! command -v ${D} &> /dev/null
       then
         echo "Error:  we can't find the $D program."
-        echo "Perhaps you need to \(re\)define \$ANTSPATH in your environment."
+        echo "Perhaps you need to \(re\)define \$PATH in your environment."
         exit
       fi
   done
 
 for D in ${SCRIPT_DEPENDENCIES[@]};
   do
-    if [[ ! -s ${ANTSPATH}/${D} ]];
+    if ! command -v ${D} &> /dev/null
       then
         echo "We can't find the $D script."
-        echo "Perhaps you need to \(re\)define \$ANTSPATH in your environment."
+        echo "Perhaps you need to \(re\)define \$PATH in your environment."
         exit
       fi
   done
@@ -548,7 +548,7 @@ if [[ ${#ANATOMICAL_IMAGES[@]} -eq ${NUMBER_OF_MODALITIES} ]];
     # But if you are running a longitudinal script without longitudinal data, that may not be the only problem
     #if [[ $DO_REGISTRATION_TO_TEMPLATE -eq 1 ]];
     #    then
-    #      logCmd ${ANTSPATH}/antsCorticalThickness.sh \
+    #      logCmd antsCorticalThickness.sh \
     #        -d ${DIMENSION} \
     #        -x ${ATROPOS_SEGMENTATION_INTERNAL_ITERATIONS} \
     #        -t ${REGISTRATION_TEMPLATE} \
@@ -567,7 +567,7 @@ if [[ ${#ANATOMICAL_IMAGES[@]} -eq ${NUMBER_OF_MODALITIES} ]];
 
     #if [[ $DO_REGISTRATION_TO_TEMPLATE -eq 0 ]];
     #  then
-    #     logCmd ${ANTSPATH}/antsCorticalThickness.sh \
+    #     logCmd antsCorticalThickness.sh \
     #       -d ${DIMENSION} \
     #       -x ${ATROPOS_SEGMENTATION_INTERNAL_ITERATIONS} \
     #       -q ${RUN_FAST_ANTSCT_TO_GROUP_TEMPLATE} \
@@ -589,7 +589,7 @@ if [[ ${#ANATOMICAL_IMAGES[@]} -eq ${NUMBER_OF_MODALITIES} ]];
     OUTPUT_DIRECTORY_FOR_SINGLE_SUBJECT_TEMPLATE="${OUTPUT_PREFIX}SingleSubjectTemplate/"
     SINGLE_SUBJECT_TEMPLATE=${OUTPUT_DIRECTORY_FOR_SINGLE_SUBJECT_TEMPLATE}T_template0.nii.gz
     logCmd mkdir -p ${OUTPUT_DIRECTORY_FOR_SINGLE_SUBJECT_TEMPLATE}
-    logCmd ${ANTSPATH}/DenoiseImage -d ${DIMENSION} -i ${ANATOMICAL_IMAGES[0]} -o ${SINGLE_SUBJECT_TEMPLATE}  --verbose 1
+    logCmd DenoiseImage -d ${DIMENSION} -i ${ANATOMICAL_IMAGES[0]} -o ${SINGLE_SUBJECT_TEMPLATE}  --verbose 1
   fi
 
 if [[ ! -f ${BRAIN_TEMPLATE} ]];
@@ -656,7 +656,7 @@ for(( i=0; i < ${NUMBER_OF_MODALITIES}; i++ ))
   do
     TEMPLATE_INPUT_IMAGE="${OUTPUT_DIRECTORY_FOR_SINGLE_SUBJECT_TEMPLATE}initTemplateModality${i}.nii.gz"
 
-    logCmd ${ANTSPATH}/ImageMath 3 ${TEMPLATE_INPUT_IMAGE} PadImage ${ANATOMICAL_IMAGES[$i]} 5
+    logCmd ImageMath 3 ${TEMPLATE_INPUT_IMAGE} PadImage ${ANATOMICAL_IMAGES[$i]} 5
 
     TEMPLATE_Z_IMAGES="${TEMPLATE_Z_IMAGES} -z ${TEMPLATE_INPUT_IMAGE}"
   done
@@ -671,7 +671,7 @@ if [[ ! -f $SINGLE_SUBJECT_TEMPLATE ]];
 
     if [[ $RUN_OLD_ANTS_SST_CREATION -gt 0 ]];
       then
-        logCmd ${ANTSPATH}/antsMultivariateTemplateConstruction.sh \
+        logCmd antsMultivariateTemplateConstruction.sh \
           -d ${DIMENSION} \
           -o ${OUTPUT_DIRECTORY_FOR_SINGLE_SUBJECT_TEMPLATE}T_ \
           -b 0 \
@@ -690,7 +690,7 @@ if [[ ! -f $SINGLE_SUBJECT_TEMPLATE ]];
           ${TEMPLATE_Z_IMAGES} \
           ${ANATOMICAL_IMAGES[@]}
     else
-       logCmd ${ANTSPATH}/antsMultivariateTemplateConstruction2.sh \
+       logCmd antsMultivariateTemplateConstruction2.sh \
          -d ${DIMENSION} \
          -o ${OUTPUT_DIRECTORY_FOR_SINGLE_SUBJECT_TEMPLATE}T_ \
          -a 0 \
@@ -803,7 +803,7 @@ if [[ ! -f ${SINGLE_SUBJECT_TEMPLATE_CORTICAL_THICKNESS} ]];
   then
     if [[ $DO_REGISTRATION_TO_TEMPLATE -eq 0 ]];
       then
-        logCmd ${ANTSPATH}/antsCorticalThickness.sh \
+        logCmd antsCorticalThickness.sh \
           -d ${DIMENSION} -x ${ATROPOS_SEGMENTATION_INTERNAL_ITERATIONS} \
           -q ${RUN_FAST_ANTSCT_TO_GROUP_TEMPLATE} \
           -a ${SINGLE_SUBJECT_TEMPLATE} \
@@ -817,7 +817,7 @@ if [[ ! -f ${SINGLE_SUBJECT_TEMPLATE_CORTICAL_THICKNESS} ]];
           -w ${ATROPOS_SEGMENTATION_PRIOR_WEIGHT_SST} \
           -o ${SINGLE_SUBJECT_ANTSCT_PREFIX}
       else
-        logCmd ${ANTSPATH}/antsCorticalThickness.sh \
+        logCmd antsCorticalThickness.sh \
           -d ${DIMENSION} -x ${ATROPOS_SEGMENTATION_INTERNAL_ITERATIONS}  \
           -t ${REGISTRATION_TEMPLATE} \
           -q ${RUN_FAST_ANTSCT_TO_GROUP_TEMPLATE} \
@@ -865,9 +865,9 @@ if [[ ${SINGLE_SUBJECT_TEMPLATE_POSTERIORS_EXIST} -eq 0 ]];
     exit 1
   fi
 
-logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${SINGLE_SUBJECT_TEMPLATE_SKULL_STRIPPED} m ${SINGLE_SUBJECT_TEMPLATE} ${SINGLE_SUBJECT_TEMPLATE_EXTRACTION_MASK}
-logCmd ${ANTSPATH}/SmoothImage ${DIMENSION} ${SINGLE_SUBJECT_TEMPLATE_EXTRACTION_MASK} 1 ${SINGLE_SUBJECT_TEMPLATE_EXTRACTION_PRIOR} 1
-logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${SINGLE_SUBJECT_TEMPLATE_EXTRACTION_REGISTRATION_MASK} MD ${SINGLE_SUBJECT_TEMPLATE_EXTRACTION_MASK} 40
+logCmd ImageMath ${DIMENSION} ${SINGLE_SUBJECT_TEMPLATE_SKULL_STRIPPED} m ${SINGLE_SUBJECT_TEMPLATE} ${SINGLE_SUBJECT_TEMPLATE_EXTRACTION_MASK}
+logCmd SmoothImage ${DIMENSION} ${SINGLE_SUBJECT_TEMPLATE_EXTRACTION_MASK} 1 ${SINGLE_SUBJECT_TEMPLATE_EXTRACTION_PRIOR} 1
+logCmd ImageMath ${DIMENSION} ${SINGLE_SUBJECT_TEMPLATE_EXTRACTION_REGISTRATION_MASK} MD ${SINGLE_SUBJECT_TEMPLATE_EXTRACTION_MASK} 40
 
 if [[ ${SINGLE_SUBJECT_TEMPLATE_PRIORS_EXIST} -eq 0 ]];
   then
@@ -881,7 +881,7 @@ if [[ ${SINGLE_SUBJECT_TEMPLATE_PRIORS_EXIST} -eq 0 ]];
         for j in ${SINGLE_SUBJECT_TEMPLATE_POSTERIORS[@]}
           do
             PRIOR=${j/BrainSegmentationPosteriors/Priors}
-            logCmd ${ANTSPATH}/SmoothImage ${DIMENSION} $j 1 $PRIOR 1
+            logCmd SmoothImage ${DIMENSION} $j 1 $PRIOR 1
           done
 
       else
@@ -901,7 +901,7 @@ if [[ ${SINGLE_SUBJECT_TEMPLATE_PRIORS_EXIST} -eq 0 ]];
 
         if [[ ! -f ${SINGLE_SUBJECT_TEMPLATE_MALF_LABELS} ]];
           then
-            logCmd ${ANTSPATH}/antsJointLabelFusion.sh \
+            logCmd antsJointLabelFusion.sh \
               -d ${DIMENSION} \
               -q ${RUN_FAST_MALF_COOKING} \
               -x ${SINGLE_SUBJECT_TEMPLATE_EXTRACTION_MASK} \
@@ -920,21 +920,21 @@ if [[ ${SINGLE_SUBJECT_TEMPLATE_PRIORS_EXIST} -eq 0 ]];
             SINGLE_SUBJECT_TEMPLATE_PRIORS[$j]=${POSTERIOR/BrainSegmentationPosteriors/Priors}
 
             let PRIOR_LABEL=$j+1
-            logCmd ${ANTSPATH}/ThresholdImage ${DIMENSION} ${SINGLE_SUBJECT_TEMPLATE_MALF_LABELS} ${SINGLE_SUBJECT_TEMPLATE_PRIORS[$j]} ${PRIOR_LABEL} ${PRIOR_LABEL} 1 0
-            logCmd ${ANTSPATH}/SmoothImage ${DIMENSION} ${SINGLE_SUBJECT_TEMPLATE_PRIORS[$j]} 1 ${SINGLE_SUBJECT_TEMPLATE_PRIORS[$j]} 1
+            logCmd ThresholdImage ${DIMENSION} ${SINGLE_SUBJECT_TEMPLATE_MALF_LABELS} ${SINGLE_SUBJECT_TEMPLATE_PRIORS[$j]} ${PRIOR_LABEL} ${PRIOR_LABEL} 1 0
+            logCmd SmoothImage ${DIMENSION} ${SINGLE_SUBJECT_TEMPLATE_PRIORS[$j]} 1 ${SINGLE_SUBJECT_TEMPLATE_PRIORS[$j]} 1
           done
 
         TMP_CSF_POSTERIOR=${SINGLE_SUBJECT_ANTSCT_PREFIX}BrainSegmentationCsfPosteriorTmp.${OUTPUT_SUFFIX}
-        logCmd ${ANTSPATH}/SmoothImage ${DIMENSION} ${SINGLE_SUBJECT_TEMPLATE_POSTERIORS[0]} 1 ${TMP_CSF_POSTERIOR} 1
-        logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${SINGLE_SUBJECT_TEMPLATE_PRIORS[0]} max ${SINGLE_SUBJECT_TEMPLATE_PRIORS[0]} ${TMP_CSF_POSTERIOR}
+        logCmd SmoothImage ${DIMENSION} ${SINGLE_SUBJECT_TEMPLATE_POSTERIORS[0]} 1 ${TMP_CSF_POSTERIOR} 1
+        logCmd ImageMath ${DIMENSION} ${SINGLE_SUBJECT_TEMPLATE_PRIORS[0]} max ${SINGLE_SUBJECT_TEMPLATE_PRIORS[0]} ${TMP_CSF_POSTERIOR}
 
         # Brian's finishing touches on "cooking"---subtract out CSF from all other priors
         for (( j = 1; j < ${#SINGLE_SUBJECT_TEMPLATE_PRIORS[@]}; j++ ))
           do
             let PRIOR_LABEL=$j+1
 
-            logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${SINGLE_SUBJECT_TEMPLATE_PRIORS[$j]} - ${SINGLE_SUBJECT_TEMPLATE_PRIORS[$j]} ${SINGLE_SUBJECT_TEMPLATE_PRIORS[0]}
-            logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${SINGLE_SUBJECT_TEMPLATE_PRIORS[$j]} WindowImage ${SINGLE_SUBJECT_TEMPLATE_PRIORS[$j]} 0 1 0 1
+            logCmd ImageMath ${DIMENSION} ${SINGLE_SUBJECT_TEMPLATE_PRIORS[$j]} - ${SINGLE_SUBJECT_TEMPLATE_PRIORS[$j]} ${SINGLE_SUBJECT_TEMPLATE_PRIORS[0]}
+            logCmd ImageMath ${DIMENSION} ${SINGLE_SUBJECT_TEMPLATE_PRIORS[$j]} WindowImage ${SINGLE_SUBJECT_TEMPLATE_PRIORS[$j]} 0 1 0 1
           done
 
         logCmd rm -f $TMP_CSF_POSTERIOR
@@ -992,7 +992,7 @@ for (( i=0; i < ${#ANATOMICAL_IMAGES[@]}; i+=$NUMBER_OF_MODALITIES ))
     SUBJECT_ANATOMICAL_IMAGES=''
     if [[ ${RIGID_ALIGNMENT_TO_SST} -ne 0 ]];
       then
-        logCmd ${ANTSPATH}/antsRegistrationSyN.sh \
+        logCmd antsRegistrationSyN.sh \
           -d ${DIMENSION} \
           -o ${OUTPUT_DIRECTORY_FOR_SINGLE_SUBJECT_CORTICAL_THICKNESS}/${BASENAME_ID}RigidToSST \
           -m ${ANATOMICAL_IMAGES[$i]} \
@@ -1010,7 +1010,7 @@ for (( i=0; i < ${#ANATOMICAL_IMAGES[@]}; i+=$NUMBER_OF_MODALITIES ))
             BASENAME_LOCAL_ID=${BASENAME_LOCAL_ID/\.nii\.gz/}
             BASENAME_LOCAL_ID=${BASENAME_LOCAL_ID/\.nii/}
 
-            logCmd ${ANTSPATH}/antsApplyTransforms \
+            logCmd antsApplyTransforms \
               -d ${DIMENSION} \
               -i ${ANATOMICAL_IMAGES[$j]} \
               -r ${SINGLE_SUBJECT_TEMPLATE} \
@@ -1035,7 +1035,7 @@ for (( i=0; i < ${#ANATOMICAL_IMAGES[@]}; i+=$NUMBER_OF_MODALITIES ))
 
     OUTPUT_LOCAL_PREFIX=${OUTPUT_DIRECTORY_FOR_SINGLE_SUBJECT_CORTICAL_THICKNESS}/${BASENAME_ID}
 
-    logCmd ${ANTSPATH}/antsCorticalThickness.sh \
+    logCmd antsCorticalThickness.sh \
       -d ${DIMENSION} -x ${ATROPOS_SEGMENTATION_INTERNAL_ITERATIONS}  \
       -q ${RUN_ANTSCT_TO_SST_QUICK} \
       ${SUBJECT_ANATOMICAL_IMAGES} \
@@ -1055,7 +1055,7 @@ for (( i=0; i < ${#ANATOMICAL_IMAGES[@]}; i+=$NUMBER_OF_MODALITIES ))
 
         if [[ ! -f ${OUTPUT_LOCAL_PREFIX}SubjectToGroupTemplateWarp.nii.gz ]];
           then
-            logCmd ${ANTSPATH}/antsApplyTransforms \
+            logCmd antsApplyTransforms \
               -d ${DIMENSION} \
               -r ${REGISTRATION_TEMPLATE} \
               -o [ ${OUTPUT_LOCAL_PREFIX}SubjectToGroupTemplateWarp.nii.gz,1 ] \
@@ -1067,7 +1067,7 @@ for (( i=0; i < ${#ANATOMICAL_IMAGES[@]}; i+=$NUMBER_OF_MODALITIES ))
 
         if [[ ! -f ${OUTPUT_LOCAL_PREFIX}GroupTemplateToSubjectWarp.nii.gz ]];
           then
-            logCmd ${ANTSPATH}/antsApplyTransforms \
+            logCmd antsApplyTransforms \
               -d ${DIMENSION} \
               -r ${ANATOMICAL_REFERENCE_IMAGE} \
               -o [ ${OUTPUT_LOCAL_PREFIX}GroupTemplateToSubjectWarp.nii.gz,1 ] \
@@ -1087,7 +1087,7 @@ for (( i=0; i < ${#ANATOMICAL_IMAGES[@]}; i+=$NUMBER_OF_MODALITIES ))
 
             if [[ ! -f ${SUBJECT_CORTICAL_LABELS} ]];
               then
-                logCmd ${ANTSPATH}/antsApplyTransforms \
+                logCmd antsApplyTransforms \
                   -d ${DIMENSION} \
                   -i ${CORTICAL_LABEL_IMAGE} \
                   -r ${ANATOMICAL_REFERENCE_IMAGE} \
@@ -1095,9 +1095,9 @@ for (( i=0; i < ${#ANATOMICAL_IMAGES[@]}; i+=$NUMBER_OF_MODALITIES ))
                   -n MultiLabel \
                   -t ${OUTPUT_LOCAL_PREFIX}GroupTemplateToSubjectWarp.nii.gz
 
-                logCmd ${ANTSPATH}/ThresholdImage ${DIMENSION} ${OUTPUT_LOCAL_PREFIX}BrainSegmentation.${OUTPUT_SUFFIX} ${SUBJECT_TMP} 2 2 1 0
-                logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${SUBJECT_CORTICAL_LABELS} m ${SUBJECT_TMP} ${SUBJECT_CORTICAL_LABELS}
-                logCmd ${ANTSPATH}/ImageMath ${DIMENSION} ${SUBJECT_STATS} LabelStats ${SUBJECT_CORTICAL_LABELS} ${SUBJECT_CORTICAL_THICKNESS}
+                logCmd ThresholdImage ${DIMENSION} ${OUTPUT_LOCAL_PREFIX}BrainSegmentation.${OUTPUT_SUFFIX} ${SUBJECT_TMP} 2 2 1 0
+                logCmd ImageMath ${DIMENSION} ${SUBJECT_CORTICAL_LABELS} m ${SUBJECT_TMP} ${SUBJECT_CORTICAL_LABELS}
+                logCmd ImageMath ${DIMENSION} ${SUBJECT_STATS} LabelStats ${SUBJECT_CORTICAL_LABELS} ${SUBJECT_CORTICAL_THICKNESS}
               fi
 
             logCmd rm -f $SUBJECT_TMP
diff --git a/Scripts/antsLongitudinalJointLabelFusion.sh b/Scripts/antsLongitudinalJointLabelFusion.sh
index 4f6c4e0d..02599c43 100755
--- a/Scripts/antsLongitudinalJointLabelFusion.sh
+++ b/Scripts/antsLongitudinalJointLabelFusion.sh
@@ -5,50 +5,21 @@ VERSION="0.0.0"
 # trap keyboard interrupt (control-c)
 trap control_c SIGINT
 
-function setPath {
-    cat <<SETPATH
-
---------------------------------------------------------------------------------------
-Error locating ANTS
---------------------------------------------------------------------------------------
-It seems that the ANTSPATH environment variable is not set. Please add the ANTSPATH
-variable. This can be achieved by editing the .bash_profile in the home directory.
-Add:
-
-ANTSPATH=/home/yourname/bin/ants/
-
-Or the correct location of the ANTS binaries.
-
-Alternatively, edit this script ( `basename $0` ) to set up this parameter correctly.
-
-SETPATH
-    exit 1
-}
-
-# Uncomment the line below in case you have not set the ANTSPATH variable in your environment.
-# export ANTSPATH=${ANTSPATH:="$HOME/bin/ants/"} # EDIT THIS
-
-#ANTSPATH=YOURANTSPATH
-if [[ ${#ANTSPATH} -le 3 ]];
-  then
-    setPath >&2
-  fi
-
 # Test availability of helper scripts.
 # No need to test this more than once. Can reside outside of the main loop.
-ANTS=${ANTSPATH}/antsRegistration
-WARP=${ANTSPATH}/antsApplyTransforms
-JLF=${ANTSPATH}/antsJointFusion
-PEXEC=${ANTSPATH}/ANTSpexec.sh
-SGE=${ANTSPATH}/waitForSGEQJobs.pl
-PBS=${ANTSPATH}/waitForPBSQJobs.pl
-XGRID=${ANTSPATH}/waitForXGridJobs.pl
-SLURM=${ANTSPATH}/waitForSlurmJobs.pl
+ANTS=antsRegistration
+WARP=antsApplyTransforms
+JLF=antsJointFusion
+PEXEC=ANTSpexec.sh
+SGE=waitForSGEQJobs.pl
+PBS=waitForPBSQJobs.pl
+XGRID=waitForXGridJobs.pl
+SLURM=waitForSlurmJobs.pl
 
 fle_error=0
 for FLE in $JLF $ANTS $WARP $PEXEC $SGE $XGRID $PBS $SLURM
   do
-  if [[ ! -x $FLE ]];
+  if ! command -v $FLE &> /dev/null
     then
       echo
       echo "--------------------------------------------------------------------------------------"
@@ -250,7 +221,7 @@ Optional arguments:
 
 Requirements:
 
-This scripts relies on the following scripts in your $ANTSPATH directory. The script
+This scripts relies on the following scripts in your $PATH. The script
 will terminate prematurely if these files are not present or are not executable.
 - pexec.sh
 - waitForSGEQJobs.pl (only for use with Sun Grid Engine)
@@ -297,8 +268,6 @@ function reportParameters {
 --------------------------------------------------------------------------------------
  Parameters
 --------------------------------------------------------------------------------------
- ANTSPATH is $ANTSPATH
-
  Dimensionality:           $DIM
  Output prefix:            $OUTPUT_PREFIX
  Posteriors format:        $OUTPUT_POSTERIORS_FORMAT
@@ -560,10 +529,10 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
         continue
       fi
 
-    regcall=${ANTSPATH}/antsRegistrationSyN.sh
+    regcall=antsRegistrationSyN.sh
     if [[ $RUNQUICK -eq 1 ]];
       then
-        regcall=${ANTSPATH}/antsRegistrationSyNQuick.sh
+        regcall=antsRegistrationSyNQuick.sh
       fi
     registrationCall="$regcall \
                           -d ${DIM} \
@@ -574,7 +543,7 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
                           -m ${ATLAS_IMAGES[$i]} \
                           -o ${OUTPUT_PREFIX}${BASENAME}_${i}_ > ${OUTPUT_PREFIX}${BASENAME}_${i}_log.txt"
 
-    labelXfrmCall="${ANTSPATH}/antsApplyTransforms \
+    labelXfrmCall="antsApplyTransforms \
                           -d ${DIM} \
                           --float 1 \
                           -i ${ATLAS_LABELS[$i]} \
@@ -584,12 +553,12 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
                           -t ${OUTPUT_PREFIX}${BASENAME}_${i}_1Warp.nii.gz \
                           -t ${OUTPUT_PREFIX}${BASENAME}_${i}_0GenericAffine.mat >> ${OUTPUT_PREFIX}${BASENAME}_${i}_log.txt"
 
-    copyImageHeaderCall="${ANTSPATH}/CopyImageHeaderInformation \
+    copyImageHeaderCall="CopyImageHeaderInformation \
                          ${TARGET_IMAGE} \
                          ${OUTPUT_PREFIX}${BASENAME}_${i}_Warped.nii.gz \
                          ${OUTPUT_PREFIX}${BASENAME}_${i}_Warped.nii.gz 1 1 1"
 
-    copyLabelsHeaderCall="${ANTSPATH}/CopyImageHeaderInformation \
+    copyLabelsHeaderCall="CopyImageHeaderInformation \
                           ${TARGET_IMAGE} \
                           ${OUTPUT_PREFIX}${BASENAME}_${i}_WarpedLabels.nii.gz \
                           ${OUTPUT_PREFIX}${BASENAME}_${i}_WarpedLabels.nii.gz 1 1 1"
@@ -609,12 +578,12 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
 
     if [[ $DOQSUB -eq 1 ]];
       then
-        id=`qsub -cwd -S /bin/bash -N antsJlfReg -v ANTSPATH=$ANTSPATH $QSUB_OPTS $qscript | awk '{print $3}'`
+        id=`qsub -cwd -S /bin/bash -N antsJlfReg  $QSUB_OPTS $qscript | awk '{print $3}'`
         jobIDs="$jobIDs $id"
         sleep 0.5
     elif [[ $DOQSUB -eq 4 ]];
       then
-        id=`qsub -N antsJlfReg -v ANTSPATH=$ANTSPATH $QSUB_OPTS -q nopreempt -l nodes=1:ppn=1 -l mem=${REGISTRATION_MEMORY} -l walltime=${REGISTRATION_WALLTIME} $qscript | awk '{print $1}'`
+        id=`qsub -N antsJlfReg  $QSUB_OPTS -q nopreempt -l nodes=1:ppn=1 -l mem=${REGISTRATION_MEMORY} -l walltime=${REGISTRATION_WALLTIME} $qscript | awk '{print $1}'`
         jobIDs="$jobIDs $id"
         sleep 0.5
     elif [[ $DOQSUB -eq 3 ]];
@@ -623,7 +592,7 @@ for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
         jobIDs="$jobIDs $id"
     elif [[ $DOQSUB -eq 5 ]];
       then
-        id=`sbatch --job-name=antsJlfReg${i} --export=ANTSPATH=$ANTSPATH $QSUB_OPTS --nodes=1 --cpus-per-task=1 --time=${REGISTRATION_WALLTIME} --mem=${REGISTRATION_MEMORY} $qscript | rev | cut -f1 -d\ | rev`
+        id=`sbatch --job-name=antsJlfReg${i}  $QSUB_OPTS --nodes=1 --cpus-per-task=1 --time=${REGISTRATION_WALLTIME} --mem=${REGISTRATION_MEMORY} $qscript | rev | cut -f1 -d\ | rev`
         jobIDs="$jobIDs $id"
         sleep 0.5
     elif [[ $DOQSUB -eq 0 ]];
@@ -643,7 +612,7 @@ if [[ $DOQSUB -eq 2 ]];
     $PEXEC -j ${CORES} "sh" ${OUTPUT_DIR}/job_*.sh
   fi
 
-jlfCall="${ANTSPATH}/antsJointFusion -d ${DIM} -t $TARGET_IMAGE --verbose 1 "
+jlfCall="antsJointFusion -d ${DIM} -t $TARGET_IMAGE --verbose 1 "
 
 if [[ $DOQSUB -eq 0 ]];
   then
@@ -680,7 +649,7 @@ if [[ $DOQSUB -eq 0 ]];
 
     if [[ $MAJORITYVOTE -eq 1 ]];
       then
-        jlfCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
+        jlfCall="ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
       else
 
         for (( i = 0; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
@@ -698,19 +667,19 @@ if [[ $DOQSUB -eq 0 ]];
         if [[ ${TARGET_MASK_IMAGE} == 'otsu' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOtsu.nii.gz"
-            maskCall="${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
+            maskCall="ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
         elif [[ ${TARGET_MASK_IMAGE} == 'or' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOr.nii.gz"
 
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_IMAGES[0]} ${EXISTING_WARPED_ATLAS_IMAGES[1]};"
+            maskCall="ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_IMAGES[0]} ${EXISTING_WARPED_ATLAS_IMAGES[1]};"
             for (( i = 2; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
               do
-                maskCall="${maskCall} ${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_IMAGES[$i]};"
+                maskCall="${maskCall} ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_IMAGES[$i]};"
               done
-            maskCall="${maskCall} ${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
+            maskCall="${maskCall} ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
         elif [[ -f ${TARGET_MASK_IMAGE} ]];
@@ -768,14 +737,14 @@ if [[ $DOQSUB -eq 0 ]];
             exit 1
           fi
 
-        jlfTimeCall="${ANTSPATH}/antsJointFusion -d ${DIM} -t $tImg -x $tMask -o [ ${OUTPUT_PREFIX}${j}_Labels.nii.gz,${OUTPUT_PREFIX}${j}_Intensity.nii.gz ] --verbose 1 "
+        jlfTimeCall="antsJointFusion -d ${DIM} -t $tImg -x $tMask -o [ ${OUTPUT_PREFIX}${j}_Labels.nii.gz,${OUTPUT_PREFIX}${j}_Intensity.nii.gz ] --verbose 1 "
 
         for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
           do
             IMG_BASE=`basename ${ATLAS_IMAGES[$i]}`
             BASENAME=` echo ${IMG_BASE} | cut -d '.' -f 1 `
 
-            labelXfrmCall="${ANTSPATH}/antsApplyTransforms \
+            labelXfrmCall="antsApplyTransforms \
                                   -d ${DIM} \
                                   --float 1 \
                                   -i ${ATLAS_LABELS[$i]} \
@@ -787,7 +756,7 @@ if [[ $DOQSUB -eq 0 ]];
                                   -t ${OUTPUT_PREFIX}${BASENAME}_${i}_1Warp.nii.gz \
                                   -t ${OUTPUT_PREFIX}${BASENAME}_${i}_0GenericAffine.mat >> ${OUTPUT_PREFIX}${BASENAME}_time_${j}_log.txt"
 
-            imageXfrmCall="${ANTSPATH}/antsApplyTransforms \
+            imageXfrmCall="antsApplyTransforms \
                                   -d ${DIM} \
                                   --float 1 \
                                   -i ${ATLAS_IMAGES[$i]} \
@@ -798,12 +767,12 @@ if [[ $DOQSUB -eq 0 ]];
                                   -t ${OUTPUT_PREFIX}${BASENAME}_${i}_1Warp.nii.gz \
                                   -t ${OUTPUT_PREFIX}${BASENAME}_${i}_0GenericAffine.mat >> ${OUTPUT_PREFIX}${BASENAME}_time_${j}_log.txt"
 
-            copyImageHeaderCall="${ANTSPATH}/CopyImageHeaderInformation \
+            copyImageHeaderCall="CopyImageHeaderInformation \
                                  ${tImg} \
                                  ${OUTPUT_PREFIX}${BASENAME}_${i}_${j}_Warped.nii.gz \
                                  ${OUTPUT_PREFIX}${BASENAME}_${i}_${j}_Warped.nii.gz 1 1 1"
 
-            copyLabelsHeaderCall="${ANTSPATH}/CopyImageHeaderInformation \
+            copyLabelsHeaderCall="CopyImageHeaderInformation \
                                   ${tImg} \
                                   ${OUTPUT_PREFIX}${BASENAME}_${i}_${j}_WarpedLabels.nii.gz \
                                   ${OUTPUT_PREFIX}${BASENAME}_${i}_${j}_WarpedLabels.nii.gz 1 1 1"
@@ -837,7 +806,7 @@ if [[ $DOQSUB -eq 1 ]];
     echo " Starting JLF on SGE cluster. "
     echo "--------------------------------------------------------------------------------------"
 
-    ${ANTSPATH}/waitForSGEQJobs.pl 1 600 $jobIDs
+    waitForSGEQJobs.pl 1 600 $jobIDs
 
     # Returns 1 if there are errors
     if [[ ! $? -eq 0 ]];
@@ -872,7 +841,7 @@ if [[ $DOQSUB -eq 1 ]];
 
     if [[ $MAJORITYVOTE -eq 1 ]];
       then
-        jlfCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
+        jlfCall="ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
       else
 
         for (( i = 0; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
@@ -890,19 +859,19 @@ if [[ $DOQSUB -eq 1 ]];
         if [[ ${TARGET_MASK_IMAGE} == 'otsu' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOtsu.nii.gz"
-            maskCall="${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
+            maskCall="ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
         elif [[ ${TARGET_MASK_IMAGE} == 'or' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOr.nii.gz"
 
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_IMAGES[0]} ${EXISTING_WARPED_ATLAS_IMAGES[1]};"
+            maskCall="ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_IMAGES[0]} ${EXISTING_WARPED_ATLAS_IMAGES[1]};"
             for (( i = 2; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
               do
-                maskCall="${maskCall} ${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_IMAGES[$i]};"
+                maskCall="${maskCall} ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_IMAGES[$i]};"
               done
-            maskCall="${maskCall} ${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
+            maskCall="${maskCall} ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
         elif [[ -f ${TARGET_MASK_IMAGE} ]];
@@ -916,7 +885,7 @@ if [[ $DOQSUB -eq 1 ]];
     echo "$maskCall" > $qscript2
     echo "$jlfCall" >> $qscript2
 
-    jobIDs=`qsub -cwd -S /bin/bash -N antsJlf -v ANTSPATH=$ANTSPATH $QSUB_OPTS $qscript2 | awk '{print $3}'`
+    jobIDs=`qsub -cwd -S /bin/bash -N antsJlf  $QSUB_OPTS $qscript2 | awk '{print $3}'`
 
     for (( j = 0; j < ${#TIME_DIRECTORIES[@]}; j++ ))
       do
@@ -945,14 +914,14 @@ if [[ $DOQSUB -eq 1 ]];
           exit 1
         fi
 
-        jlfTimeCall="${ANTSPATH}/antsJointFusion -d ${DIM} -t $tImg -x $tMask --verbose 1 "
+        jlfTimeCall="antsJointFusion -d ${DIM} -t $tImg -x $tMask --verbose 1 "
 
         for (( i = 0; i < ${#ATLAS_IMAGES[@]}; i++ ))
           do
             IMG_BASE=`basename ${ATLAS_IMAGES[$i]}`
             BASENAME=` echo ${IMG_BASE} | cut -d '.' -f 1 `
 
-            labelXfrmCall="${ANTSPATH}/antsApplyTransforms \
+            labelXfrmCall="antsApplyTransforms \
                                   -d ${DIM} \
                                   --float 1 \
                                   -i ${ATLAS_LABELS[$i]} \
@@ -964,7 +933,7 @@ if [[ $DOQSUB -eq 1 ]];
                                   -t ${OUTPUT_PREFIX}${BASENAME}_${i}_1Warp.nii.gz \
                                   -t ${OUTPUT_PREFIX}${BASENAME}_${i}_0GenericAffine.mat >> ${OUTPUT_PREFIX}${BASENAME}_${i}_log.txt"
 
-            imageXfrmCall="${ANTSPATH}/antsApplyTransforms \
+            imageXfrmCall="antsApplyTransforms \
                                   -d ${DIM} \
                                   --float 1 \
                                   -i ${ATLAS_IMAGES[$i]} \
@@ -976,12 +945,12 @@ if [[ $DOQSUB -eq 1 ]];
                                   -t ${OUTPUT_PREFIX}${BASENAME}_${i}_1Warp.nii.gz \
                                   -t ${OUTPUT_PREFIX}${BASENAME}_${i}_0GenericAffine.mat >> ${OUTPUT_PREFIX}${BASENAME}_${i}_log.txt"
 
-            copyImageHeaderCall="${ANTSPATH}/CopyImageHeaderInformation \
+            copyImageHeaderCall="CopyImageHeaderInformation \
                                  ${tImg} \
                                  ${OUTPUT_PREFIX}${BASENAME}_${i}_${j}_Warped.nii.gz \
                                  ${OUTPUT_PREFIX}${BASENAME}_${i}_${j}_Warped.nii.gz 1 1 1"
 
-            copyLabelsHeaderCall="${ANTSPATH}/CopyImageHeaderInformation \
+            copyLabelsHeaderCall="CopyImageHeaderInformation \
                                   ${tImg} \
                                   ${OUTPUT_PREFIX}${BASENAME}_${i}_${j}_WarpedLabels.nii.gz \
                                   ${OUTPUT_PREFIX}${BASENAME}_${i}_${j}_WarpedLabels.nii.gz 1 1 1"
@@ -995,12 +964,12 @@ if [[ $DOQSUB -eq 1 ]];
           done
 
           echo "$jlfTimeCall" >> $qscript3
-          jobTimeIDs=`qsub -cwd -S /bin/bash -N timeJlf -v ANTSPATH=$ANTSPATH $QSUB_OPTS $qscript3 | awk '{print $3}'`
+          jobTimeIDs=`qsub -cwd -S /bin/bash -N timeJlf  $QSUB_OPTS $qscript3 | awk '{print $3}'`
           jobIDs="$jobIDs $jobTimeIDs"
 
       done
 
-    ${ANTSPATH}/waitForSGEQJobs.pl 1 600 $jobTimeIDs
+    waitForSGEQJobs.pl 1 600 $jobTimeIDs
   fi
 if [[ $DOQSUB -eq 4 ]];
   then
@@ -1010,7 +979,7 @@ if [[ $DOQSUB -eq 4 ]];
     echo " Starting JLF on PBS cluster. "
     echo "--------------------------------------------------------------------------------------"
 
-    ${ANTSPATH}/waitForPBSQJobs.pl 1 600 $jobIDs
+    waitForPBSQJobs.pl 1 600 $jobIDs
     # Returns 1 if there are errors
     if [[ ! $? -eq 0 ]];
       then
@@ -1044,7 +1013,7 @@ if [[ $DOQSUB -eq 4 ]];
 
     if [[ $MAJORITYVOTE -eq 1 ]];
       then
-        jlfCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
+        jlfCall="ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
       else
 
         for (( i = 0; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
@@ -1062,19 +1031,19 @@ if [[ $DOQSUB -eq 4 ]];
         if [[ ${TARGET_MASK_IMAGE} == 'otsu' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOtsu.nii.gz"
-            maskCall="${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
+            maskCall="ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
         elif [[ ${TARGET_MASK_IMAGE} == 'or' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOr.nii.gz"
 
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_IMAGES[0]} ${EXISTING_WARPED_ATLAS_IMAGES[1]};"
+            maskCall="ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_IMAGES[0]} ${EXISTING_WARPED_ATLAS_IMAGES[1]};"
             for (( i = 2; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
               do
-                maskCall="${maskCall} ${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_IMAGES[$i]};"
+                maskCall="${maskCall} ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_IMAGES[$i]};"
               done
-            maskCall="${maskCall} ${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
+            maskCall="${maskCall} ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
         elif [[ -f ${TARGET_MASK_IMAGE} ]];
@@ -1088,8 +1057,8 @@ if [[ $DOQSUB -eq 4 ]];
     echo "$maskCall" > $qscript2
     echo "$jlfCall" >> $qscript2
 
-    jobIDs=`qsub -N antsJlf -v ANTSPATH=$ANTSPATH $QSUB_OPTS -q nopreempt -l nodes=1:ppn=1 -l mem=${JLF_MEMORY} -l walltime=${JLF_WALLTIME} $qscript2 | awk '{print $1}'`
-    ${ANTSPATH}/waitForPBSQJobs.pl 1 600 $jobIDs
+    jobIDs=`qsub -N antsJlf  $QSUB_OPTS -q nopreempt -l nodes=1:ppn=1 -l mem=${JLF_MEMORY} -l walltime=${JLF_WALLTIME} $qscript2 | awk '{print $1}'`
+    waitForPBSQJobs.pl 1 600 $jobIDs
   fi
 
 if [[ $DOQSUB -eq 2 ]];
@@ -1120,7 +1089,7 @@ if [[ $DOQSUB -eq 2 ]];
 
     if [[ $MAJORITYVOTE -eq 1 ]];
       then
-        jlfCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
+        jlfCall="ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
       else
 
         for (( i = 0; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
@@ -1138,19 +1107,19 @@ if [[ $DOQSUB -eq 2 ]];
         if [[ ${TARGET_MASK_IMAGE} == 'otsu' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOtsu.nii.gz"
-            maskCall="${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
+            maskCall="ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
         elif [[ ${TARGET_MASK_IMAGE} == 'or' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOr.nii.gz"
 
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_IMAGES[0]} ${EXISTING_WARPED_ATLAS_IMAGES[1]};"
+            maskCall="ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_IMAGES[0]} ${EXISTING_WARPED_ATLAS_IMAGES[1]};"
             for (( i = 2; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
               do
-                maskCall="${maskCall} ${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_IMAGES[$i]};"
+                maskCall="${maskCall} ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_IMAGES[$i]};"
               done
-            maskCall="${maskCall} ${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
+            maskCall="${maskCall} ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
         elif [[ -f ${TARGET_MASK_IMAGE} ]];
@@ -1174,7 +1143,7 @@ if [[ $DOQSUB -eq 3 ]];
     echo " Starting JLF on XGrid cluster. Submitted $count jobs "
     echo "--------------------------------------------------------------------------------------"
 
-    ${ANTSPATH}/waitForXGridJobs.pl -xgridflags "$XGRID_OPTS" -verbose -delay 30 $jobIDs
+    waitForXGridJobs.pl -xgridflags "$XGRID_OPTS" -verbose -delay 30 $jobIDs
     # Returns 1 if there are errors
     if [[ ! $? -eq 0 ]];
       then
@@ -1208,7 +1177,7 @@ if [[ $DOQSUB -eq 3 ]];
 
     if [[ $MAJORITYVOTE -eq 1 ]];
       then
-        jlfCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
+        jlfCall="ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
       else
 
         for (( i = 0; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
@@ -1226,19 +1195,19 @@ if [[ $DOQSUB -eq 3 ]];
         if [[ ${TARGET_MASK_IMAGE} == 'otsu' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOtsu.nii.gz"
-            maskCall="${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
+            maskCall="ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
         elif [[ ${TARGET_MASK_IMAGE} == 'or' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOr.nii.gz"
 
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_IMAGES[0]} ${EXISTING_WARPED_ATLAS_IMAGES[1]};"
+            maskCall="ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_IMAGES[0]} ${EXISTING_WARPED_ATLAS_IMAGES[1]};"
             for (( i = 2; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
               do
-                maskCall="${maskCall} ${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_IMAGES[$i]};"
+                maskCall="${maskCall} ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_IMAGES[$i]};"
               done
-            maskCall="${maskCall} ${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
+            maskCall="${maskCall} ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
         elif [[ -f ${TARGET_MASK_IMAGE} ]];
@@ -1262,7 +1231,7 @@ if [[ $DOQSUB -eq 5 ]];
     echo " Starting JLF on SLURM cluster. "
     echo "--------------------------------------------------------------------------------------"
 
-    ${ANTSPATH}/waitForSlurmJobs.pl 1 600 $jobIDs
+    waitForSlurmJobs.pl 1 600 $jobIDs
     # Returns 1 if there are errors
     if [[ ! $? -eq 0 ]];
       then
@@ -1299,7 +1268,7 @@ if [[ $DOQSUB -eq 5 ]];
 
     if [[ $MAJORITYVOTE -eq 1 ]];
       then
-        jlfCall="${ANTSPATH}/ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
+        jlfCall="ImageMath ${DIM} ${OUTPUT_PREFIX}MajorityVotingLabels.nii.gz MajorityVoting ${EXISTING_WARPED_ATLAS_LABELS[@]} "
       else
 
         for (( i = 0; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
@@ -1317,19 +1286,19 @@ if [[ $DOQSUB -eq 5 ]];
         if [[ ${TARGET_MASK_IMAGE} == 'otsu' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOtsu.nii.gz"
-            maskCall="${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
+            maskCall="ThresholdImage ${DIM} ${TARGET_IMAGE} ${TARGET_MASK_IMAGE} Otsu 1;"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
         elif [[ ${TARGET_MASK_IMAGE} == 'or' ]];
           then
             TARGET_MASK_IMAGE="${OUTPUT_PREFIX}TargetMaskImageOr.nii.gz"
 
-            maskCall="${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_IMAGES[0]} ${EXISTING_WARPED_ATLAS_IMAGES[1]};"
+            maskCall="ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${EXISTING_WARPED_ATLAS_IMAGES[0]} ${EXISTING_WARPED_ATLAS_IMAGES[1]};"
             for (( i = 2; i < ${#EXISTING_WARPED_ATLAS_IMAGES[@]}; i++ ))
               do
-                maskCall="${maskCall} ${ANTSPATH}/ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_IMAGES[$i]};"
+                maskCall="${maskCall} ImageMath ${DIM} ${TARGET_MASK_IMAGE} max ${TARGET_MASK_IMAGE} ${EXISTING_WARPED_ATLAS_IMAGES[$i]};"
               done
-            maskCall="${maskCall} ${ANTSPATH}/ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
+            maskCall="${maskCall} ThresholdImage ${DIM} ${TARGET_MASK_IMAGE} ${TARGET_MASK_IMAGE} 0 0 0 1"
 
             jlfCall="${jlfCall} -x ${TARGET_MASK_IMAGE}"
         elif [[ -f ${TARGET_MASK_IMAGE} ]];
@@ -1344,8 +1313,8 @@ if [[ $DOQSUB -eq 5 ]];
     echo "$maskCall" >> $qscript2
     echo "$jlfCall" >> $qscript2
 
-    jobIDs=`sbatch --job-name=antsJlf --export=ANTSPATH=$ANTSPATH $QSUB_OPTS --nodes=1 --cpus-per-task=1 --time=${JLF_WALLTIME} --mem=${JLF_MEMORY} $qscript2 | rev | cut -f1 -d\ | rev`
-    ${ANTSPATH}/waitForSlurmJobs.pl 1 600 $jobIDs
+    jobIDs=`sbatch --job-name=antsJlf  $QSUB_OPTS --nodes=1 --cpus-per-task=1 --time=${JLF_WALLTIME} --mem=${JLF_MEMORY} $qscript2 | rev | cut -f1 -d\ | rev`
+    waitForSlurmJobs.pl 1 600 $jobIDs
   fi
 
 # clean up
diff --git a/Scripts/antsMultivariateTemplateConstruction.sh b/Scripts/antsMultivariateTemplateConstruction.sh
index 36458d9e..f069b429 100755
--- a/Scripts/antsMultivariateTemplateConstruction.sh
+++ b/Scripts/antsMultivariateTemplateConstruction.sh
@@ -5,49 +5,21 @@ VERSION="0.0.0"
 # trap keyboard interrupt (control-c)
 trap control_c SIGINT
 
-function setPath {
-    cat <<SETPATH
-
---------------------------------------------------------------------------------------
-Error locating ANTS
---------------------------------------------------------------------------------------
-It seems that the ANTSPATH environment variable is not set. Please add the ANTSPATH
-variable. This can be achieved by editing the .bash_profile in the home directory.
-Add:
-
-ANTSPATH=/home/yourname/bin/ants/
-
-Or the correct location of the ANTS binaries.
-
-Alternatively, edit this script ( `basename $0` ) to set up this parameter correctly.
-
-SETPATH
-    exit 1
-}
-
-# Uncomment the line below in case you have not set the ANTSPATH variable in your environment.
-# export ANTSPATH=${ANTSPATH:="$HOME/bin/ants/"} # EDIT THIS
-
-if [[ ${#ANTSPATH} -le 3 ]];
-  then
-    setPath >&2
-  fi
-
 # Test availability of helper scripts.
 # No need to test this more than once. Can reside outside of the main loop.
-ANTS=${ANTSPATH}/ANTS
-WARP=${ANTSPATH}/WarpImageMultiTransform
-N4=${ANTSPATH}/N4BiasFieldCorrection
-PEXEC=${ANTSPATH}/ANTSpexec.sh
-SGE=${ANTSPATH}/waitForSGEQJobs.pl
-PBS=${ANTSPATH}/waitForPBSQJobs.pl
-XGRID=${ANTSPATH}/waitForXGridJobs.pl
-SLURM=${ANTSPATH}/waitForSlurmJobs.pl
+ANTS=ANTS
+WARP=WarpImageMultiTransform
+N4=N4BiasFieldCorrection
+PEXEC=ANTSpexec.sh
+SGE=waitForSGEQJobs.pl
+PBS=waitForPBSQJobs.pl
+XGRID=waitForXGridJobs.pl
+SLURM=waitForSlurmJobs.pl
 
 fle_error=0
 for FLE in $ANTS $WARP $N4 $PEXEC $SGE $XGRID $PBS $SLURM
   do
-    if [[ ! -x $FLE ]];
+    if ! command -v $FLE &> /dev/null
       then
         echo
         echo "--------------------------------------------------------------------------------------"
@@ -233,8 +205,6 @@ function reportMappingParameters {
 --------------------------------------------------------------------------------------
  Mapping parameters
 --------------------------------------------------------------------------------------
- ANTSPATH is $ANTSPATH
-
  Dimensionality:                    $DIM
  N4BiasFieldCorrection:             $N4CORRECT
  Similarity Metric:                 $METRICTYPE
@@ -277,10 +247,10 @@ function summarizeimageset() {
 
   case $summarizemethod in
     0) #mean
-      ${ANTSPATH}/AverageImages $dim $output 0 ${images[@]}
+      AverageImages $dim $output 0 ${images[@]}
       ;;
     1) #mean of normalized images
-      ${ANTSPATH}/AverageImages $dim $output 2 ${images[@]}
+      AverageImages $dim $output 2 ${images[@]}
       ;;
     2) #median
       local image
@@ -288,7 +258,7 @@ function summarizeimageset() {
         do
           echo $image >> ${output}_list.txt
         done
-      ${ANTSPATH}/ImageSetStatistics $dim ${output}_list.txt ${output} 0
+      ImageSetStatistics $dim ${output}_list.txt ${output} 0
       rm ${output}_list.txt
       ;;
   esac
@@ -305,11 +275,11 @@ function summarizeimageset() {
       ;;
     1)
       echo "Laplacian sharpening"
-      ${ANTSPATH}/ImageMath $dim $output Sharpen $output
+      ImageMath $dim $output Sharpen $output
       ;;
     2)
       echo "Unsharp mask sharpening"
-      ${ANTSPATH}/ImageMath $dim $output UnsharpMask $output 0.5 1 0 0
+      ImageMath $dim $output UnsharpMask $output 0.5 1 0 0
       ;;
   esac
 
@@ -368,38 +338,38 @@ function shapeupdatetotemplate() {
         echo
         echo "--------------------------------------------------------------------------------------"
         echo " shapeupdatetotemplate---voxel-wise averaging of the inverse warp fields (from subject to template)"
-        echo "   ${ANTSPATH}/AverageImages $dim ${templatename}${whichtemplate}warp.nii.gz 0 `ls ${outputname}*Warp.nii.gz | grep -v "InverseWarp"`"
+        echo "   AverageImages $dim ${templatename}${whichtemplate}warp.nii.gz 0 `ls ${outputname}*Warp.nii.gz | grep -v "InverseWarp"`"
         echo "--------------------------------------------------------------------------------------"
 
-        ${ANTSPATH}/AverageImages $dim ${templatename}${whichtemplate}warp.nii.gz 0 `ls ${outputname}*Warp.nii.gz | grep -v "InverseWarp"`
+        AverageImages $dim ${templatename}${whichtemplate}warp.nii.gz 0 `ls ${outputname}*Warp.nii.gz | grep -v "InverseWarp"`
 
         echo
         echo "--------------------------------------------------------------------------------------"
         echo " shapeupdatetotemplate---scale the averaged inverse warp field by the gradient step"
-        echo "   ${ANTSPATH}/MultiplyImages $dim ${templatename}${whichtemplate}warp.nii.gz ${gradientstep} ${templatename}${whichtemplate}warp.nii.gz"
+        echo "   MultiplyImages $dim ${templatename}${whichtemplate}warp.nii.gz ${gradientstep} ${templatename}${whichtemplate}warp.nii.gz"
         echo "--------------------------------------------------------------------------------------"
 
-        ${ANTSPATH}/MultiplyImages $dim ${templatename}${whichtemplate}warp.nii.gz ${gradientstep} ${templatename}${whichtemplate}warp.nii.gz
+        MultiplyImages $dim ${templatename}${whichtemplate}warp.nii.gz ${gradientstep} ${templatename}${whichtemplate}warp.nii.gz
 
         echo
         echo "--------------------------------------------------------------------------------------"
         echo " shapeupdatetotemplate---average the affine transforms (template <-> subject)"
         echo "                      ---transform the inverse field by the resulting average affine transform"
-        echo "   ${ANTSPATH}/${AVERAGE_AFFINE_PROGRAM} ${dim} ${templatename}0Affine.txt ${outputname}*Affine.txt"
-        echo "   ${ANTSPATH}/WarpImageMultiTransform ${dim} ${templatename}0warp.nii.gz ${templatename}0warp.nii.gz -i  ${templatename}0Affine.txt -R ${template}"
+        echo "   ${AVERAGE_AFFINE_PROGRAM} ${dim} ${templatename}0Affine.txt ${outputname}*Affine.txt"
+        echo "   WarpImageMultiTransform ${dim} ${templatename}0warp.nii.gz ${templatename}0warp.nii.gz -i  ${templatename}0Affine.txt -R ${template}"
         echo "--------------------------------------------------------------------------------------"
 
-        ${ANTSPATH}/${AVERAGE_AFFINE_PROGRAM} ${dim} ${templatename}0Affine.txt ${outputname}*Affine.txt
-        ${ANTSPATH}/WarpImageMultiTransform ${dim} ${templatename}0warp.nii.gz ${templatename}0warp.nii.gz -i  ${templatename}0Affine.txt -R ${template}
+        ${AVERAGE_AFFINE_PROGRAM} ${dim} ${templatename}0Affine.txt ${outputname}*Affine.txt
+        WarpImageMultiTransform ${dim} ${templatename}0warp.nii.gz ${templatename}0warp.nii.gz -i  ${templatename}0Affine.txt -R ${template}
 
-        ${ANTSPATH}/MeasureMinMaxMean ${dim} ${templatename}0warp.nii.gz ${templatename}warplog.txt 1
+        MeasureMinMaxMean ${dim} ${templatename}0warp.nii.gz ${templatename}warplog.txt 1
       fi
 
     echo "--------------------------------------------------------------------------------------"
     echo " shapeupdatetotemplate---warp each template by the resulting transforms"
-    echo "   ${ANTSPATH}/WarpImageMultiTransform ${dim} ${template} ${template} -i ${templatename}0Affine.txt ${templatename}0warp.nii.gz ${templatename}0warp.nii.gz ${templatename}0warp.nii.gz ${templatename}0warp.nii.gz -R ${template}"
+    echo "   WarpImageMultiTransform ${dim} ${template} ${template} -i ${templatename}0Affine.txt ${templatename}0warp.nii.gz ${templatename}0warp.nii.gz ${templatename}0warp.nii.gz ${templatename}0warp.nii.gz -R ${template}"
     echo "--------------------------------------------------------------------------------------"
-    ${ANTSPATH}/WarpImageMultiTransform ${dim} ${template} ${template} -i ${templatename}0Affine.txt ${templatename}0warp.nii.gz ${templatename}0warp.nii.gz ${templatename}0warp.nii.gz ${templatename}0warp.nii.gz -R ${template}
+    WarpImageMultiTransform ${dim} ${template} ${template} -i ${templatename}0Affine.txt ${templatename}0warp.nii.gz ${templatename}0warp.nii.gz ${templatename}0warp.nii.gz ${templatename}0warp.nii.gz -R ${template}
 }
 
 function jobfnamepadding {
@@ -766,7 +736,7 @@ if [[ ${NINFILES} -eq 0 ]];
             done
          done < $IMAGESFILE
     else
-        range=`${ANTSPATH}/ImageMath $TDIM abs nvols ${IMAGESETVARIABLE} | tail -1 | cut -d "," -f 4 | cut -d " " -f 2 | cut -d " ]" -f 1 `
+        range=`ImageMath $TDIM abs nvols ${IMAGESETVARIABLE} | tail -1 | cut -d "," -f 4 | cut -d " " -f 2 | cut -d " ]" -f 1 `
         if [[ ${range} -eq 1 && ${TDIM} -ne 4 ]];
             then
             echo "Please provide at least 2 filenames for the template."
@@ -797,7 +767,7 @@ if [[ ${NINFILES} -eq 0 ]];
              #split the 4D file into 3D elements
              cp ${IMAGESETVARIABLE} ${tmpdir}/
              cd ${tmpdir}/
-             # ${ANTSPATH}/ImageMath $TDIM vol0.nii.gz TimeSeriesSubset ${IMAGESETVARIABLE} ${range}
+             # ImageMath $TDIM vol0.nii.gz TimeSeriesSubset ${IMAGESETVARIABLE} ${range}
              # rm -f ${IMAGESETVARIABLE}
 
              # selecting 16 volumes randomly from the timeseries for averaging, placing them in tmp/selection folder.
@@ -833,15 +803,15 @@ if [[ ${NINFILES} -eq 0 ]];
 
                     if [[ ${number} -lt 10 ]];
                         then
-                        ${ANTSPATH}/ImageMath $TDIM selection/vol000${number}.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
+                        ImageMath $TDIM selection/vol000${number}.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
                         #     cp vol000${number}.nii.gz selection/
                     elif [[ ${number} -ge 10 && ${number} -lt 100 ]];
                         then
-                        ${ANTSPATH}/ImageMath $TDIM selection/vol00${number}.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
+                        ImageMath $TDIM selection/vol00${number}.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
                         #     cp vol00${number}.nii.gz selection/
                     elif [[ ${number} -ge 100 && ${number} -lt 1000 ]];
                         then
-                        ${ANTSPATH}/ImageMath $TDIM selection/vol0${number}.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
+                        ImageMath $TDIM selection/vol0${number}.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
                         #     cp vol0${number}.nii.gz selection/
                     fi
                     let j++
@@ -855,17 +825,17 @@ if [[ ${NINFILES} -eq 0 ]];
                 let "number %= $range"
                 if [[ ${number} -lt 10 ]];
                     then
-                    ${ANTSPATH}/ImageMath $TDIM selection/vol0.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
+                    ImageMath $TDIM selection/vol0.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
                     #     cp vol000${number}.nii.gz selection/
                 elif [[ ${number} -ge 10 && ${number} -lt 100 ]];
                     then
-                    ${ANTSPATH}/ImageMath $TDIM selection/vol0.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
+                    ImageMath $TDIM selection/vol0.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
                     #     cp vol00${number}.nii.gz selection/
                 fi
             done
         elif [[ ${range} -le ${nfmribins} ]];
             then
-            ${ANTSPATH}/ImageMath selection/$TDIM vol0.nii.gz TimeSeriesSubset ${IMAGESETVARIABLE} ${range}
+            ImageMath selection/$TDIM vol0.nii.gz TimeSeriesSubset ${IMAGESETVARIABLE} ${range}
             #  cp *.nii.gz selection/
         fi
         # set filelist variable
@@ -1033,12 +1003,12 @@ if [[ "$RIGID" -eq 1 ]];
 
         if [[ $DOQSUB -eq 1 ]];
             then
-            id=`qsub -cwd -S /bin/bash -N antsBuildTemplate_rigid -v ANTSPATH=$ANTSPATH $QSUBOPTS $qscript | awk '{print $3}'`
+            id=`qsub -cwd -S /bin/bash -N antsBuildTemplate_rigid $QSUBOPTS $qscript | awk '{print $3}'`
             jobIDs="$jobIDs $id"
             sleep 0.5
         elif [[ $DOQSUB -eq 4 ]];
             then
-            id=`qsub -N antsrigid -v ANTSPATH=$ANTSPATH $QSUBOPTS -q nopreempt -l nodes=1:ppn=1 -l walltime=20:00:00 -l mem=8gb $qscript | awk '{print $1}'`
+            id=`qsub -N antsrigid $QSUBOPTS -q nopreempt -l nodes=1:ppn=1 -l walltime=20:00:00 -l mem=8gb $qscript | awk '{print $1}'`
             jobIDs="$jobIDs $id"
             sleep 0.5
         elif [[ $DOQSUB -eq 2 ]];
@@ -1053,7 +1023,7 @@ if [[ "$RIGID" -eq 1 ]];
             jobIDs="$jobIDs $id"
         elif [[ $DOQSUB -eq 5 ]];
             then
-            id=`sbatch --job-name=antsrigid --export=ANTSPATH=$ANTSPATH $QSUBOPTS --nodes=1 --cpus-per-task=1 --time=20:00:00 --mem=8192M $qscript | rev | cut -f1 -d\ | rev`
+            id=`sbatch --job-name=antsrigid $QSUBOPTS --nodes=1 --cpus-per-task=1 --time=20:00:00 --mem=8192M $qscript | rev | cut -f1 -d\ | rev`
             jobIDs="$jobIDs $id"
             sleep 0.5
         elif [[ $DOQSUB -eq 0 ]];
@@ -1071,7 +1041,7 @@ if [[ "$RIGID" -eq 1 ]];
         echo " Starting ANTS rigid registration on SGE cluster. Submitted $count jobs "
         echo "--------------------------------------------------------------------------------------"
         # now wait for the jobs to finish. Rigid registration is quick, so poll queue every 60 seconds
- ${ANTSPATH}/waitForSGEQJobs.pl 1 60 $jobIDs
+ waitForSGEQJobs.pl 1 60 $jobIDs
         # Returns 1 if there are errors
         if [[ ! $? -eq 0 ]];
             then
@@ -1087,7 +1057,7 @@ if [[ "$RIGID" -eq 1 ]];
         echo " Starting ANTS rigid registration on PBS cluster. Submitted $count jobs "
         echo "--------------------------------------------------------------------------------------"
                # now wait for the jobs to finish. Rigid registration is quick, so poll queue every 60 seconds
-        ${ANTSPATH}/waitForPBSQJobs.pl 1 60 $jobIDs
+        waitForPBSQJobs.pl 1 60 $jobIDs
         # Returns 1 if there are errors
         if [[ ! $? -eq 0 ]];
             then
@@ -1115,7 +1085,7 @@ if [[ "$RIGID" -eq 1 ]];
         echo " Starting ANTS rigid registration on XGrid cluster. Submitted $count jobs "
         echo "--------------------------------------------------------------------------------------"
         # now wait for the jobs to finish. Rigid registration is quick, so poll queue every 60 seconds
-        ${ANTSPATH}/waitForXGridJobs.pl -xgridflags "$XGRIDOPTS" -verbose -delay 30 $jobIDs
+        waitForXGridJobs.pl -xgridflags "$XGRIDOPTS" -verbose -delay 30 $jobIDs
         # Returns 1 if there are errors
         if [[ ! $? -eq 0 ]];
             then
@@ -1131,7 +1101,7 @@ if [[ "$RIGID" -eq 1 ]];
         echo " Starting ANTS rigid registration on SLURM cluster. Submitted $count jobs "
         echo "--------------------------------------------------------------------------------------"
                # now wait for the jobs to finish. Rigid registration is quick, so poll queue every 60 seconds
-        ${ANTSPATH}/waitForSlurmJobs.pl 1 60 $jobIDs
+        waitForSlurmJobs.pl 1 60 $jobIDs
         # Returns 1 if there are errors
         if [[ ! $? -eq 0 ]];
             then
@@ -1154,7 +1124,7 @@ if [[ "$RIGID" -eq 1 ]];
             IMAGERIGIDSET[${#IMAGERIGIDSET[@]}]=$RIGID
         done
         echo
-        echo  "${ANTSPATH}/AverageImages $DIM ${TEMPLATES[$j]} 2 ${IMAGERIGIDSET[@]}"
+        echo  "AverageImages $DIM ${TEMPLATES[$j]} 2 ${IMAGERIGIDSET[@]}"
 
       # Don't sharpen after rigid alignment
       summarizeimageset $DIM ${TEMPLATES[$j]} ${STATSMETHOD} 0 ${IMAGERIGIDSET[@]}
@@ -1412,14 +1382,14 @@ while [[ $i -lt ${ITERATIONLIMIT} ]];
             then
             echo -e "$SCRIPTPREPEND" > $qscript
             echo -e "$exe" >> $qscript
-            id=`qsub -cwd -N antsBuildTemplate_deformable_${i} -S /bin/bash -v ANTSPATH=$ANTSPATH $QSUBOPTS $qscript | awk '{print $3}'`
+            id=`qsub -cwd -N antsBuildTemplate_deformable_${i} -S /bin/bash $QSUBOPTS $qscript | awk '{print $3}'`
             jobIDs="$jobIDs $id"
             sleep 0.5
         elif [[ $DOQSUB -eq 4 ]];
             then
             echo -e "$SCRIPTPREPEND" > $qscript
             echo -e "$exe" >> $qscript
-            id=`qsub -N antsdef${i} -v ANTSPATH=$ANTSPATH -q nopreempt -l nodes=1:ppn=1 -l walltime=20:00:00 -l mem=8gb $QSUBOPTS $qscript | awk '{print $1}'`
+            id=`qsub -N antsdef${i} -q nopreempt -l nodes=1:ppn=1 -l walltime=20:00:00 -l mem=8gb $QSUBOPTS $qscript | awk '{print $1}'`
             jobIDs="$jobIDs $id"
             sleep 0.5
         elif [[ $DOQSUB -eq 2 ]];
@@ -1436,7 +1406,7 @@ while [[ $i -lt ${ITERATIONLIMIT} ]];
             echo '#!/bin/sh' > $qscript
             echo -e "$SCRIPTPREPEND" >> $qscript
             echo -e "$exe" >> $qscript
-            id=`sbatch --job-name=antsdef${i} --export=ANTSPATH=$ANTSPATH --nodes=1 --cpus-per-task=1 --time=20:00:00 --mem=8192M $QSUBOPTS $qscript | rev | cut -f1 -d\ | rev`
+            id=`sbatch --job-name=antsdef${i} --nodes=1 --cpus-per-task=1 --time=20:00:00 --mem=8192M $QSUBOPTS $qscript | rev | cut -f1 -d\ | rev`
             jobIDs="$jobIDs $id"
             sleep 0.5
         elif [[ $DOQSUB -eq 0 ]];
@@ -1457,7 +1427,7 @@ while [[ $i -lt ${ITERATIONLIMIT} ]];
         echo " Starting ANTS registration on SGE cluster. Iteration: $itdisplay of $ITERATIONLIMIT"
         echo "--------------------------------------------------------------------------------------"
         # now wait for the stuff to finish - this will take a while so poll queue every 10 mins
-        ${ANTSPATH}/waitForSGEQJobs.pl 1 600 $jobIDs
+        waitForSGEQJobs.pl 1 600 $jobIDs
         if [[ ! $? -eq 0 ]];
             then
             echo "qsub submission failed - jobs went into error state"
@@ -1470,7 +1440,7 @@ while [[ $i -lt ${ITERATIONLIMIT} ]];
         echo " Starting ANTS registration on PBS cluster. Iteration: $itdisplay of $ITERATIONLIMIT"
         echo "--------------------------------------------------------------------------------------"
         # now wait for the stuff to finish - this will take a while so poll queue every 10 mins
-        ${ANTSPATH}/waitForPBSQJobs.pl 1 600 $jobIDs
+        waitForPBSQJobs.pl 1 600 $jobIDs
         if [[ ! $? -eq 0 ]];
             then
             echo "qsub submission failed - jobs went into error state"
@@ -1497,7 +1467,7 @@ while [[ $i -lt ${ITERATIONLIMIT} ]];
         echo " Starting ANTS registration on XGrid cluster. Submitted $count jobs "
         echo "--------------------------------------------------------------------------------------"
         # now wait for the jobs to finish. This is slow, so poll less often
-        ${ANTSPATH}/waitForXGridJobs.pl -xgridflags "$XGRIDOPTS" -verbose -delay 300 $jobIDs
+        waitForXGridJobs.pl -xgridflags "$XGRIDOPTS" -verbose -delay 300 $jobIDs
         # Returns 1 if there are errors
         if [[ ! $? -eq 0 ]];
             then
@@ -1513,7 +1483,7 @@ while [[ $i -lt ${ITERATIONLIMIT} ]];
         echo " Starting ANTS registration on SLURM cluster. Submitted $count jobs "
         echo "--------------------------------------------------------------------------------------"
         # now wait for the stuff to finish - this will take a while so poll queue every 10 mins
-        ${ANTSPATH}/waitForSlurmJobs.pl 1 600 $jobIDs
+        waitForSlurmJobs.pl 1 600 $jobIDs
         if [[ ! $? -eq 0 ]];
             then
             echo "SLURM submission failed - jobs went into error state"
diff --git a/Scripts/antsMultivariateTemplateConstruction2.sh b/Scripts/antsMultivariateTemplateConstruction2.sh
index e50e9a5c..fe1112d3 100755
--- a/Scripts/antsMultivariateTemplateConstruction2.sh
+++ b/Scripts/antsMultivariateTemplateConstruction2.sh
@@ -4,52 +4,21 @@ shopt -s extglob
 
 VERSION="0.0.0"
 
-# trap keyboard interrupt (control-c)
-trap control_c SIGINT
-
-function setPath {
-    cat <<SETPATH
-
---------------------------------------------------------------------------------------
-Error locating ANTS
---------------------------------------------------------------------------------------
-It seems that the ANTSPATH environment variable is not set. Please add the ANTSPATH
-variable. This can be achieved by editing the .bash_profile in the home directory.
-Add:
-
-ANTSPATH=/home/yourname/bin/ants/
-
-Or the correct location of the ANTS binaries.
-
-Alternatively, edit this script ( `basename $0` ) to set up this parameter correctly.
-
-SETPATH
-    exit 1
-}
-
-# Uncomment the line below in case you have not set the ANTSPATH variable in your environment.
-# export ANTSPATH=${ANTSPATH:="$HOME/bin/ants/"} # EDIT THIS
-
-if [[ ${#ANTSPATH} -le 3 ]];
-  then
-    setPath >&2
-  fi
-
 # Test availability of helper scripts.
 # No need to test this more than once. Can reside outside of the main loop.
-ANTS=${ANTSPATH}/antsRegistration
-WARP=${ANTSPATH}/antsApplyTransforms
-N4=${ANTSPATH}/N4BiasFieldCorrection
-PEXEC=${ANTSPATH}/ANTSpexec.sh
-SGE=${ANTSPATH}/waitForSGEQJobs.pl
-PBS=${ANTSPATH}/waitForPBSQJobs.pl
-XGRID=${ANTSPATH}/waitForXGridJobs.pl
-SLURM=${ANTSPATH}/waitForSlurmJobs.pl
+ANTS=antsRegistration
+WARP=antsApplyTransforms
+N4=N4BiasFieldCorrection
+PEXEC=ANTSpexec.sh
+SGE=waitForSGEQJobs.pl
+PBS=waitForPBSQJobs.pl
+XGRID=waitForXGridJobs.pl
+SLURM=waitForSlurmJobs.pl
 
 fle_error=0
 for FLE in $ANTS $WARP $N4 $PEXEC $SGE $XGRID $PBS $SLURM
   do
-    if [[ ! -x $FLE ]];
+    if ! command -v $FLE &> /dev/null
       then
         echo
         echo "-----------------------------------------------------------------------------"
@@ -295,8 +264,6 @@ function reportMappingParameters {
 --------------------------------------------------------------------------------------
  Mapping parameters
 --------------------------------------------------------------------------------------
- ANTSPATH is $ANTSPATH
-
  Dimensionality:           $DIM
  Do N4 bias correction:    $N4CORRECT
  Back up each iteration:   $BACKUPEACHITERATION
@@ -341,10 +308,10 @@ function summarizeimageset() {
 
   case $summarizemethod in
     0) #mean
-      ${ANTSPATH}/AverageImages $dim $output 0 ${images[@]}
+      AverageImages $dim $output 0 ${images[@]}
       ;;
     1) #mean of normalized images
-      ${ANTSPATH}/AverageImages $dim $output 2 ${images[@]}
+      AverageImages $dim $output 2 ${images[@]}
       ;;
     2) #median
       local image
@@ -352,7 +319,7 @@ function summarizeimageset() {
         do
           echo $image >> ${output}_list.txt
         done
-      ${ANTSPATH}/ImageSetStatistics $dim ${output}_list.txt ${output} 0
+      ImageSetStatistics $dim ${output}_list.txt ${output} 0
       rm ${output}_list.txt
       ;;
   esac
@@ -369,11 +336,11 @@ function summarizeimageset() {
       ;;
     1)
       echo "Laplacian sharpening"
-      ${ANTSPATH}/ImageMath $dim $output Sharpen $output
+      ImageMath $dim $output Sharpen $output
       ;;
     2)
       echo "Unsharp mask sharpening"
-      ${ANTSPATH}/ImageMath $dim $output UnsharpMask $output 0.5 1 0 0
+      ImageMath $dim $output UnsharpMask $output 0.5 1 0 0
       ;;
   esac
 
@@ -416,8 +383,8 @@ function shapeupdatetotemplate() {
     echo "--------------------------------------------------------------------------------------"
     echo " shapeupdatetotemplate---voxel-wise averaging of the warped images to the current template"
     date
-    #echo "   ${ANTSPATH}/AverageImages $dim ${template} 1 ${templatename}${whichtemplate}*WarpedToTemplate.nii.gz    "
-    #echo "    ${ANTSPATH}/ImageSetStatistics $dim ${whichtemplate}WarpedToTemplateList.txt ${template} 0"
+    #echo "   AverageImages $dim ${template} 1 ${templatename}${whichtemplate}*WarpedToTemplate.nii.gz    "
+    #echo "    ImageSetStatistics $dim ${whichtemplate}WarpedToTemplateList.txt ${template} 0"
     echo "--------------------------------------------------------------------------------------"
 
     imagelist=(`ls ${outputname}template${whichtemplate}*WarpedToTemplate.nii.gz`)
@@ -442,34 +409,34 @@ function shapeupdatetotemplate() {
           echo
           echo "--------------------------------------------------------------------------------------"
           echo " shapeupdatetotemplate---voxel-wise averaging of the inverse warp fields (from subject to template)"
-          echo "   ${ANTSPATH}/AverageImages $dim ${templatename}${whichtemplate}warp.nii.gz 0 `ls ${outputname}*Warp.nii.gz | grep -v "InverseWarp"`"
+          echo "   AverageImages $dim ${templatename}${whichtemplate}warp.nii.gz 0 `ls ${outputname}*Warp.nii.gz | grep -v "InverseWarp"`"
           date
           echo "--------------------------------------------------------------------------------------"
-          ${ANTSPATH}/AverageImages $dim ${templatename}${whichtemplate}warp.nii.gz 0 `ls ${outputname}*Warp.nii.gz | grep -v "InverseWarp"`
+          AverageImages $dim ${templatename}${whichtemplate}warp.nii.gz 0 `ls ${outputname}*Warp.nii.gz | grep -v "InverseWarp"`
 
           echo
           echo "--------------------------------------------------------------------------------------"
           echo " shapeupdatetotemplate---scale the averaged inverse warp field by the gradient step"
-          echo "   ${ANTSPATH}/MultiplyImages $dim ${templatename}${whichtemplate}warp.nii.gz ${gradientstep} ${templatename}${whichtemplate}warp.nii.gz"
+          echo "   MultiplyImages $dim ${templatename}${whichtemplate}warp.nii.gz ${gradientstep} ${templatename}${whichtemplate}warp.nii.gz"
           date
           echo "--------------------------------------------------------------------------------------"
-          ${ANTSPATH}/MultiplyImages $dim ${templatename}${whichtemplate}warp.nii.gz ${gradientstep} ${templatename}${whichtemplate}warp.nii.gz
+          MultiplyImages $dim ${templatename}${whichtemplate}warp.nii.gz ${gradientstep} ${templatename}${whichtemplate}warp.nii.gz
         fi
 
         echo
         echo "--------------------------------------------------------------------------------------"
         echo " shapeupdatetotemplate---average the affine transforms (template <-> subject)"
         echo "                      ---transform the inverse field by the resulting average affine transform"
-        echo "   ${ANTSPATH}/${AVERAGE_AFFINE_PROGRAM} ${dim} ${templatename}0GenericAffine.mat ${outputname}*GenericAffine.mat"
+        echo "   ${AVERAGE_AFFINE_PROGRAM} ${dim} ${templatename}0GenericAffine.mat ${outputname}*GenericAffine.mat"
         echo "   ${WARP} -d ${dim} -e vector -i ${templatename}0warp.nii.gz -o ${templatename}0warp.nii.gz -t [ ${templatename}0GenericAffine.mat,1 ] -r ${template} --verbose 1"
         echo "--------------------------------------------------------------------------------------"
 
-        ${ANTSPATH}/${AVERAGE_AFFINE_PROGRAM} ${dim} ${templatename}0GenericAffine.mat ${outputname}*GenericAffine.mat
+        ${AVERAGE_AFFINE_PROGRAM} ${dim} ${templatename}0GenericAffine.mat ${outputname}*GenericAffine.mat
 
         if [[ $NWARPS -ne 0 ]];
           then
             ${WARP} -d ${dim} -e vector -i ${templatename}0warp.nii.gz -o ${templatename}0warp.nii.gz -t [ ${templatename}0GenericAffine.mat,1 ] -r ${template} --verbose 1
-            ${ANTSPATH}/MeasureMinMaxMean ${dim} ${templatename}0warp.nii.gz ${templatename}warplog.txt 1
+            MeasureMinMaxMean ${dim} ${templatename}0warp.nii.gz ${templatename}warplog.txt 1
           fi
       fi
 
@@ -925,7 +892,7 @@ elif [[ ${NINFILES} -eq 1 ]];
             done
          done < $IMAGESFILE
     else
-        range=`${ANTSPATH}/ImageMath $TDIM abs nvols ${IMAGESETVARIABLE} | tail -1 | cut -d "," -f 4 | cut -d " " -f 2 | cut -d " ]" -f 1 `
+        range=`ImageMath $TDIM abs nvols ${IMAGESETVARIABLE} | tail -1 | cut -d "," -f 4 | cut -d " " -f 2 | cut -d " ]" -f 1 `
         if [[ ${range} -eq 1 && ${TDIM} -ne 4 ]];
           then
             echo "Please provide at least 2 filenames for the template."
@@ -956,7 +923,7 @@ elif [[ ${NINFILES} -eq 1 ]];
              #split the 4D file into 3D elements
              cp ${IMAGESETVARIABLE} ${tmpdir}/
              cd ${tmpdir}/
-             # ${ANTSPATH}/ImageMath $TDIM vol0.nii.gz TimeSeriesSubset ${IMAGESETVARIABLE} ${range}
+             # ImageMath $TDIM vol0.nii.gz TimeSeriesSubset ${IMAGESETVARIABLE} ${range}
              # rm -f ${IMAGESETVARIABLE}
 
              # selecting 16 volumes randomly from the timeseries for averaging, placing them in tmp/selection folder.
@@ -992,15 +959,15 @@ elif [[ ${NINFILES} -eq 1 ]];
 
                     if [[ ${number} -lt 10 ]];
                         then
-                        ${ANTSPATH}/ImageMath $TDIM selection/vol000${number}.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
+                        ImageMath $TDIM selection/vol000${number}.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
                         #   cp vol000${number}.nii.gz selection/
                     elif [[ ${number} -ge 10 && ${number} -lt 100 ]];
                         then
-                        ${ANTSPATH}/ImageMath $TDIM selection/vol00${number}.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
+                        ImageMath $TDIM selection/vol00${number}.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
                         #   cp vol00${number}.nii.gz selection/
                     elif [[ ${number} -ge 100 && ${number} -lt 1000 ]];
                         then
-                        ${ANTSPATH}/ImageMath $TDIM selection/vol0${number}.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
+                        ImageMath $TDIM selection/vol0${number}.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
                         #   cp vol0${number}.nii.gz selection/
                     fi
                     let j++
@@ -1014,17 +981,17 @@ elif [[ ${NINFILES} -eq 1 ]];
                 let "number %= $range"
                 if [[ ${number} -lt 10 ]];
                     then
-                    ${ANTSPATH}/ImageMath $TDIM selection/vol0.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
+                    ImageMath $TDIM selection/vol0.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
                     #   cp vol000${number}.nii.gz selection/
                 elif [[ ${number} -ge 10 && ${number} -lt 100 ]];
                     then
-                    ${ANTSPATH}/ImageMath $TDIM selection/vol0.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
+                    ImageMath $TDIM selection/vol0.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
                     #   cp vol00${number}.nii.gz selection/
                 fi
             done
         elif [[ ${range} -le ${nfmribins} ]];
             then
-            ${ANTSPATH}/ImageMath selection/$TDIM vol0.nii.gz TimeSeriesSubset ${IMAGESETVARIABLE} ${range}
+            ImageMath selection/$TDIM vol0.nii.gz TimeSeriesSubset ${IMAGESETVARIABLE} ${range}
             # cp *.nii.gz selection/
         fi
         # set filelist variable
@@ -1199,12 +1166,12 @@ if [[ "$RIGID" -eq 1 ]];
 
         if [[ $DOQSUB -eq 1 ]];
           then
-            id=`qsub -cwd -S /bin/bash -N antsBuildTemplate_rigid -v ANTSPATH=$ANTSPATH $QSUBOPTS $qscript | awk '{print $3}'`
+            id=`qsub -cwd -S /bin/bash -N antsBuildTemplate_rigid -v  $QSUBOPTS $qscript | awk '{print $3}'`
             jobIDs="$jobIDs $id"
             sleep 0.5
         elif [[ $DOQSUB -eq 4 ]];
           then
-            id=`qsub -N antsrigid -v ANTSPATH=$ANTSPATH $QSUBOPTS -q nopreempt -l nodes=1:ppn=1 -l mem=${MEMORY} -l walltime=${WALLTIME} $qscript | awk '{print $1}'`
+            id=`qsub -N antsrigid -v  $QSUBOPTS -q nopreempt -l nodes=1:ppn=1 -l mem=${MEMORY} -l walltime=${WALLTIME} $qscript | awk '{print $1}'`
             jobIDs="$jobIDs $id"
             sleep 0.5
         elif [[ $DOQSUB -eq 2 ]];
@@ -1219,7 +1186,7 @@ if [[ "$RIGID" -eq 1 ]];
             jobIDs="$jobIDs $id"
         elif [[ $DOQSUB -eq 5 ]];
             then
-            id=`sbatch --job-name=antsrigid --export=ANTSPATH=$ANTSPATH $QSUBOPTS --nodes=1 --cpus-per-task=1 --time=${WALLTIME} --mem=${MEMORY} $qscript | rev | cut -f1 -d\ | rev`
+            id=`sbatch --job-name=antsrigid --export= $QSUBOPTS --nodes=1 --cpus-per-task=1 --time=${WALLTIME} --mem=${MEMORY} $qscript | rev | cut -f1 -d\ | rev`
             jobIDs="$jobIDs $id"
             sleep 0.5
         elif [[ $DOQSUB -eq 0 ]];
@@ -1238,7 +1205,7 @@ if [[ "$RIGID" -eq 1 ]];
         echo " Starting ANTS rigid registration on SGE cluster. Submitted $count jobs "
         echo "--------------------------------------------------------------------------------------"
         # now wait for the jobs to finish. Rigid registration is quick, so poll queue every 60 seconds
-        ${ANTSPATH}/waitForSGEQJobs.pl 1 60 $jobIDs
+        waitForSGEQJobs.pl 1 60 $jobIDs
         # Returns 1 if there are errors
         if [[ ! $? -eq 0 ]];
           then
@@ -1254,7 +1221,7 @@ if [[ "$RIGID" -eq 1 ]];
         echo " Starting ANTS rigid registration on PBS cluster. Submitted $count jobs "
         echo "--------------------------------------------------------------------------------------"
                # now wait for the jobs to finish. Rigid registration is quick, so poll queue every 60 seconds
-        ${ANTSPATH}/waitForPBSQJobs.pl 1 60 $jobIDs
+        waitForPBSQJobs.pl 1 60 $jobIDs
         # Returns 1 if there are errors
         if [[ ! $? -eq 0 ]];
           then
@@ -1282,7 +1249,7 @@ if [[ "$RIGID" -eq 1 ]];
         echo " Starting ANTS rigid registration on XGrid cluster. Submitted $count jobs "
         echo "--------------------------------------------------------------------------------------"
         # now wait for the jobs to finish. Rigid registration is quick, so poll queue every 60 seconds
-        ${ANTSPATH}/waitForXGridJobs.pl -xgridflags "$XGRIDOPTS" -verbose -delay 30 $jobIDs
+        waitForXGridJobs.pl -xgridflags "$XGRIDOPTS" -verbose -delay 30 $jobIDs
         # Returns 1 if there are errors
         if [[ ! $? -eq 0 ]];
           then
@@ -1298,7 +1265,7 @@ if [[ "$RIGID" -eq 1 ]];
         echo " Starting ANTS rigid registration on SLURM cluster. Submitted $count jobs "
         echo "--------------------------------------------------------------------------------------"
                # now wait for the jobs to finish. Rigid registration is quick, so poll queue every 60 seconds
-        ${ANTSPATH}/waitForSlurmJobs.pl 1 60 $jobIDs
+        waitForSlurmJobs.pl 1 60 $jobIDs
         # Returns 1 if there are errors
         if [[ ! $? -eq 0 ]];
           then
@@ -1575,14 +1542,14 @@ while [[ $i -lt ${ITERATIONLIMIT} ]];
           then
             echo "$SCRIPTPREPEND" > $qscript
             echo -e "$exe" >> $qscript
-            id=`qsub -cwd -N antsBuildTemplate_deformable_${i} -S /bin/bash -v ANTSPATH=$ANTSPATH $QSUBOPTS $qscript | awk '{print $3}'`
+            id=`qsub -cwd -N antsBuildTemplate_deformable_${i} -S /bin/bash -v  $QSUBOPTS $qscript | awk '{print $3}'`
             jobIDs="$jobIDs $id"
             sleep 0.5
         elif [[ $DOQSUB -eq 4 ]];
           then
             echo -e "$SCRIPTPREPEND" > $qscript
             echo -e "$exe" >> $qscript
-            id=`qsub -N antsdef${i} -v ANTSPATH=$ANTSPATH -q nopreempt -l nodes=1:ppn=1 -l mem=${MEMORY} -l walltime=${WALLTIME} $QSUBOPTS $qscript | awk '{print $1}'`
+            id=`qsub -N antsdef${i} -v  -q nopreempt -l nodes=1:ppn=1 -l mem=${MEMORY} -l walltime=${WALLTIME} $QSUBOPTS $qscript | awk '{print $1}'`
             jobIDs="$jobIDs $id"
             sleep 0.5
         elif [[ $DOQSUB -eq 2 ]];
@@ -1599,7 +1566,7 @@ while [[ $i -lt ${ITERATIONLIMIT} ]];
             echo '#!/bin/sh' > $qscript
             echo -e "$SCRIPTPREPEND" >> $qscript
             echo -e "$exe" >> $qscript
-            id=`sbatch --job-name=antsdef${i} --export=ANTSPATH=$ANTSPATH --nodes=1 --cpus-per-task=1 --time=${WALLTIME} --mem=${MEMORY} $QSUBOPTS $qscript | rev | cut -f1 -d\ | rev`
+            id=`sbatch --job-name=antsdef${i} --export= --nodes=1 --cpus-per-task=1 --time=${WALLTIME} --mem=${MEMORY} $QSUBOPTS $qscript | rev | cut -f1 -d\ | rev`
             jobIDs="$jobIDs $id"
             sleep 0.5
         elif [[ $DOQSUB -eq 0 ]];
@@ -1620,7 +1587,7 @@ while [[ $i -lt ${ITERATIONLIMIT} ]];
         echo " Starting ANTS registration on SGE cluster. Iteration: $itdisplay of $ITERATIONLIMIT"
         echo "--------------------------------------------------------------------------------------"
         # now wait for the stuff to finish - this will take a while so poll queue every 10 mins
-        ${ANTSPATH}/waitForSGEQJobs.pl 1 600 $jobIDs
+        waitForSGEQJobs.pl 1 600 $jobIDs
         if [[ ! $? -eq 0 ]];
           then
             echo "qsub submission failed - jobs went into error state"
@@ -1633,7 +1600,7 @@ while [[ $i -lt ${ITERATIONLIMIT} ]];
         echo " Starting ANTS registration on PBS cluster. Iteration: $itdisplay of $ITERATIONLIMIT"
         echo "--------------------------------------------------------------------------------------"
         # now wait for the stuff to finish - this will take a while so poll queue every 10 mins
-        ${ANTSPATH}/waitForPBSQJobs.pl 1 600 $jobIDs
+        waitForPBSQJobs.pl 1 600 $jobIDs
         if [[ ! $? -eq 0 ]];
           then
             echo "qsub submission failed - jobs went into error state"
@@ -1661,7 +1628,7 @@ while [[ $i -lt ${ITERATIONLIMIT} ]];
         echo " Starting ANTS registration on XGrid cluster. Submitted $count jobs "
         echo "--------------------------------------------------------------------------------------"
         # now wait for the jobs to finish. This is slow, so poll less often
-        ${ANTSPATH}/waitForXGridJobs.pl -xgridflags "$XGRIDOPTS" -verbose -delay 300 $jobIDs
+        waitForXGridJobs.pl -xgridflags "$XGRIDOPTS" -verbose -delay 300 $jobIDs
         # Returns 1 if there are errors
         if [[ ! $? -eq 0 ]];
           then
@@ -1678,7 +1645,7 @@ while [[ $i -lt ${ITERATIONLIMIT} ]];
         echo " Starting ANTS registration on SLURM cluster. Submitted $count jobs "
         echo "--------------------------------------------------------------------------------------"
         # now wait for the stuff to finish - this will take a while so poll queue every 10 mins
-        ${ANTSPATH}/waitForSlurmJobs.pl 1 600 $jobIDs
+        waitForSlurmJobs.pl 1 600 $jobIDs
         if [[ ! $? -eq 0 ]];
           then
             echo "SLURM submission failed - jobs went into error state"
diff --git a/Scripts/antsNeuroimagingBattery b/Scripts/antsNeuroimagingBattery
index d6c5f8c4..2d4a4025 100755
--- a/Scripts/antsNeuroimagingBattery
+++ b/Scripts/antsNeuroimagingBattery
@@ -89,8 +89,6 @@ my $temp = "/state/partition1/";
 my $help=0;
 my $info=0;
 
-my $ANTSPATH = $ENV{ANTSPATH};
-
 GetOptions ("input-directory=s"         => \$subdir,    # string
             "output-directory=s"        => \$outdir,     # string
             "output-name=s"             => \$outname,    # string
@@ -225,33 +223,33 @@ for my $dtfile ( @$dtifiles ) {
 
     my $obase = "${outdir}${dirname}${outname}${outid}";
     my $ref = "${obase}ref.nii.gz";
-    system("${ANTSPATH}/ImageMath 3 $ref m $anat $mask" );
-    my $res = "${ANTSPATH}/ResampleImageBySpacing 3 $ref $ref 2.0 2.0 2.0";
+    system("ImageMath 3 $ref m $anat $mask" );
+    my $res = "ResampleImageBySpacing 3 $ref $ref 2.0 2.0 2.0";
     print("$res\n");
     system($res);
 
-    my $dtiexe = "${ANTSPATH}/antsIntermodalityIntrasubject.sh -d 3 -t 2 -i $dwi -b $dtfile -r $ref -R $anat -x $mask $warpflag -o ${outdir}${dirname}${outname}${outid} -T $template";
+    my $dtiexe = "antsIntermodalityIntrasubject.sh -d 3 -t 2 -i $dwi -b $dtfile -r $ref -R $anat -x $mask $warpflag -o ${outdir}${dirname}${outname}${outid} -T $template";
     print( "$dtiexe\n");
     system( $dtiexe );
 
-    system("${ANTSPATH}/ImageMath 3 ${outdir}${dirname}${outname}${outid}fa_anatomical.nii.gz TensorFA ${outdir}${dirname}${outname}${outid}dt_anatomical.nii.gz");
-    system("${ANTSPATH}/ImageMath 3 ${outdir}${dirname}${outname}${outid}fa_anatomical.nii.gz m ${outdir}${dirname}${outname}${outid}fa_anatomical.nii.gz $mask");
+    system("ImageMath 3 ${outdir}${dirname}${outname}${outid}fa_anatomical.nii.gz TensorFA ${outdir}${dirname}${outname}${outid}dt_anatomical.nii.gz");
+    system("ImageMath 3 ${outdir}${dirname}${outname}${outid}fa_anatomical.nii.gz m ${outdir}${dirname}${outname}${outid}fa_anatomical.nii.gz $mask");
 
-     system("${ANTSPATH}/ImageMath 3 ${outdir}${dirname}${outname}${outid}md_anatomical.nii.gz TensorMeanDiffusion ${outdir}${dirname}${outname}${outid}dt_anatomical.nii.gz");
-    system("${ANTSPATH}/ImageMath 3 ${outdir}${dirname}${outname}${outid}md_anatomical.nii.gz m ${outdir}${dirname}${outname}${outid}md_anatomical.nii.gz $mask");
+     system("ImageMath 3 ${outdir}${dirname}${outname}${outid}md_anatomical.nii.gz TensorMeanDiffusion ${outdir}${dirname}${outname}${outid}dt_anatomical.nii.gz");
+    system("ImageMath 3 ${outdir}${dirname}${outname}${outid}md_anatomical.nii.gz m ${outdir}${dirname}${outname}${outid}md_anatomical.nii.gz $mask");
 
-    system("${ANTSPATH}/ImageMath 3 ${outdir}${dirname}${outname}${outid}rd_anatomical.nii.gz TensorRadialDiffusion ${outdir}${dirname}${outname}${outid}dt_anatomical.nii.gz");
-    system("${ANTSPATH}/ImageMath 3 ${outdir}${dirname}${outname}${outid}rd_anatomical.nii.gz m ${outdir}${dirname}${outname}${outid}rd_anatomical.nii.gz $mask");
+    system("ImageMath 3 ${outdir}${dirname}${outname}${outid}rd_anatomical.nii.gz TensorRadialDiffusion ${outdir}${dirname}${outname}${outid}dt_anatomical.nii.gz");
+    system("ImageMath 3 ${outdir}${dirname}${outname}${outid}rd_anatomical.nii.gz m ${outdir}${dirname}${outname}${outid}rd_anatomical.nii.gz $mask");
 
     # Remove for space reasons
     system("rm ${outdir}${dirname}${outname}${outid}dt_anatomical.nii.gz");
 
     if ( -s "${outdir}${dirname}${outname}${outid}dt_template.nii.gz") {
-      system("${ANTSPATH}/ImageMath 3 ${outdir}${dirname}${outname}${outid}fa_template.nii.gz TensorFA ${outdir}${dirname}${outname}${outid}dt_template.nii.gz");
+      system("ImageMath 3 ${outdir}${dirname}${outname}${outid}fa_template.nii.gz TensorFA ${outdir}${dirname}${outname}${outid}dt_template.nii.gz");
 
-       system("${ANTSPATH}/ImageMath 3 ${outdir}${dirname}${outname}${outid}md_template.nii.gz TensorMeanDiffusion ${outdir}${dirname}${outname}${outid}dt_template.nii.gz");
+       system("ImageMath 3 ${outdir}${dirname}${outname}${outid}md_template.nii.gz TensorMeanDiffusion ${outdir}${dirname}${outname}${outid}dt_template.nii.gz");
 
-      system("${ANTSPATH}/ImageMath 3 ${outdir}${dirname}${outname}${outid}rd_template.nii.gz TensorRadialDiffusion ${outdir}${dirname}${outname}${outid}dt_template.nii.gz");
+      system("ImageMath 3 ${outdir}${dirname}${outname}${outid}rd_template.nii.gz TensorRadialDiffusion ${outdir}${dirname}${outname}${outid}dt_template.nii.gz");
 
       system("rm ${outdir}${dirname}${outname}${outid}dt_template.nii.gz");
 
@@ -287,12 +285,12 @@ for my $pcaslfile ( @$pcaslfiles ) {
     }
 
     if ( ! -e "$cbf" ) {
-      system("${ANTSPATH}/antsASLProcessing.R -s $pcaslfile  -o ${outdir}${dirname}${outname}${outid} -a ${outdir}${outname} -t $template $labelOpt");
+      system("antsASLProcessing.R -s $pcaslfile  -o ${outdir}${dirname}${outname}${outid} -a ${outdir}${outname} -t $template $labelOpt");
     }
 
-    #system("${ANTSPATH}/antsMotionCorrStats -x ${outdir}${dirname}${outname}${outid}brainmask.nii.gz -m ${outdir}${dirname}${outname}${outid}MOCOparams.csv -o ${outdir}${dirname}${outname}${outid}MOCOStatsFramewise.csv -f 1");
+    #system("antsMotionCorrStats -x ${outdir}${dirname}${outname}${outid}brainmask.nii.gz -m ${outdir}${dirname}${outname}${outid}MOCOparams.csv -o ${outdir}${dirname}${outname}${outid}MOCOStatsFramewise.csv -f 1");
 
-    #system("${ANTSPATH}/antsMotionCorrStats -x ${outdir}${dirname}${outname}${outid}brainmask.nii.gz -m ${outdir}${dirname}${outname}${outid}MOCOparams.csv -o ${outdir}${dirname}${outname}${outid}MOCOStatsReference.csv -f 0");
+    #system("antsMotionCorrStats -x ${outdir}${dirname}${outname}${outid}brainmask.nii.gz -m ${outdir}${dirname}${outname}${outid}MOCOparams.csv -o ${outdir}${dirname}${outname}${outid}MOCOStatsReference.csv -f 0");
 
   }
 }
@@ -330,15 +328,15 @@ for my $paslfile ( @$paslfiles ) {
 
       # Create anatomical reference to align to
 
-      system("${ANTSPATH}/ImageMath 3 $ref m $anat $mask" );
-      my $res = "${ANTSPATH}/ResampleImageBySpacing 3 $ref $ref 2.0 2.0 2.0";
+      system("ImageMath 3 $ref m $anat $mask" );
+      my $res = "ResampleImageBySpacing 3 $ref $ref 2.0 2.0 2.0";
       system($res);
 
       # Motion correct M0
-      my $m0Moco1 = "${ANTSPATH}/antsMotionCorr -d 3 -a $m0file -o $meanM0";
+      my $m0Moco1 = "antsMotionCorr -d 3 -a $m0file -o $meanM0";
       system($m0Moco1);
 
-      my $m0Moco2 = "${ANTSPATH}/antsMotionCorr -d 3 -o [ ${outdir}${dirname}${outname}${outid}m0, $M0, $meanM0 ] -u 1 -m mi[ $meanM0, $m0file, 1, 32, Regular, 0.1 ] -t Affine[ 0.2 ] -i 25 -e 1 -f 1 -s 0 -l 0";
+      my $m0Moco2 = "antsMotionCorr -d 3 -o [ ${outdir}${dirname}${outname}${outid}m0, $M0, $meanM0 ] -u 1 -m mi[ $meanM0, $m0file, 1, 32, Regular, 0.1 ] -t Affine[ 0.2 ] -i 25 -e 1 -f 1 -s 0 -l 0";
       print( "$m0Moco2\n");
       system( $m0Moco2 );
 
@@ -348,12 +346,12 @@ for my $paslfile ( @$paslfiles ) {
     #print("$paslMoco\n");
     #system($paslMoco);
 
-      my $makecbf = "${ANTSPATH}/cbf_pasl_robust_batch.R $paslfile $meanM0 $cbf";
+      my $makecbf = "cbf_pasl_robust_batch.R $paslfile $meanM0 $cbf";
       print( "\n\n\n$makecbf\n\n\n");
       system( $makecbf );
     }
 
-    my $alignexe = "${ANTSPATH}/antsIntermodalityIntrasubject.sh -d 3 -t 2 -a $cbf -i $meanM0 -r $ref -R $anat -x $mask $warpflag -o ${outdir}${dirname}${outname}${outid} -T $template";
+    my $alignexe = "antsIntermodalityIntrasubject.sh -d 3 -t 2 -a $cbf -i $meanM0 -r $ref -R $anat -x $mask $warpflag -o ${outdir}${dirname}${outname}${outid} -T $template";
     print( "$alignexe\n");
 
     system( $alignexe );
@@ -391,23 +389,23 @@ for my $boldfile ( @$boldfiles ) {
   if ( ! -e "$meanbold" ) {
 
   # Slice timing correction
-  my $stc = "${ANTSPATH}/ImageMath 4 $bold SliceTimingCorrection $boldfile 0 bspline";
+  my $stc = "ImageMath 4 $bold SliceTimingCorrection $boldfile 0 bspline";
   system($stc);
 
   # Motion correction
-  system("${ANTSPATH}/antsMotionCorr -d 3 -a $bold -o $meanbold");
-  system("${ANTSPATH}/antsMotionCorr -d 3 -o [ ${obase}, $bold, $meanbold ] -u 1 -m mi[ $meanbold, $bold, 1, 32, Regular, 0.1 ] -t Affine[0.2] -i 25 -e 1 -f 1 -s 0 -l 0 -u 1");
+  system("antsMotionCorr -d 3 -a $bold -o $meanbold");
+  system("antsMotionCorr -d 3 -o [ ${obase}, $bold, $meanbold ] -u 1 -m mi[ $meanbold, $bold, 1, 32, Regular, 0.1 ] -t Affine[0.2] -i 25 -e 1 -f 1 -s 0 -l 0 -u 1");
 
 
-  system("${ANTSPATH}/ImageMath 3 $ref m $anat $mask" );
-  my $res = "${ANTSPATH}/ResampleImageBySpacing 3 $ref $ref 2.0 2.0 2.0";
+  system("ImageMath 3 $ref m $anat $mask" );
+  my $res = "ResampleImageBySpacing 3 $ref $ref 2.0 2.0 2.0";
   system($res);
   }
 
-  my $alignexe = "${ANTSPATH}/antsIntermodalityIntrasubject.sh -d 3 -t 2 -i $meanbold -r $ref -R $anat -x $mask $warpflag -o ${outdir}${dirname}${outname}${outid} -T $template";
+  my $alignexe = "antsIntermodalityIntrasubject.sh -d 3 -t 2 -i $meanbold -r $ref -R $anat -x $mask $warpflag -o ${outdir}${dirname}${outname}${outid} -T $template";
   system( $alignexe );
 
-  system("${ANTSPATH}/antsMotionCorrStats -x ${outdir}${dirname}${outname}${outid}_brainmask.nii.gz -m ${outdir}${dirname}${outname}${outid}_MOCOparams.csv -0 ${outdir}${dirname}${outname}${outid}_MOCOstats.csv -f 1");
+  system("antsMotionCorrStats -x ${outdir}${dirname}${outname}${outid}_brainmask.nii.gz -m ${outdir}${dirname}${outname}${outid}_MOCOparams.csv -0 ${outdir}${dirname}${outname}${outid}_MOCOstats.csv -f 1");
 
   }
 }
@@ -438,22 +436,22 @@ for my $rsboldfile ( @$rsboldfiles ) {
 
 
   # Motion correction
-  system("${ANTSPATH}/antsMotionCorr -d 3 -a $rsboldfile -o $meanbold");
-  print("${ANTSPATH}/antsMotionCorr -d 3 -o [ ${obase}, $bold, $meanbold ] -u 1 -m mi[ $meanbold, $rsboldfile, 1, 32, Regular, 0.1 ] -t Affine[0.2] -i 25 -e 1 -f 1 -s 0 -l 0 -u 1 \n");
-  system("${ANTSPATH}/antsMotionCorr -d 3 -o [ ${obase}, $bold, $meanbold ] -m mi[ $meanbold, $rsboldfile, 1, 32, Regular, 0.1 ] -t Affine[ 0.2 ] -i 25 -e 1 -f 1 -s 0 -l 0 -u 1");
+  system("antsMotionCorr -d 3 -a $rsboldfile -o $meanbold");
+  print("antsMotionCorr -d 3 -o [ ${obase}, $bold, $meanbold ] -u 1 -m mi[ $meanbold, $rsboldfile, 1, 32, Regular, 0.1 ] -t Affine[0.2] -i 25 -e 1 -f 1 -s 0 -l 0 -u 1 \n");
+  system("antsMotionCorr -d 3 -o [ ${obase}, $bold, $meanbold ] -m mi[ $meanbold, $rsboldfile, 1, 32, Regular, 0.1 ] -t Affine[ 0.2 ] -i 25 -e 1 -f 1 -s 0 -l 0 -u 1");
 
 
-  system("${ANTSPATH}/ImageMath 3 $ref m $anat $mask" );
-  my $res = "${ANTSPATH}/ResampleImageBySpacing 3 $ref $ref 2.0 2.0 2.0";
+  system("ImageMath 3 $ref m $anat $mask" );
+  my $res = "ResampleImageBySpacing 3 $ref $ref 2.0 2.0 2.0";
   system($res);
   }
 
-  my $alignexe = "${ANTSPATH}/antsIntermodalityIntrasubject.sh -d 3 -t 2 -i $meanbold -r $ref -R $anat -x $mask $warpflag -o ${outdir}${dirname}${outname}${outid} -T $template";
+  my $alignexe = "antsIntermodalityIntrasubject.sh -d 3 -t 2 -i $meanbold -r $ref -R $anat -x $mask $warpflag -o ${outdir}${dirname}${outname}${outid} -T $template";
   system( $alignexe );
 
-  system("${ANTSPATH}/antsMotionCorrStats -x ${outdir}${dirname}${outname}${outid}brainmask.nii.gz -m ${outdir}${dirname}${outname}${outid}MOCOparams.csv -o ${outdir}${dirname}${outname}${outid}MOCOStatsFramewise.csv -f 1");
+  system("antsMotionCorrStats -x ${outdir}${dirname}${outname}${outid}brainmask.nii.gz -m ${outdir}${dirname}${outname}${outid}MOCOparams.csv -o ${outdir}${dirname}${outname}${outid}MOCOStatsFramewise.csv -f 1");
 
-  system("${ANTSPATH}/antsMotionCorrStats -x ${outdir}${dirname}${outname}${outid}brainmask.nii.gz -m ${outdir}${dirname}${outname}${outid}MOCOparams.csv -o ${outdir}${dirname}${outname}${outid}MOCOStatsReference.csv -f 0");
+  system("antsMotionCorrStats -x ${outdir}${dirname}${outname}${outid}brainmask.nii.gz -m ${outdir}${dirname}${outname}${outid}MOCOparams.csv -o ${outdir}${dirname}${outname}${outid}MOCOStatsReference.csv -f 0");
   }
 }
 
diff --git a/Scripts/antsRegistrationSpaceTime.sh b/Scripts/antsRegistrationSpaceTime.sh
index ab946b1e..e92a213d 100755
--- a/Scripts/antsRegistrationSpaceTime.sh
+++ b/Scripts/antsRegistrationSpaceTime.sh
@@ -5,40 +5,11 @@ VERSION="0.0.0 test"
 # trap keyboard interrupt (control-c)
 trap control_c SIGINT
 
-function setPath {
-    cat <<SETPATH
+ANTS=antsRegistration
 
---------------------------------------------------------------------------------------
-Error locating ANTS
---------------------------------------------------------------------------------------
-It seems that the ANTSPATH environment variable is not set. Please add the ANTSPATH
-variable. This can be achieved by editing the .bash_profile in the home directory.
-Add:
-
-ANTSPATH=/home/yourname/bin/ants/
-
-Or the correct location of the ANTS binaries.
-
-Alternatively, edit this script ( `basename $0` ) to set up this parameter correctly.
-
-SETPATH
-    exit 1
-}
-
-# Uncomment the line below in case you have not set the ANTSPATH variable in your environment.
-# export ANTSPATH=${ANTSPATH:="$HOME/bin/ants/"} # EDIT THIS
-
-#ANTSPATH=YOURANTSPATH
-if [[ ${#ANTSPATH} -le 3 ]];
+if ! command -v ${ANTS} &> /dev/null
   then
-    setPath >&2
-  fi
-
-ANTS=${ANTSPATH}/antsRegistration
-
-if [[ ! -s ${ANTS} ]];
-  then
-    echo "antsRegistration program can't be found. Please (re)define \$ANTSPATH in your environment."
+    echo "antsRegistration program can't be found. Please (re)define \$PATH in your environment."
     exit
   fi
 
@@ -171,8 +142,6 @@ function reportMappingParameters {
 --------------------------------------------------------------------------------------
  Mapping parameters
 --------------------------------------------------------------------------------------
- ANTSPATH is $ANTSPATH
-
  Dimensionality:           $DIM
  Output name prefix:       $OUTPUTNAME
  Fixed images:             ${FIXEDIMAGES[@]}
diff --git a/Scripts/antsRegistrationSyN.sh b/Scripts/antsRegistrationSyN.sh
index dcfa8c50..0d13713a 100755
--- a/Scripts/antsRegistrationSyN.sh
+++ b/Scripts/antsRegistrationSyN.sh
@@ -5,40 +5,11 @@ VERSION="0.0.0 test"
 # trap keyboard interrupt (control-c)
 trap control_c SIGINT
 
-function setPath {
-    cat <<SETPATH
+ANTS=antsRegistration
 
---------------------------------------------------------------------------------------
-Error locating ANTS
---------------------------------------------------------------------------------------
-It seems that the ANTSPATH environment variable is not set. Please add the ANTSPATH
-variable. This can be achieved by editing the .bash_profile in the home directory.
-Add:
-
-ANTSPATH=/home/yourname/bin/ants/
-
-Or the correct location of the ANTS binaries.
-
-Alternatively, edit this script ( `basename $0` ) to set up this parameter correctly.
-
-SETPATH
-    exit 1
-}
-
-# Uncomment the line below in case you have not set the ANTSPATH variable in your environment.
-# export ANTSPATH=${ANTSPATH:="$HOME/bin/ants/"} # EDIT THIS
-
-#ANTSPATH=YOURANTSPATH
-if [[ ${#ANTSPATH} -le 3 ]];
+if ! command -v ${ANTS} &> /dev/null
   then
-    setPath >&2
-  fi
-
-ANTS=${ANTSPATH}/antsRegistration
-
-if [[ ! -s ${ANTS} ]];
-  then
-    echo "antsRegistration program can't be found. Please (re)define \$ANTSPATH in your environment."
+    echo "antsRegistration program can't be found. Please (re)define \$PATH in your environment."
     exit
   fi
 
@@ -243,8 +214,6 @@ function reportMappingParameters {
 --------------------------------------------------------------------------------------
  Mapping parameters
 --------------------------------------------------------------------------------------
- ANTSPATH is $ANTSPATH
-
  Dimensionality:           $DIM
  Output name prefix:       $OUTPUTNAME
  Fixed images:             ${FIXEDIMAGES[@]}
@@ -465,7 +434,7 @@ reportMappingParameters
 
 ISLARGEIMAGE=0
 
-SIZESTRING=$( ${ANTSPATH}/PrintHeader ${FIXEDIMAGES[0]} 2 )
+SIZESTRING=$( PrintHeader ${FIXEDIMAGES[0]} 2 )
 SIZESTRING="${SIZESTRING%\\n}"
 SIZE=( `echo $SIZESTRING | tr 'x' ' '` )
 
diff --git a/Scripts/antsRegistrationSyNQuick.sh b/Scripts/antsRegistrationSyNQuick.sh
index 83beedb9..984ebbff 100755
--- a/Scripts/antsRegistrationSyNQuick.sh
+++ b/Scripts/antsRegistrationSyNQuick.sh
@@ -5,40 +5,11 @@ VERSION="0.0.0 test"
 # trap keyboard interrupt (control-c)
 trap control_c SIGINT
 
-function setPath {
-    cat <<SETPATH
+ANTS=antsRegistration
 
---------------------------------------------------------------------------------------
-Error locating ANTS
---------------------------------------------------------------------------------------
-It seems that the ANTSPATH environment variable is not set. Please add the ANTSPATH
-variable. This can be achieved by editing the .bash_profile in the home directory.
-Add:
-
-ANTSPATH=/home/yourname/bin/ants/
-
-Or the correct location of the ANTS binaries.
-
-Alternatively, edit this script ( `basename $0` ) to set up this parameter correctly.
-
-SETPATH
-    exit 1
-}
-
-# Uncomment the line below in case you have not set the ANTSPATH variable in your environment.
-# export ANTSPATH=${ANTSPATH:="$HOME/bin/ants/"} # EDIT THIS
-
-#ANTSPATH=YOURANTSPATH
-if [[ ${#ANTSPATH} -le 3 ]];
+if ! command -v ${ANTS} &> /dev/null
   then
-    setPath >&2
-  fi
-
-ANTS=${ANTSPATH}/antsRegistration
-
-if [[ ! -s ${ANTS} ]];
-  then
-    echo "antsRegistration program can't be found. Please (re)define \$ANTSPATH in your environment."
+    echo "antsRegistration program can't be found. Please (re)define \$PATH in your environment."
     exit
   fi
 
@@ -246,8 +217,6 @@ function reportMappingParameters {
 --------------------------------------------------------------------------------------
  Mapping parameters
 --------------------------------------------------------------------------------------
- ANTSPATH is $ANTSPATH
-
  Dimensionality:           $DIM
  Output name prefix:       $OUTPUTNAME
  Fixed images:             ${FIXEDIMAGES[@]}
@@ -469,7 +438,7 @@ reportMappingParameters
 
 ISLARGEIMAGE=0
 
-SIZESTRING=$( ${ANTSPATH}/PrintHeader ${FIXEDIMAGES[0]} 2 )
+SIZESTRING=$( PrintHeader ${FIXEDIMAGES[0]} 2 )
 SIZESTRING="${SIZESTRING%\\n}"
 SIZE=( `echo $SIZESTRING | tr 'x' ' '` )
 
diff --git a/Scripts/antsaffine.sh b/Scripts/antsaffine.sh
index 2f0b6afa..3c900b74 100755
--- a/Scripts/antsaffine.sh
+++ b/Scripts/antsaffine.sh
@@ -1,11 +1,8 @@
 #!/bin/bash
 
-if [[ -z ${ANTSPATH} ]] ; then
-  echo "Environment variable ANTSPATH must be defined"
-  exit 1
-fi
-if [[ ! -f "${ANTSPATH}/ANTS" ]] ; then
-  echo "Cannot find the ANTS program. Please \(re\)define \$ANTSPATH in your environment."
+if ! command -v ANTS &> /dev/null
+then
+  echo "Cannot find the ANTS program. Please \(re\)define \$PATH in your environment."
   exit 1
 fi
 
@@ -15,24 +12,10 @@ if [ $NUMPARAMS -lt 3 ]
 then
 echo " USAGE ::  "
 echo "  sh   antsaffine.sh  ImageDimension  fixed.ext  moving.ext  OPTIONAL-OUTPREFIX   PURELY-RIGID  "
-echo " be sure to set ANTSPATH environment variable "
 echo " affine only registration "
 exit
 fi
 
-#ANTSPATH=YOURANTSPATH
-if [  ${#ANTSPATH} -le 0 ]
-then
-echo " Please set ANTSPATH=LocationOfYourAntsBinaries "
-echo " Either set this in your profile or directly, here in the script. "
-echo " For example : "
-echo $ANTSPATH
-echo " ANTSPATH=/home/yourname/bin/ants/ "
-exit
-else
-echo " ANTSPATH is $ANTSPATH "
-fi
-
 #initialization, here, is unbiased
 DIM=$1
 
@@ -72,14 +55,13 @@ then
 fi
 echo " Will this mapping be purely rigid?  $RIGID "
 
-echo  " ANTSPATH  is $ANTSPATH     "
  #below, some affine options
   #--MI-option 16x8000 #-a InitAffine.txt --continue-affine 0
 
-exe=" ${ANTSPATH}/ANTS $DIM -m  MI[ ${FIXED},${MOVING},1,32 ] -o ${OUTPUTNAME}   -i 0   --use-Histogram-Matching --number-of-affine-iterations 10000x10000x10000x10000x10000  $RIGID   "
+exe=" ANTS $DIM -m  MI[ ${FIXED},${MOVING},1,32 ] -o ${OUTPUTNAME}   -i 0   --use-Histogram-Matching --number-of-affine-iterations 10000x10000x10000x10000x10000  $RIGID   "
 
  echo " $exe "
 
   $exe
 
-    ${ANTSPATH}/WarpImageMultiTransform $DIM  $MOVING  ${OUTPUTNAME}deformed.nii.gz ${OUTPUTNAME}Affine.txt  -R ${FIXED}
+    WarpImageMultiTransform $DIM  $MOVING  ${OUTPUTNAME}deformed.nii.gz ${OUTPUTNAME}Affine.txt  -R ${FIXED}
diff --git a/Scripts/antsdeformationmag.sh b/Scripts/antsdeformationmag.sh
index be6ac259..925429ae 100755
--- a/Scripts/antsdeformationmag.sh
+++ b/Scripts/antsdeformationmag.sh
@@ -1,9 +1,9 @@
 #!/bin/bash
 NUMPARAMS=$#
-if [ $NUMPARAMS -lt 4 ]
+if [ $NUMPARAMS -lt 3 ]
 then
 echo " USAGE ::  "
-echo " $0   inWarp WhichTypeOfMagnitude outputmagnitudeimage.nii  ANTSPATH "
+echo " $0   inWarp WhichTypeOfMagnitude outputmagnitudeimage.nii "
 echo " WhichTypeOfMagnitude ==  Laplacian Grad  Euclidean "
 echo " the numbers that come out of this depend on some itk filters being dimensionally correct and consistent. "
 echo " this may not be the case -- however, relative values should be ok , e.g comparing Grad values to Grad values etc "
@@ -13,13 +13,12 @@ fi
 inwarp=$1
 whichmag=$2
 magimage=$3
-ANTSPATH=$4
-dimarr=(`${ANTSPATH}/PrintHeader ${inwarp}xvec.nii.gz  | grep Spacing | grep , | wc `)
+dimarr=(`PrintHeader ${inwarp}xvec.nii.gz  | grep Spacing | grep , | wc `)
 DIM=${dimarr[0]}
 let DIM=${DIM}+1
 # multiply some image of the right size by 0 to make the initial magnitude image
-${ANTSPATH}/ImageMath  $DIM  $magimage m  ${inwarp}xvec.nii.gz 0
-${ANTSPATH}/ImageMath  $DIM  ${magimage}temp.nii.gz m  ${inwarp}xvec.nii.gz 0
+ImageMath  $DIM  $magimage m  ${inwarp}xvec.nii.gz 0
+ImageMath  $DIM  ${magimage}temp.nii.gz m  ${inwarp}xvec.nii.gz 0
 ok=0
 for  x in  x y z
 do
@@ -30,28 +29,28 @@ if [ $whichmag == Laplacian ]
 then
 echo " Laplacian $x "
 ok=1
-${ANTSPATH}/ImageMath  $DIM  ${magimage}temp.nii.gz Laplacian  ${inwarp}${x}vec.nii.gz 1.0 0
+ImageMath  $DIM  ${magimage}temp.nii.gz Laplacian  ${inwarp}${x}vec.nii.gz 1.0 0
 elif [ $whichmag == Grad ]
 then
 echo " Grad $x "
 ok=1
-${ANTSPATH}/ImageMath  $DIM  ${magimage}temp.nii.gz Grad ${inwarp}${x}vec.nii.gz 1.0  0
+ImageMath  $DIM  ${magimage}temp.nii.gz Grad ${inwarp}${x}vec.nii.gz 1.0  0
 #ImageMath  $DIM  temp.nii.gz m temp.nii.gz temp.nii.gz
 elif [ $whichmag == Euclidean ]
 then
 echo " Euclidean $x "
 ok=1
-${ANTSPATH}/ImageMath  $DIM  ${magimage}temp.nii.gz m  ${inwarp}${x}vec.nii.gz ${inwarp}${x}vec.nii.gz
+ImageMath  $DIM  ${magimage}temp.nii.gz m  ${inwarp}${x}vec.nii.gz ${inwarp}${x}vec.nii.gz
 fi
 # add the xvec magnitude to the magimage
-${ANTSPATH}/ImageMath  $DIM  $magimage  +  $magimage ${magimage}temp.nii.gz
+ImageMath  $DIM  $magimage  +  $magimage ${magimage}temp.nii.gz
 fi # ifz
 done #loop
 if [ $ok -eq 1 ]
 then
 # take the square root
-${ANTSPATH}/ImageMath  $DIM  $magimage ^ $magimage 0.5
-${ANTSPATH}/MeasureMinMaxMean $DIM $magimage
+ImageMath  $DIM  $magimage ^ $magimage 0.5
+MeasureMinMaxMean $DIM $magimage
 #thus,
 #magimage=sqrt( x*x + y*y + z*z )
 else
diff --git a/Scripts/antswithdt.sh b/Scripts/antswithdt.sh
index 835c0dbe..260f0b3e 100755
--- a/Scripts/antswithdt.sh
+++ b/Scripts/antswithdt.sh
@@ -3,12 +3,10 @@
 NUMPARAMS=$#
 
 MAXITERATIONS=30x90x20
-export ANTSPATH=${ANTSPATH:="$HOME/bin/ants/"}
 if [ $NUMPARAMS -lt 3 ]
 then
 echo " USAGE ::  "
 echo "  sh   ants.sh  ImageDimension  fixed.ext  moving.ext Subject/Moving-DT-To-Deform-To-Fixed-Image  OPTIONAL-Subject/Moving-BZero-To-DistortionCorrect-To-Moving-T1-Image "
-echo " be sure to set ANTSPATH environment variable "
 echo " Max-Iterations in form :    JxKxL where "
 echo "  J = max iterations at coarsest resolution (here, reduce by power of 2^2) "
 echo " K = middle resolution iterations ( here, reduce by power of 2 ) "
@@ -24,12 +22,9 @@ echo " We use the cross-correlation to perform the distortion correction. "
 echo " Some parameter tuning may be required, depending on the distortions present in your acquisition. "
 exit
 fi
-if [ ${#ANTSPATH} -le 3 ] ; then
-  echo we guess at your ants path
-  export ANTSPATH=${ANTSPATH:="$HOME/bin/ants/"} # EDIT THIS
-fi
-if [ ! -s ${ANTSPATH}/ANTS ] ; then
-  echo we cant find the ANTS program -- does not seem to exist.  please \(re\)define \$ANTSPATH in your environment.
+if ! command -v ANTS &> /dev/null
+then
+  echo we cant find the ANTS program -- does not seem to exist.  please \(re\)define \$PATH in your environment.
   exit
 fi
 
@@ -91,7 +86,7 @@ fi
 if  [ ${#MOVINGDT} -gt 3 ]
 then
 echo " The BZero DOES NOT EXIST : Using FA Instead!!"
-${ANTSPATH}/ImageMath 3 ${OUTPUTNAME}_fa.nii TensorFA  $MOVINGDT
+ImageMath 3 ${OUTPUTNAME}_fa.nii TensorFA  $MOVINGDT
 MOVINGBZ=${OUTPUTNAME}_fa.nii
 fi
 
@@ -107,7 +102,6 @@ fi
 #echo " $METRICPARAMS  &  $METRIC "
 #exit
 
-echo  " ANTSPATH  $ANTSPATH "
 echo " Mapping Parameters  :: "
 echo  " Transformation is:  $TRANSFORMATION "
 echo " MaxIterations :   $MAXITERATIONS "
@@ -124,26 +118,26 @@ echo " "
 
 # first, do distortion correction of MOVINGDT to MOVING
 # use the B0 image
-${ANTSPATH}/ANTS 3 -m CC[ ${MOVINGBZ},${MOVING},1,2 ]  -o ${OUTPUTNAME}distcorr  -r Gauss[ 3,0 ] -t SyN[ 0.25 ]  -i 25x20x0  --number-of-affine-iterations 10000x10000x10000
+ANTS 3 -m CC[ ${MOVINGBZ},${MOVING},1,2 ]  -o ${OUTPUTNAME}distcorr  -r Gauss[ 3,0 ] -t SyN[ 0.25 ]  -i 25x20x0  --number-of-affine-iterations 10000x10000x10000
 
-${ANTSPATH}/WarpImageMultiTransform 3 $MOVING   ${OUTPUTNAME}distcorr.nii.gz ${OUTPUTNAME}distcorrWarp.nii.gz ${OUTPUTNAME}distcorrAffine.txt  -R $MOVINGBZ
+WarpImageMultiTransform 3 $MOVING   ${OUTPUTNAME}distcorr.nii.gz ${OUTPUTNAME}distcorrWarp.nii.gz ${OUTPUTNAME}distcorrAffine.txt  -R $MOVINGBZ
 #exit
 
 if [[ ! -s ${OUTPUTNAME}Affine.txt ]] ; then
-  sh ${ANTSPATH}/ants.sh $DIM $FIXED $MOVING ${OUTPUTNAME}
+  sh ants.sh $DIM $FIXED $MOVING ${OUTPUTNAME}
 fi
 
 if  [[ -s ${MOVINGDT} ]] &&  [[  -s ${OUTPUTNAME}Affine.txt ]] ; then
     DTDEF=${OUTPUTNAME}DTdeformed.nii.gz
     FIXEDSUB=${OUTPUTNAME}fixedsub.nii.gz
-#    ${ANTSPATH}/ResampleImageBySpacing 3 $FIXED $FIXEDSUB 2 2 2
+#    ResampleImageBySpacing 3 $FIXED $FIXEDSUB 2 2 2
     FIXEDSUB=$FIXED
     echo " Warp DT "
-    ${ANTSPATH}/WarpTensorImageMultiTransform $DIM  $MOVINGDT    $DTDEF ${OUTPUTNAME}Warp.nii.gz ${OUTPUTNAME}Affine.txt  -i  ${OUTPUTNAME}distcorrAffine.txt   ${OUTPUTNAME}distcorrInverseWarp.nii.gz   -R $FIXEDSUB
+    WarpTensorImageMultiTransform $DIM  $MOVINGDT    $DTDEF ${OUTPUTNAME}Warp.nii.gz ${OUTPUTNAME}Affine.txt  -i  ${OUTPUTNAME}distcorrAffine.txt   ${OUTPUTNAME}distcorrInverseWarp.nii.gz   -R $FIXEDSUB
 
     COMPWARP=${OUTPUTNAME}DTwarp.nii.gz
-    ${ANTSPATH}/ComposeMultiTransform $DIM $COMPWARP   -R ${FIXEDSUB}  ${OUTPUTNAME}Warp.nii.gz ${OUTPUTNAME}Affine.txt  -i  ${OUTPUTNAME}distcorrAffine.txt   ${OUTPUTNAME}distcorrInverseWarp.nii.gz
-    ${ANTSPATH}/ReorientTensorImage 3 $DTDEF  $DTDEF  $COMPWARP
+    ComposeMultiTransform $DIM $COMPWARP   -R ${FIXEDSUB}  ${OUTPUTNAME}Warp.nii.gz ${OUTPUTNAME}Affine.txt  -i  ${OUTPUTNAME}distcorrAffine.txt   ${OUTPUTNAME}distcorrInverseWarp.nii.gz
+    ReorientTensorImage 3 $DTDEF  $DTDEF  $COMPWARP
 
 fi
 
diff --git a/Scripts/basic_ants_example.sh b/Scripts/basic_ants_example.sh
index 55d75508..3cd7fbd4 100755
--- a/Scripts/basic_ants_example.sh
+++ b/Scripts/basic_ants_example.sh
@@ -13,12 +13,9 @@ echo these are BASIC examples --- not intended to illustrate optimal usage but p
 exit
 fi
 #
-if [ ${#ANTSPATH} -le 3 ] ; then
-  echo we guess at your ants path
-  export ANTSPATH=${ANTSPATH:="$HOME/bin/ants/"} # EDIT THIS
-fi
-if [ ! -s ${ANTSPATH}/ANTS ] ; then
-  echo we cant find the ANTS program -- does not seem to exist.  please \(re\)define \$ANTSPATH in your environment.
+if ! command -v ANTS &> /dev/null
+then
+  echo we cant find the ANTS program -- does not seem to exist.  please \(re\)define \$PATH in your environment.
   exit
 fi
 #
@@ -64,10 +61,10 @@ TRAN=$BGREEDYSYN  # choose a transformation
 if [[ $OPT == "Reg" ]] ; then
 
 # run the registration
-${ANTSPATH}/ANTS $DIM -o $OUTPUTNAME $ITS $TRAN $INT
+ANTS $DIM -o $OUTPUTNAME $ITS $TRAN $INT
 # this is how you apply the output transformation
-${ANTSPATH}/WarpImageMultiTransform $DIM ${II} ${OUTPUTNAME}IItoJJ.nii.gz -R ${JJ} $INVW
-${ANTSPATH}/WarpImageMultiTransform $DIM ${JJ} ${OUTPUTNAME}JJtoII.nii.gz -R ${II} $FWDW
+WarpImageMultiTransform $DIM ${II} ${OUTPUTNAME}IItoJJ.nii.gz -R ${JJ} $INVW
+WarpImageMultiTransform $DIM ${JJ} ${OUTPUTNAME}JJtoII.nii.gz -R ${II} $FWDW
 
 elif [[ $OPT == "RegSegPSE" ]] ; then
 
@@ -78,21 +75,21 @@ JJSEG=${OUTPUTNAME}B_seg.nii.gz
 #
 # get masks for atropos
 #
-${ANTSPATH}/ThresholdImage $DIM $II $IISEG 1 1.e9
-${ANTSPATH}/ThresholdImage $DIM $JJ $JJSEG 1 1.e9
+ThresholdImage $DIM $II $IISEG 1 1.e9
+ThresholdImage $DIM $JJ $JJSEG 1 1.e9
 AtroposParams=" -d $DIM -m [ 0.1,1x1 ] -c [ 5,0 ] -i kmeans[ 3 ] "
-${ANTSPATH}/Atropos $AtroposParams -a $II -o $IISEG  -x $IISEG
-${ANTSPATH}/Atropos $AtroposParams -a $JJ -o $JJSEG  -x $JJSEG
+Atropos $AtroposParams -a $II -o $IISEG  -x $IISEG
+Atropos $AtroposParams -a $JJ -o $JJSEG  -x $JJSEG
 # compute some segmentations and use them in labelguided mapping
 LABELGUIDED=" -m PSE[ ${II},${JJ},${IISEG},${JJSEG},0.75,0.1,25,0,10 ] "
 #
-${ANTSPATH}/ANTS $DIM -o ${OUTPUTNAME} $ITS $TRAN $INT $LABELGUIDED
-${ANTSPATH}/WarpImageMultiTransform $DIM ${II} ${OUTPUTNAME}IItoJJ.nii.gz -R ${JJ} $INVW
-${ANTSPATH}/WarpImageMultiTransform $DIM ${JJ} ${OUTPUTNAME}JJtoII.nii.gz -R ${II} $FWDW
+ANTS $DIM -o ${OUTPUTNAME} $ITS $TRAN $INT $LABELGUIDED
+WarpImageMultiTransform $DIM ${II} ${OUTPUTNAME}IItoJJ.nii.gz -R ${JJ} $INVW
+WarpImageMultiTransform $DIM ${JJ} ${OUTPUTNAME}JJtoII.nii.gz -R ${II} $FWDW
 
 # now warp the labels in both directions
-${ANTSPATH}/WarpImageMultiTransform $DIM ${IISEG} ${OUTPUTNAME}IIsegtoJJseg.nii.gz -R ${JJ} $INVW --use-NN
-${ANTSPATH}/WarpImageMultiTransform $DIM ${JJSEG} ${OUTPUTNAME}JJsegtoIIseg.nii.gz -R ${II} $FWDW --use-NN
+WarpImageMultiTransform $DIM ${IISEG} ${OUTPUTNAME}IIsegtoJJseg.nii.gz -R ${JJ} $INVW --use-NN
+WarpImageMultiTransform $DIM ${JJSEG} ${OUTPUTNAME}JJsegtoIIseg.nii.gz -R ${II} $FWDW --use-NN
 
 
 elif [[ $OPT == "RegSegMSQ" ]] ; then
@@ -104,21 +101,21 @@ JJSEG=${OUTPUTNAME}B_seg.nii.gz
 #
 # get masks for atropos
 #
-${ANTSPATH}/ThresholdImage $DIM $II $IISEG 1 1.e9
-${ANTSPATH}/ThresholdImage $DIM $JJ $JJSEG 1 1.e9
+ThresholdImage $DIM $II $IISEG 1 1.e9
+ThresholdImage $DIM $JJ $JJSEG 1 1.e9
 AtroposParams=" -d $DIM -m [ 0.1,1x1 ] -c [ 5,0 ] -i kmeans[ 3 ] "
-${ANTSPATH}/Atropos $AtroposParams -a $II -o $IISEG  -x $IISEG
-${ANTSPATH}/Atropos $AtroposParams -a $JJ -o $JJSEG  -x $JJSEG
+Atropos $AtroposParams -a $II -o $IISEG  -x $IISEG
+Atropos $AtroposParams -a $JJ -o $JJSEG  -x $JJSEG
 # compute some segmentations and use them in labelguided mapping
 LABELGUIDED=" -m MSQ[ ${IISEG},${JJSEG},0.75 ] "
 #
-${ANTSPATH}/ANTS $DIM -o ${OUTPUTNAME} $ITS $TRAN $INT $LABELGUIDED
-${ANTSPATH}/WarpImageMultiTransform $DIM ${II} ${OUTPUTNAME}IItoJJ.nii.gz -R ${JJ} $INVW
-${ANTSPATH}/WarpImageMultiTransform $DIM ${JJ} ${OUTPUTNAME}JJtoII.nii.gz -R ${II} $FWDW
+ANTS $DIM -o ${OUTPUTNAME} $ITS $TRAN $INT $LABELGUIDED
+WarpImageMultiTransform $DIM ${II} ${OUTPUTNAME}IItoJJ.nii.gz -R ${JJ} $INVW
+WarpImageMultiTransform $DIM ${JJ} ${OUTPUTNAME}JJtoII.nii.gz -R ${II} $FWDW
 
 # now warp the labels in both directions
-${ANTSPATH}/WarpImageMultiTransform $DIM ${IISEG} ${OUTPUTNAME}IIsegtoJJseg.nii.gz -R ${JJ} $INVW --use-NN
-${ANTSPATH}/WarpImageMultiTransform $DIM ${JJSEG} ${OUTPUTNAME}JJsegtoIIseg.nii.gz -R ${II} $FWDW --use-NN
+WarpImageMultiTransform $DIM ${IISEG} ${OUTPUTNAME}IIsegtoJJseg.nii.gz -R ${JJ} $INVW --use-NN
+WarpImageMultiTransform $DIM ${JJSEG} ${OUTPUTNAME}JJsegtoIIseg.nii.gz -R ${II} $FWDW --use-NN
 
 
 elif [[ $OPT == "BTP" ]] ; then
@@ -128,15 +125,15 @@ elif [[ $OPT == "BTP" ]] ; then
 # such that it's more appropriate for your data.
 # call buildtemplateparallel.sh -h to get usage.
 #
-${ANTSPATH}/buildtemplateparallel.sh -d 2  -o ${OUTPUTNAME}BTP -c 0  $II $JJ
+buildtemplateparallel.sh -d 2  -o ${OUTPUTNAME}BTP -c 0  $II $JJ
 rm -r GR* *cfg
 
 TEM=${OUTPUTNAME}BTPtemplate.nii.gz
 NM1=` echo $JJ | cut -d '.' -f 1 `
 INVW=" -i ${OUTPUTNAME}BTP${NM1}Affine.txt ${OUTPUTNAME}BTP${NM1}InverseWarp.nii.gz "
 FWDW=" ${OUTPUTNAME}BTP${NM1}Warp.nii.gz ${OUTPUTNAME}BTP${NM1}Affine.txt "
-${ANTSPATH}/WarpImageMultiTransform $DIM ${JJ} ${OUTPUTNAME}JJtoTemplate.nii.gz -R $TEM $FWDW
-${ANTSPATH}/WarpImageMultiTransform $DIM $TEM ${OUTPUTNAME}TemplatetoJJ.nii.gz -R ${JJ} $INVW
+WarpImageMultiTransform $DIM ${JJ} ${OUTPUTNAME}JJtoTemplate.nii.gz -R $TEM $FWDW
+WarpImageMultiTransform $DIM $TEM ${OUTPUTNAME}TemplatetoJJ.nii.gz -R ${JJ} $INVW
 
 else
  echo unrecognized option $OPT
diff --git a/Scripts/buildtemplateparallel.sh b/Scripts/buildtemplateparallel.sh
index 0b322958..34372f6b 100755
--- a/Scripts/buildtemplateparallel.sh
+++ b/Scripts/buildtemplateparallel.sh
@@ -5,53 +5,25 @@ afftype=".txt"
 # trap keyboard interrupt (control-c)
 trap control_c SIGINT
 
-function setPath {
-    cat <<SETPATH
-
---------------------------------------------------------------------------------------
-Error locating ANTS
---------------------------------------------------------------------------------------
-It seems that the ANTSPATH environment variable is not set. Please add the ANTSPATH
-variable. This can be achieved by editing the .bash_profile in the home directory.
-Add:
-
-ANTSPATH=/home/yourname/bin/ants/
-
-Or the correct location of the ANTS binaries.
-
-Alternatively, edit this script ( `basename $0` ) to set up this parameter correctly.
-
-SETPATH
-    exit 1
-}
-
-# Uncomment the line below in case you have not set the ANTSPATH variable in your environment.
-# export ANTSPATH=${ANTSPATH:="$HOME/bin/ants/"} # EDIT THIS
-
-#ANTSPATH=YOURANTSPATH
-if [ ${#ANTSPATH} -le 3 ]
-    then
-    setPath >&2
-fi
-
-if [ ! -s ${ANTSPATH}/ANTS ] ; then
-  echo "ANTS program can't be found. Please (re)define \$ANTSPATH in your environment."
+if ! command -v ANTS &> /dev/null
+then
+  echo "ANTS program can't be found. Please (re)define \$PATH in your environment."
   exit
 fi
 
 # Test availability of helper scripts.
 # No need to test this more than once. Can reside outside of the main loop.
-ANTSSCRIPTNAME=${ANTSPATH}/antsIntroduction.sh
-PEXEC=${ANTSPATH}/ANTSpexec.sh
-SGE=${ANTSPATH}/waitForSGEQJobs.pl
-PBS=${ANTSPATH}/waitForPBSQJobs.pl
-XGRID=${ANTSPATH}/waitForXGridJobs.pl
-SLURM=${ANTSPATH}/waitForSlurmJobs.pl
+ANTSSCRIPTNAME=antsIntroduction.sh
+PEXEC=ANTSpexec.sh
+SGE=waitForSGEQJobs.pl
+PBS=waitForPBSQJobs.pl
+XGRID=waitForXGridJobs.pl
+SLURM=waitForSlurmJobs.pl
 
 fle_error=0
 for FLE in $ANTSSCRIPTNAME $PEXEC $SGE $XGRID $SLURM
   do
-  if [ ! -x $FLE ] ;
+    if ! command -v $FLE &> /dev/null
       then
       echo
       echo "--------------------------------------------------------------------------------------"
@@ -280,7 +252,7 @@ Optional arguments:
 
 Requirements:
 
-This scripts relies on the following scripts in your $ANTSPATH directory. The script
+This scripts relies on the following scripts in your $PATH. The script
 will terminate prematurely if these files are not present or are not executable.
 - antsIntroduction.sh
 - pexec.sh
@@ -332,8 +304,6 @@ function reportMappingParameters {
 --------------------------------------------------------------------------------------
  Mapping parameters
 --------------------------------------------------------------------------------------
- ANTSPATH is $ANTSPATH
-
  Dimensionality:			$DIM
  N4BiasFieldCorrection:			$N4CORRECT
  Similarity Metric:			$METRICTYPE
@@ -373,21 +343,21 @@ function shapeupdatetotemplate {
     echo "--------------------------------------------------------------------------------------"
     echo " shapeupdatetotemplate 1"
     echo "--------------------------------------------------------------------------------------"
-	${ANTSPATH}/AverageImages $dim ${template} 1 ${outputname}*formed.nii.gz
+	AverageImages $dim ${template} 1 ${outputname}*formed.nii.gz
 
     echo
     echo "--------------------------------------------------------------------------------------"
     echo " shapeupdatetotemplate 2"
     echo "--------------------------------------------------------------------------------------"
 
-	${ANTSPATH}/AverageImages $dim ${templatename}warp.nii.gz 0 `ls ${outputname}*Warp.nii.gz | grep -v "InverseWarp"`
+	AverageImages $dim ${templatename}warp.nii.gz 0 `ls ${outputname}*Warp.nii.gz | grep -v "InverseWarp"`
 
     echo
     echo "--------------------------------------------------------------------------------------"
     echo " shapeupdatetotemplate 3"
     echo "--------------------------------------------------------------------------------------"
 
-	${ANTSPATH}/MultiplyImages $dim ${templatename}warp.nii.gz ${gradientstep} ${templatename}warp.nii.gz
+	MultiplyImages $dim ${templatename}warp.nii.gz ${gradientstep} ${templatename}warp.nii.gz
 
 
     echo
@@ -409,16 +379,16 @@ function shapeupdatetotemplate {
 #      ANTSAverage3DAffine ${templatename}Affine${afftype} ${outputname}*Affine${afftype}
 #    fi
 
-    ${ANTSPATH}/AverageAffineTransform ${dim} ${templatename}Affine${afftype} ${outputname}*Affine${afftype}
-    ${ANTSPATH}/WarpImageMultiTransform ${dim} ${templatename}warp.nii.gz ${templatename}warp.nii.gz -i  ${templatename}Affine${afftype} -R ${template}
-    ${ANTSPATH}/WarpImageMultiTransform ${dim} ${template} ${template} -i ${templatename}Affine${afftype} ${templatename}warp.nii.gz ${templatename}warp.nii.gz ${templatename}warp.nii.gz ${templatename}warp.nii.gz -R ${template}
+    AverageAffineTransform ${dim} ${templatename}Affine${afftype} ${outputname}*Affine${afftype}
+    WarpImageMultiTransform ${dim} ${templatename}warp.nii.gz ${templatename}warp.nii.gz -i  ${templatename}Affine${afftype} -R ${template}
+    WarpImageMultiTransform ${dim} ${template} ${template} -i ${templatename}Affine${afftype} ${templatename}warp.nii.gz ${templatename}warp.nii.gz ${templatename}warp.nii.gz ${templatename}warp.nii.gz -R ${template}
 
     echo
     echo "--------------------------------------------------------------------------------------"
     echo " shapeupdatetotemplate 6"
     echo "--------------------------------------------------------------------------------------"
     echo
-    ${ANTSPATH}/MeasureMinMaxMean ${dim} ${templatename}warp.nii.gz ${templatename}warplog.txt 1
+    MeasureMinMaxMean ${dim} ${templatename}warp.nii.gz ${templatename}warplog.txt 1
 
 
 }
@@ -797,7 +767,7 @@ if [ ${NINFILES} -eq 0 ]
 elif [[ ${NINFILES} -eq 1 ]]
     then
 
-    range=`${ANTSPATH}/ImageMath $TDIM abs nvols ${IMAGESETVARIABLE} | tail -1 | cut -d "," -f 4 | cut -d " " -f 2 | cut -d " ]" -f 1 `
+    range=`ImageMath $TDIM abs nvols ${IMAGESETVARIABLE} | tail -1 | cut -d "," -f 4 | cut -d " " -f 2 | cut -d " ]" -f 1 `
 
     if [ ${range} -eq 1 ] && [ ${TDIM} -ne 4 ]
 	then
@@ -829,7 +799,7 @@ elif [[ ${NINFILES} -eq 1 ]]
 	#split the 4D file into 3D elements
 	cp ${IMAGESETVARIABLE} ${tmpdir}/
 	cd ${tmpdir}/
- #       ${ANTSPATH}/ImageMath $TDIM vol0.nii.gz TimeSeriesSubset ${IMAGESETVARIABLE} ${range}
+ #       ImageMath $TDIM vol0.nii.gz TimeSeriesSubset ${IMAGESETVARIABLE} ${range}
 #	rm -f ${IMAGESETVARIABLE}
 
 	# selecting 16 volumes randomly from the timeseries for averaging, placing them in tmp/selection folder.
@@ -866,15 +836,15 @@ elif [[ ${NINFILES} -eq 1 ]]
 #			echo "Random number between $FLOOR and $range ---  $number"
 				if [ ${number} -lt 10 ]
 					then
-					${ANTSPATH}/ImageMath $TDIM selection/vol000${number}.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
+					ImageMath $TDIM selection/vol000${number}.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
 #					cp vol000${number}.nii.gz selection/
 				elif [ ${number} -ge 10 ] && [ ${number} -lt 100 ]
 					then
-					${ANTSPATH}/ImageMath $TDIM selection/vol00${number}.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
+					ImageMath $TDIM selection/vol00${number}.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
 #					cp vol00${number}.nii.gz selection/
 				elif [ ${number} -ge 100 ] && [ ${number} -lt 1000 ]
 					then
-					${ANTSPATH}/ImageMath $TDIM selection/vol0${number}.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
+					ImageMath $TDIM selection/vol0${number}.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
 #					cp vol0${number}.nii.gz selection/
 				fi
 
@@ -891,11 +861,11 @@ elif [[ ${NINFILES} -eq 1 ]]
 
 				if [ ${number} -lt 10 ]
 					then
-					${ANTSPATH}/ImageMath $TDIM selection/vol0.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
+					ImageMath $TDIM selection/vol0.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
 #					cp vol000${number}.nii.gz selection/
 				elif [ ${number} -ge 10 ] && [ ${number} -lt 100 ]
 					then
-					${ANTSPATH}/ImageMath $TDIM selection/vol0.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
+					ImageMath $TDIM selection/vol0.nii.gz ExtractSlice ${IMAGESETVARIABLE} ${number}
 #					cp vol00${number}.nii.gz selection/
 				fi
 			done
@@ -903,7 +873,7 @@ elif [[ ${NINFILES} -eq 1 ]]
 	elif [ ${range} -le ${nfmribins} ]
 		then
 
-		${ANTSPATH}/ImageMath selection/$TDIM vol0.nii.gz TimeSeriesSubset ${IMAGESETVARIABLE} ${range}
+		ImageMath selection/$TDIM vol0.nii.gz TimeSeriesSubset ${IMAGESETVARIABLE} ${range}
 #		cp *.nii.gz selection/
 
 	fi
@@ -924,7 +894,7 @@ if [ ! -s $REGTEMPLATE ]
     echo "--------------------------------------------------------------------------------------"
     echo " No initial template exists. Creating a population average image from the inputs."
     echo "--------------------------------------------------------------------------------------"
-    ${ANTSPATH}/AverageImages $DIM $TEMPLATE 1 $IMAGESETVARIABLE
+    AverageImages $DIM $TEMPLATE 1 $IMAGESETVARIABLE
 else
     echo
     echo "--------------------------------------------------------------------------------------"
@@ -958,8 +928,8 @@ if [ "$RIGID" -eq 1 ] ;
 
       BASENAME=` echo ${IMG} | cut -d '.' -f 1 `
 
-      exe=" ${ANTSPATH}/ANTS $DIM -m MI[ ${TEMPLATE},${IMG},1,32 ] -o rigid_${IMG} -i 0 --use-Histogram-Matching --number-of-affine-iterations 10000x10000x10000x10000x10000 $RIGIDTYPE"
-      exe2="${ANTSPATH}/WarpImageMultiTransform $DIM ${IMG} rigid_${IMG} rigid_${BASENAME}Affine${afftype} -R ${TEMPLATE}"
+      exe=" ANTS $DIM -m MI[ ${TEMPLATE},${IMG},1,32 ] -o rigid_${IMG} -i 0 --use-Histogram-Matching --number-of-affine-iterations 10000x10000x10000x10000x10000 $RIGIDTYPE"
+      exe2="WarpImageMultiTransform $DIM ${IMG} rigid_${IMG} rigid_${BASENAME}Affine${afftype} -R ${TEMPLATE}"
       pexe=" $exe >> job_${count}_metriclog.txt "
 
       qscript="job_${count}_qsub.sh"
@@ -977,12 +947,12 @@ if [ "$RIGID" -eq 1 ] ;
       echo "$exe2" >> $qscript
 
       if [ $DOQSUB -eq 1 ] ; then
-		id=`qsub -cwd -S /bin/bash -N antsBuildTemplate_rigid -v ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=1,LD_LIBRARY_PATH=$LD_LIBRARY_PATH,ANTSPATH=$ANTSPATH $QSUBOPTS $qscript | awk '{print $3}'`
+		id=`qsub -cwd -S /bin/bash -N antsBuildTemplate_rigid -v ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=1,LD_LIBRARY_PATH=$LD_LIBRARY_PATH $QSUBOPTS $qscript | awk '{print $3}'`
 		jobIDs="$jobIDs $id"
 		    sleep 0.5
       elif [ $DOQSUB -eq 4 ]; then
         echo "cp -R /jobtmp/pbstmp.\$PBS_JOBID/* ${currentdir}" >> $qscript;
-		id=`qsub -N antsrigid -v ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=1,LD_LIBRARY_PATH=$LD_LIBRARY_PATH,ANTSPATH=$ANTSPATH $QSUBOPTS -q $DEFQUEUE -l nodes=1:ppn=1 -l walltime=4:00:00 $qscript | awk '{print $1}'`
+		id=`qsub -N antsrigid -v ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=1,LD_LIBRARY_PATH=$LD_LIBRARY_PATH $QSUBOPTS -q $DEFQUEUE -l nodes=1:ppn=1 -l walltime=4:00:00 $qscript | awk '{print $1}'`
 		jobIDs="$jobIDs $id"
         sleep 0.5
       elif  [ $DOQSUB -eq 2 ] ; then
@@ -994,7 +964,7 @@ if [ "$RIGID" -eq 1 ] ;
         #echo "xgrid $XGRIDOPTS -job submit /bin/bash $qscript"
         jobIDs="$jobIDs $id"
       elif [[ $DOQSUB -eq 5 ]]; then
-        id=`sbatch --job-name=antsrigid --export=ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=1,LD_LIBRARY_PATH=$LD_LIBRARY_PATH,ANTSPATH=$ANTSPATH $QSUBOPTS --nodes=1 --cpus-per-task=1 --time=4:00:00 $qscript | rev | cut -f1 -d\ | rev`
+        id=`sbatch --job-name=antsrigid --export=ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=1,LD_LIBRARY_PATH=$LD_LIBRARY_PATH $QSUBOPTS --nodes=1 --cpus-per-task=1 --time=4:00:00 $qscript | rev | cut -f1 -d\ | rev`
         jobIDs="$jobIDs $id"
         sleep 0.5
       elif  [ $DOQSUB -eq 0 ] ; then
@@ -1015,7 +985,7 @@ if [ "$RIGID" -eq 1 ] ;
 	echo " Starting ANTS rigid registration on SGE cluster. Submitted $count jobs "
 	echo "--------------------------------------------------------------------------------------"
         # now wait for the jobs to finish. Rigid registration is quick, so poll queue every 60 seconds
-	${ANTSPATH}/waitForSGEQJobs.pl 1 60 $jobIDs
+	waitForSGEQJobs.pl 1 60 $jobIDs
 
 	# Returns 1 if there are errors
 	if [ ! $? -eq 0 ]; then
@@ -1032,7 +1002,7 @@ if [ "$RIGID" -eq 1 ] ;
 	echo " Starting ANTS rigid registration on PBS cluster. Submitted $count jobs "
 	echo "--------------------------------------------------------------------------------------"
         # now wait for the jobs to finish. Rigid registration is quick, so poll queue every 60 seconds
-	${ANTSPATH}/waitForPBSQJobs.pl 1 60 $jobIDs
+	waitForPBSQJobs.pl 1 60 $jobIDs
 
 	# Returns 1 if there are errors
 	if [ ! $? -eq 0 ]; then
@@ -1062,7 +1032,7 @@ if [ "$RIGID" -eq 1 ] ;
 	echo " Starting ANTS rigid registration on XGrid cluster. Submitted $count jobs "
 	echo "--------------------------------------------------------------------------------------"
         # now wait for the jobs to finish. Rigid registration is quick, so poll queue every 60 seconds
-	${ANTSPATH}/waitForXGridJobs.pl -xgridflags "$XGRIDOPTS" -verbose -delay 30 $jobIDs
+	waitForXGridJobs.pl -xgridflags "$XGRIDOPTS" -verbose -delay 30 $jobIDs
 	# Returns 1 if there are errors
 	if [ ! $? -eq 0 ]; then
 	    echo "XGrid submission failed - jobs went into error state"
@@ -1078,7 +1048,7 @@ if [ "$RIGID" -eq 1 ] ;
 	echo " Starting ANTS rigid registration on SLURM cluster. Submitted $count jobs "
 	echo "--------------------------------------------------------------------------------------"
         # now wait for the jobs to finish. Rigid registration is quick, so poll queue every 60 seconds
-	${ANTSPATH}/waitForSlurmJobs.pl 1 60 $jobIDs
+	waitForSlurmJobs.pl 1 60 $jobIDs
 
 	# Returns 1 if there are errors
 	if [ ! $? -eq 0 ]; then
@@ -1089,7 +1059,7 @@ if [ "$RIGID" -eq 1 ] ;
 
 
     # Update template
-    ${ANTSPATH}/AverageImages $DIM $TEMPLATE 1 $RIGID_IMAGESET
+    AverageImages $DIM $TEMPLATE 1 $RIGID_IMAGESET
 
     # cleanup and save output in seperate folder
 
@@ -1205,7 +1175,7 @@ while [  $i -lt ${ITERATIONLIMIT} ]
 
     # 6 submit to SGE (DOQSUB=1), PBS (DOQSUB=4), PEXEC (DOQSUB=2), XGrid (DOQSUB=3) or else run locally (DOQSUB=0)
     if [ $DOQSUB -eq 1 ]; then
-      id=`qsub -cwd -N antsBuildTemplate_deformable_${i} -S /bin/bash -v ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=1,LD_LIBRARY_PATH=$LD_LIBRARY_PATH,ANTSPATH=$ANTSPATH $QSUBOPTS $exe | awk '{print $3}'`
+      id=`qsub -cwd -N antsBuildTemplate_deformable_${i} -S /bin/bash -v ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=1,LD_LIBRARY_PATH=$LD_LIBRARY_PATH $QSUBOPTS $exe | awk '{print $3}'`
       jobIDs="$jobIDs $id"
       sleep 0.5
     elif [ $DOQSUB -eq 4 ]; then
@@ -1213,7 +1183,7 @@ while [  $i -lt ${ITERATIONLIMIT} ]
       echo "$SCRIPTPREPEND" > $qscript
       echo "$exe" >> $qscript
       echo "cp -R /jobtmp/pbstmp.\$PBS_JOBID/* ${currentdir}" >> $qscript;
-      id=`qsub -N antsdef${i} -v ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=1,LD_LIBRARY_PATH=$LD_LIBRARY_PATH,ANTSPATH=$ANTSPATH -q $DEFQUEUE -l nodes=1:ppn=1 -l walltime=4:00:00 $QSUBOPTS $qscript | awk '{print $1}'`
+      id=`qsub -N antsdef${i} -v ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=1,LD_LIBRARY_PATH=$LD_LIBRARY_PATH -q $DEFQUEUE -l nodes=1:ppn=1 -l walltime=4:00:00 $QSUBOPTS $qscript | awk '{print $1}'`
       jobIDs="$jobIDs $id"
       sleep 0.5
     elif [ $DOQSUB -eq 2 ] ; then
@@ -1232,7 +1202,7 @@ while [  $i -lt ${ITERATIONLIMIT} ]
       echo '#!/bin/sh' > $qscript
       echo -e "$SCRIPTPREPEND" >> $qscript
       echo -e "$exe" >> $qscript
-      id=`sbatch --mem-per-cpu=32768M --job-name=antsdef${i} --export=ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=1,LD_LIBRARY_PATH=$LD_LIBRARY_PATH,ANTSPATH=$ANTSPATH --nodes=1 --cpus-per-task=1 --time=4:00:00 $QSUBOPTS $qscript | rev | cut -f1 -d\ | rev`
+      id=`sbatch --mem-per-cpu=32768M --job-name=antsdef${i} --export=ITK_GLOBAL_DEFAULT_NUMBER_OF_THREADS=1,LD_LIBRARY_PATH=$LD_LIBRARY_PATH --nodes=1 --cpus-per-task=1 --time=4:00:00 $QSUBOPTS $qscript | rev | cut -f1 -d\ | rev`
       jobIDs="$jobIDs $id"
       sleep 0.5
     elif  [ $DOQSUB -eq 0 ] ; then
@@ -1254,7 +1224,7 @@ while [  $i -lt ${ITERATIONLIMIT} ]
       echo "--------------------------------------------------------------------------------------"
 
       # now wait for the stuff to finish - this will take a while so poll queue every 10 mins
-      ${ANTSPATH}/waitForSGEQJobs.pl 1 600 $jobIDs
+      waitForSGEQJobs.pl 1 600 $jobIDs
 
       if [ ! $? -eq 0 ]; then
         echo "qsub submission failed - jobs went into error state"
@@ -1270,7 +1240,7 @@ while [  $i -lt ${ITERATIONLIMIT} ]
       echo "--------------------------------------------------------------------------------------"
 
       # now wait for the stuff to finish - this will take a while so poll queue every 10 mins
-      ${ANTSPATH}/waitForPBSQJobs.pl 1 600 $jobIDs
+      waitForPBSQJobs.pl 1 600 $jobIDs
 
       if [ ! $? -eq 0 ]; then
         echo "qsub submission failed - jobs went into error state"
@@ -1301,7 +1271,7 @@ while [  $i -lt ${ITERATIONLIMIT} ]
     echo " Starting ANTS registration on XGrid cluster. Submitted $count jobs "
     echo "--------------------------------------------------------------------------------------"
            # now wait for the jobs to finish. This is slow, so poll less often
-    ${ANTSPATH}/waitForXGridJobs.pl -xgridflags "$XGRIDOPTS" -verbose -delay 300 $jobIDs
+    waitForXGridJobs.pl -xgridflags "$XGRIDOPTS" -verbose -delay 300 $jobIDs
     # Returns 1 if there are errors
     if [ ! $? -eq 0 ]; then
         echo "XGrid submission failed - jobs went into error state"
@@ -1318,7 +1288,7 @@ while [  $i -lt ${ITERATIONLIMIT} ]
     echo "--------------------------------------------------------------------------------------"
 
     # now wait for the stuff to finish - this will take a while so poll queue every 10 mins
-    ${ANTSPATH}/waitForSlurmJobs.pl 1 600 $jobIDs
+    waitForSlurmJobs.pl 1 600 $jobIDs
 
     if [[ ! $? -eq 0 ]];
         then
diff --git a/Scripts/directlabels.sh b/Scripts/directlabels.sh
index a8041ad0..c387c08a 100755
--- a/Scripts/directlabels.sh
+++ b/Scripts/directlabels.sh
@@ -8,13 +8,9 @@ VERSION="0.0"
 # trap keyboard interrupt (control-c)
 trap control_c SIGINT
 
-# Uncomment the line below in case you have not set the ANTSPATH variable in your environment.
-if [ ${#ANTSPATH} -le 3 ] ; then
-  echo we guess at your ants path
-  export ANTSPATH=${ANTSPATH:="$HOME/bin/ants/"} # EDIT THIS
-fi
-if [ ! -s ${ANTSPATH}/ANTS ] ; then
-  echo we cant find the ANTS program -- does not seem to exist.  please \(re\)define \$ANTSPATH in your environment.
+if ! command -v ANTS &> /dev/null
+then
+  echo we cant find the ANTS program -- does not seem to exist.  please \(re\)define \$PATH in your environment.
   exit
 fi
 
@@ -82,7 +78,7 @@ PARAMETERS
 
 getLabelsAndBoundingBoxes() {
 
-  OUTPUT=(`${ANTSPATH}/LabelGeometryMeasures $DIMENSION $LABEL_IMAGE`);
+  OUTPUT=(`LabelGeometryMeasures $DIMENSION $LABEL_IMAGE`);
 
   ## Get labels
 
@@ -178,21 +174,21 @@ writeSubimages() {
    #   3. Combine the result from 1) and 2) to have an image with only
    #      the white matter and the current label (as the grey matter).
    #
-   OUTPUT=(`${ANTSPATH}/ThresholdImage $DIMENSION $LABEL_IMAGE $grayMatterMask ${LABELS[$i]} ${LABELS[$i]} 1 0`)
-   OUTPUT=(`${ANTSPATH}/ThresholdImage $DIMENSION $SEG_IMAGE $whiteMatterMask 3 3 3 0`)
-   OUTPUT=(`${ANTSPATH}/ImageMath $DIMENSION $grayMatterMask m $grayMatterMask $SEG_IMAGE`)
-   OUTPUT=(`${ANTSPATH}/ImageMath $DIMENSION $gmWmMask + $grayMatterMask $whiteMatterMask`)
-   OUTPUT=(`${ANTSPATH}/ExtractRegionFromImage $DIMENSION $gmWmMask ${TMPDIR}seg_${LABELS[$i]}.nii.gz $minIndex $maxIndex`)
-   OUTPUT=(`${ANTSPATH}/ImageMath $DIMENSION ${TMPDIR}seg_${LABELS[$i]}.nii.gz PadImage ${TMPDIR}seg_${LABELS[$i]}.nii.gz $PADDING`)
+   OUTPUT=(`ThresholdImage $DIMENSION $LABEL_IMAGE $grayMatterMask ${LABELS[$i]} ${LABELS[$i]} 1 0`)
+   OUTPUT=(`ThresholdImage $DIMENSION $SEG_IMAGE $whiteMatterMask 3 3 3 0`)
+   OUTPUT=(`ImageMath $DIMENSION $grayMatterMask m $grayMatterMask $SEG_IMAGE`)
+   OUTPUT=(`ImageMath $DIMENSION $gmWmMask + $grayMatterMask $whiteMatterMask`)
+   OUTPUT=(`ExtractRegionFromImage $DIMENSION $gmWmMask ${TMPDIR}seg_${LABELS[$i]}.nii.gz $minIndex $maxIndex`)
+   OUTPUT=(`ImageMath $DIMENSION ${TMPDIR}seg_${LABELS[$i]}.nii.gz PadImage ${TMPDIR}seg_${LABELS[$i]}.nii.gz $PADDING`)
    if [ -f $WMPROB_IMAGE ]; then
-     OUTPUT=(`${ANTSPATH}/ImageMath $DIMENSION $whiteMatterMask m $whiteMatterMask $WMPROB_IMAGE`)
-     OUTPUT=(`${ANTSPATH}/ExtractRegionFromImage $DIMENSION $whiteMatterMask ${TMPDIR}wm_${LABELS[$i]}.nii.gz $minIndex $maxIndex`);
-     OUTPUT=(`${ANTSPATH}/ImageMath $DIMENSION ${TMPDIR}wm_${LABELS[$i]}.nii.gz PadImage ${TMPDIR}wm_${LABELS[$i]}.nii.gz $PADDING`);
+     OUTPUT=(`ImageMath $DIMENSION $whiteMatterMask m $whiteMatterMask $WMPROB_IMAGE`)
+     OUTPUT=(`ExtractRegionFromImage $DIMENSION $whiteMatterMask ${TMPDIR}wm_${LABELS[$i]}.nii.gz $minIndex $maxIndex`);
+     OUTPUT=(`ImageMath $DIMENSION ${TMPDIR}wm_${LABELS[$i]}.nii.gz PadImage ${TMPDIR}wm_${LABELS[$i]}.nii.gz $PADDING`);
    fi
    if [ -f $GMPROB_IMAGE ]; then
-     OUTPUT=(`${ANTSPATH}/ImageMath $DIMENSION $grayMatterMask m $grayMatterMask $GMPROB_IMAGE`)
-     OUTPUT=(`${ANTSPATH}/ExtractRegionFromImage $DIMENSION $grayMatterMask ${TMPDIR}gm_${LABELS[$i]}.nii.gz $minIndex $maxIndex`);
-     OUTPUT=(`${ANTSPATH}/ImageMath $DIMENSION ${TMPDIR}gm_${LABELS[$i]}.nii.gz PadImage ${TMPDIR}gm_${LABELS[$i]}.nii.gz $PADDING`);
+     OUTPUT=(`ImageMath $DIMENSION $grayMatterMask m $grayMatterMask $GMPROB_IMAGE`)
+     OUTPUT=(`ExtractRegionFromImage $DIMENSION $grayMatterMask ${TMPDIR}gm_${LABELS[$i]}.nii.gz $minIndex $maxIndex`);
+     OUTPUT=(`ImageMath $DIMENSION ${TMPDIR}gm_${LABELS[$i]}.nii.gz PadImage ${TMPDIR}gm_${LABELS[$i]}.nii.gz $PADDING`);
    fi
 
    rm -rf $grayMatterMask
@@ -230,7 +226,7 @@ function jobfnamepadding {
 
 function pasteImages {
 
-  output=( `${ANTSPATH}/CreateImage $DIMENSION $SEG_IMAGE $OUTPUT_IMAGE 0` );
+  output=( `CreateImage $DIMENSION $SEG_IMAGE $OUTPUT_IMAGE 0` );
 
   for (( i=0; i<${#BOUNDING_BOXES[@]}; i++ )); do
     bbox=$(echo ${BOUNDING_BOXES[$i]}|sed 's/,/ /g')
@@ -253,7 +249,7 @@ function pasteImages {
 
     minIndex=${minIndex:1};
 
-    output=(`${ANTSPATH}/PasteImageIntoImage $DIMENSION $OUTPUT_IMAGE $TMPDIR/direct_${LABELS[$i]}.nii.gz $OUTPUT_IMAGE $minIndex 0 2 -1`);
+    output=(`PasteImageIntoImage $DIMENSION $OUTPUT_IMAGE $TMPDIR/direct_${LABELS[$i]}.nii.gz $OUTPUT_IMAGE $minIndex 0 2 -1`);
   done
 
 }
@@ -272,7 +268,7 @@ time_start=`date +%s`
 CURRENTDIR=`pwd`/
 TMPDIR=${CURRENTDIR}/tmp$RANDOM/
 
-DIRECT=${ANTSPATH}/KellyKapowski
+DIRECT=KellyKapowski
 DIMENSION=3
 SEG_IMAGE=""
 GMPROB_IMAGE=""
@@ -296,8 +292,8 @@ CORES=2
 # It can be set to an empty string if you do not need any special cluster options
 QSUBOPTS="" # EDIT THIS
 
-PEXEC=${ANTSPATH}/ANTSpexec.sh
-SGE=${ANTSPATH}/waitForSGEQJobs.pl
+PEXEC=ANTSpexec.sh
+SGE=waitForSGEQJobs.pl
 
 for FLE in $PEXEC $SGE
   do
@@ -407,7 +403,7 @@ for LABEL in ${LABELS[@]}
 
   # 6 submit to SGE or else run locally
   if [ $DOQSUB -eq 1 ]; then
-    id=`qsub -cwd -N DiReCT_${LABEL} -S /bin/bash -v ANTSPATH=$ANTSPATH $QSUBOPTS $exe | awk '{print $3}'`
+    id=`qsub -cwd -N DiReCT_${LABEL} -S /bin/bash $QSUBOPTS $exe | awk '{print $3}'`
     jobIDs="$jobIDs $id"
     sleep 0.5
   elif [ $DOQSUB -eq 2 ] ; then
diff --git a/Scripts/geodesicinterpolation.sh b/Scripts/geodesicinterpolation.sh
index 4bcec8cc..434e64f8 100755
--- a/Scripts/geodesicinterpolation.sh
+++ b/Scripts/geodesicinterpolation.sh
@@ -11,7 +11,6 @@ echo " if you choose 10 points and step-size of  2 then you will get 4 interpola
 echo " if you use affine initialization - sometimes it could cause unpleasantness, if the affine mapping is large -- sometimes it may be needed, though "
 echo " the mask image restricts matching to an ROI "
 echo " The Auxiliary-Template is another image through which the morph images (image1 and image2) are mapped -- this often helps, if the auxiliary template is an average face image "
-echo " Be sure to set the ANTSPATH path variable "
 echo " "
 echo " You may need to tune the ANTS parameters coded within this script for your application "
 exit
@@ -74,14 +73,14 @@ if [ $NUMPARAMS -le 5 ]
 then
 if [ $USEAFF -eq 0 ]
 then
-${ANTSPATH}/ANTS 2 -m PR[ $TEMPLATE,$TARGET,1,${RADIUS}]   -t $TRAN -r $REG -o $OUTNAME   -i $ITS    --number-of-affine-iterations 0    -x $MASK
+ANTS 2 -m PR[ $TEMPLATE,$TARGET,1,${RADIUS}]   -t $TRAN -r $REG -o $OUTNAME   -i $ITS    --number-of-affine-iterations 0    -x $MASK
 fi
 if [ $USEAFF -ne 0 ]
 then
-${ANTSPATH}/ANTS 2 -m PR[ $TEMPLATE,$TARGET,1,${RADIUS}]   -t  $TRAN -r $REG -o $OUTNAME   -i $ITS     -x  $MASK  #--MI-option 16x2000
+ANTS 2 -m PR[ $TEMPLATE,$TARGET,1,${RADIUS}]   -t  $TRAN -r $REG -o $OUTNAME   -i $ITS     -x  $MASK  #--MI-option 16x2000
 fi
-${ANTSPATH}/ComposeMultiTransform 2   ${OUTNAME}Warp.nii.gz  -R $TEMPLATE ${OUTNAME}Warp.nii.gz ${OUTNAME}Affine.txt
-${ANTSPATH}/ComposeMultiTransform 2   ${OUTNAME}InverseWarp.nii.gz  -R $TARGET -i ${OUTNAME}Affine.txt ${OUTNAME}InverseWarp.nii.gz
+ComposeMultiTransform 2   ${OUTNAME}Warp.nii.gz  -R $TEMPLATE ${OUTNAME}Warp.nii.gz ${OUTNAME}Affine.txt
+ComposeMultiTransform 2   ${OUTNAME}InverseWarp.nii.gz  -R $TARGET -i ${OUTNAME}Affine.txt ${OUTNAME}InverseWarp.nii.gz
 fi
 
 if [ $NUMPARAMS -gt 5 ]
@@ -90,36 +89,36 @@ if [ $USEAFF -eq 0 ]
 then
 #echo "  Pseudo-Morphing "
 #echo " method 1 "
-${ANTSPATH}/ANTS 2 -m PR[ $TEMPLATEB,$TARGET,1,${RADIUS}]   -t $TRAN -r $REG -o ${OUTNAME}B  -i $ITS    --number-of-affine-iterations 0    -x $MASK
-${ANTSPATH}/ANTS 2 -m PR[ $TEMPLATE,$TEMPLATEB,1,${RADIUS}]   -t  $TRAN -r $REG -o ${OUTNAME}A   -i $ITS  --number-of-affine-iterations 0    -x $MASK
-${ANTSPATH}/ComposeMultiTransform 2   ${OUTNAME}AWarp.nii.gz  -R $TEMPLATE  ${OUTNAME}AWarp.nii.gz ${OUTNAME}AAffine.txt
-${ANTSPATH}/ComposeMultiTransform 2   ${OUTNAME}AInverseWarp.nii.gz  -R $TEMPLATEB -i ${OUTNAME}AAffine.txt ${OUTNAME}AInverseWarp.nii.gz
-${ANTSPATH}/ComposeMultiTransform 2   ${OUTNAME}BWarp.nii.gz  -R $TEMPLATEB  ${OUTNAME}BWarp.nii.gz ${OUTNAME}BAffine.txt
-${ANTSPATH}/ComposeMultiTransform 2   ${OUTNAME}BInverseWarp.nii.gz  -R $TARGET -i ${OUTNAME}BAffine.txt ${OUTNAME}BInverseWarp.nii.gz
-${ANTSPATH}/ComposeMultiTransform 2   ${OUTNAME}Warp.nii.gz  -R $TEMPLATE  ${OUTNAME}AWarp.nii.gz ${OUTNAME}BWarp.nii.gz
-${ANTSPATH}/ComposeMultiTransform 2   ${OUTNAME}InverseWarp.nii.gz  -R $TARGET  ${OUTNAME}BInverseWarp.nii.gz ${OUTNAME}AInverseWarp.nii.gz
+ANTS 2 -m PR[ $TEMPLATEB,$TARGET,1,${RADIUS}]   -t $TRAN -r $REG -o ${OUTNAME}B  -i $ITS    --number-of-affine-iterations 0    -x $MASK
+ANTS 2 -m PR[ $TEMPLATE,$TEMPLATEB,1,${RADIUS}]   -t  $TRAN -r $REG -o ${OUTNAME}A   -i $ITS  --number-of-affine-iterations 0    -x $MASK
+ComposeMultiTransform 2   ${OUTNAME}AWarp.nii.gz  -R $TEMPLATE  ${OUTNAME}AWarp.nii.gz ${OUTNAME}AAffine.txt
+ComposeMultiTransform 2   ${OUTNAME}AInverseWarp.nii.gz  -R $TEMPLATEB -i ${OUTNAME}AAffine.txt ${OUTNAME}AInverseWarp.nii.gz
+ComposeMultiTransform 2   ${OUTNAME}BWarp.nii.gz  -R $TEMPLATEB  ${OUTNAME}BWarp.nii.gz ${OUTNAME}BAffine.txt
+ComposeMultiTransform 2   ${OUTNAME}BInverseWarp.nii.gz  -R $TARGET -i ${OUTNAME}BAffine.txt ${OUTNAME}BInverseWarp.nii.gz
+ComposeMultiTransform 2   ${OUTNAME}Warp.nii.gz  -R $TEMPLATE  ${OUTNAME}AWarp.nii.gz ${OUTNAME}BWarp.nii.gz
+ComposeMultiTransform 2   ${OUTNAME}InverseWarp.nii.gz  -R $TARGET  ${OUTNAME}BInverseWarp.nii.gz ${OUTNAME}AInverseWarp.nii.gz
 #
 #echo " method 2 "
-#${ANTSPATH}/ComposeMultiTransform 2   ${OUTNAME}Warp.nii.gz  -R $TEMPLATE  ${OUTNAME}AWarp.nii.gz ${OUTNAME}AAffine.txt  ${OUTNAME}BWarp.nii.gz ${OUTNAME}BAffine.txt
-#${ANTSPATH}/ComposeMultiTransform 2   ${OUTNAME}InverseWarp.nii.gz  -R $TARGET -i ${OUTNAME}BAffine.txt   ${OUTNAME}BInverseWarp.nii.gz -i ${OUTNAME}AAffine.txt  ${OUTNAME}AInverseWarp.nii
+#ComposeMultiTransform 2   ${OUTNAME}Warp.nii.gz  -R $TEMPLATE  ${OUTNAME}AWarp.nii.gz ${OUTNAME}AAffine.txt  ${OUTNAME}BWarp.nii.gz ${OUTNAME}BAffine.txt
+#ComposeMultiTransform 2   ${OUTNAME}InverseWarp.nii.gz  -R $TARGET -i ${OUTNAME}BAffine.txt   ${OUTNAME}BInverseWarp.nii.gz -i ${OUTNAME}AAffine.txt  ${OUTNAME}AInverseWarp.nii
 #
 fi
 if [ $USEAFF -ne 0 ]
 then
 #echo "  Pseudo-Morphing "
 #echo " method 1 "
-${ANTSPATH}/ANTS 2 -m PR[ $TEMPLATEB,$TARGET,1,${RADIUS}]   -t $TRAN -r $REG -o ${OUTNAME}B  -i $ITS    -x $MASK
-${ANTSPATH}/ANTS 2 -m PR[ $TEMPLATE,$TEMPLATEB,1,${RADIUS}]   -t  $TRAN -r $REG -o ${OUTNAME}A   -i $ITS     -x $MASK
-${ANTSPATH}/ComposeMultiTransform 2   ${OUTNAME}AWarp.nii.gz  -R $TEMPLATE  ${OUTNAME}AWarp.nii.gz ${OUTNAME}AAffine.txt
-${ANTSPATH}/ComposeMultiTransform 2   ${OUTNAME}AInverseWarp.nii.gz  -R $TEMPLATEB -i ${OUTNAME}AAffine.txt ${OUTNAME}AInverseWarp.nii.gz
-${ANTSPATH}/ComposeMultiTransform 2   ${OUTNAME}BWarp.nii.gz  -R $TEMPLATEB  ${OUTNAME}BWarp.nii.gz ${OUTNAME}BAffine.txt
-${ANTSPATH}/ComposeMultiTransform 2   ${OUTNAME}BInverseWarp.nii.gz  -R $TARGET -i ${OUTNAME}BAffine.txt ${OUTNAME}BInverseWarp.nii.gz
-${ANTSPATH}/ComposeMultiTransform 2   ${OUTNAME}Warp.nii.gz  -R $TEMPLATE  ${OUTNAME}AWarp.nii.gz ${OUTNAME}BWarp.nii
-${ANTSPATH}/ComposeMultiTransform 2   ${OUTNAME}InverseWarp.nii.gz  -R $TARGET  ${OUTNAME}BInverseWarp.nii.gz ${OUTNAME}AInverseWarp.nii.gz
+ANTS 2 -m PR[ $TEMPLATEB,$TARGET,1,${RADIUS}]   -t $TRAN -r $REG -o ${OUTNAME}B  -i $ITS    -x $MASK
+ANTS 2 -m PR[ $TEMPLATE,$TEMPLATEB,1,${RADIUS}]   -t  $TRAN -r $REG -o ${OUTNAME}A   -i $ITS     -x $MASK
+ComposeMultiTransform 2   ${OUTNAME}AWarp.nii.gz  -R $TEMPLATE  ${OUTNAME}AWarp.nii.gz ${OUTNAME}AAffine.txt
+ComposeMultiTransform 2   ${OUTNAME}AInverseWarp.nii.gz  -R $TEMPLATEB -i ${OUTNAME}AAffine.txt ${OUTNAME}AInverseWarp.nii.gz
+ComposeMultiTransform 2   ${OUTNAME}BWarp.nii.gz  -R $TEMPLATEB  ${OUTNAME}BWarp.nii.gz ${OUTNAME}BAffine.txt
+ComposeMultiTransform 2   ${OUTNAME}BInverseWarp.nii.gz  -R $TARGET -i ${OUTNAME}BAffine.txt ${OUTNAME}BInverseWarp.nii.gz
+ComposeMultiTransform 2   ${OUTNAME}Warp.nii.gz  -R $TEMPLATE  ${OUTNAME}AWarp.nii.gz ${OUTNAME}BWarp.nii
+ComposeMultiTransform 2   ${OUTNAME}InverseWarp.nii.gz  -R $TARGET  ${OUTNAME}BInverseWarp.nii.gz ${OUTNAME}AInverseWarp.nii.gz
 #
 #echo " method 2 "
-#${ANTSPATH}/ComposeMultiTransform 2   ${OUTNAME}Warp.nii.gz  -R $TEMPLATE  ${OUTNAME}AWarp.nii.gz ${OUTNAME}AAffine.txt  ${OUTNAME}BWarp.nii.gz ${OUTNAME}BAffine.txt
-#${ANTSPATH}/ComposeMultiTransform 2   ${OUTNAME}InverseWarp.nii.gz  -R $TARGET -i ${OUTNAME}BAffine.txt   ${OUTNAME}BInverseWarp.nii.gz -i ${OUTNAME}AAffine.txt  ${OUTNAME}AInverseWarp.nii
+#ComposeMultiTransform 2   ${OUTNAME}Warp.nii.gz  -R $TEMPLATE  ${OUTNAME}AWarp.nii.gz ${OUTNAME}AAffine.txt  ${OUTNAME}BWarp.nii.gz ${OUTNAME}BAffine.txt
+#ComposeMultiTransform 2   ${OUTNAME}InverseWarp.nii.gz  -R $TARGET -i ${OUTNAME}BAffine.txt   ${OUTNAME}BInverseWarp.nii.gz -i ${OUTNAME}AAffine.txt  ${OUTNAME}AInverseWarp.nii
 #
 fi
 fi
@@ -135,21 +134,21 @@ echo " Blending values:   $BLENDINGA and $BLENDINGB"
 BASEA=${TEMPLATE%.*}
 BASEB=${TARGET%.*}
 
-${ANTSPATH}/MultiplyImages 2 ${OUTNAME}InverseWarp.nii.gz  $BLENDINGA  SM${OUTNAME}InverseWarp.nii.gz
-${ANTSPATH}/MultiplyImages 2 ${OUTNAME}InverseWarp.nii.gz  $BLENDINGA  SM${OUTNAME}InverseWarp.nii.gz
+MultiplyImages 2 ${OUTNAME}InverseWarp.nii.gz  $BLENDINGA  SM${OUTNAME}InverseWarp.nii.gz
+MultiplyImages 2 ${OUTNAME}InverseWarp.nii.gz  $BLENDINGA  SM${OUTNAME}InverseWarp.nii.gz
 
-${ANTSPATH}/MultiplyImages 2 ${OUTNAME}Warp.nii.gz  $BLENDINGB SM${OUTNAME}Warp.nii.gz
-${ANTSPATH}/MultiplyImages 2 ${OUTNAME}Warp.nii.gz  $BLENDINGB SM${OUTNAME}Warp.nii.gz
+MultiplyImages 2 ${OUTNAME}Warp.nii.gz  $BLENDINGB SM${OUTNAME}Warp.nii.gz
+MultiplyImages 2 ${OUTNAME}Warp.nii.gz  $BLENDINGB SM${OUTNAME}Warp.nii.gz
 
-  ${ANTSPATH}/WarpImageMultiTransform 2 $TARGET temp.nii.gz SM${OUTNAME}Warp.nii.gz  -R $TEMPLATE
-  ${ANTSPATH}/ImageMath 2 temp.nii.gz Normalize temp.nii.gz 1
-  ${ANTSPATH}/ImageMath 2 temp.nii.gz m temp.nii.gz 1.   #$BLENDINGA
-  ${ANTSPATH}/WarpImageMultiTransform 2 $TEMPLATE temp2.nii.gz   SM${OUTNAME}InverseWarp.nii.gz -R $TEMPLATE
-  ${ANTSPATH}/ImageMath 2 temp2.nii.gz Normalize temp2.nii.gz  1
-  ${ANTSPATH}/ImageMath 2 temp2.nii.gz m temp2.nii.gz 0  #$BLENDINGB
+  WarpImageMultiTransform 2 $TARGET temp.nii.gz SM${OUTNAME}Warp.nii.gz  -R $TEMPLATE
+  ImageMath 2 temp.nii.gz Normalize temp.nii.gz 1
+  ImageMath 2 temp.nii.gz m temp.nii.gz 1.   #$BLENDINGA
+  WarpImageMultiTransform 2 $TEMPLATE temp2.nii.gz   SM${OUTNAME}InverseWarp.nii.gz -R $TEMPLATE
+  ImageMath 2 temp2.nii.gz Normalize temp2.nii.gz  1
+  ImageMath 2 temp2.nii.gz m temp2.nii.gz 0  #$BLENDINGB
   echo "  ImageMath 2 ${BASEA}${BASEB}${BLENDNAME}morph.nii.gz + temp2.nii.gz temp.nii.gz  "
-  ${ANTSPATH}/ImageMath 2 ${BASEA}${BASEB}${BLENDNAME}morph.nii.gz + temp2.nii.gz temp.nii.gz
-  ${ANTSPATH}/ConvertToJpg  ${BASEA}${BASEB}${BLENDNAME}morph.nii.gz ${BASEA}${BASEB}${BLENDNAME}morph.jpg
+  ImageMath 2 ${BASEA}${BASEB}${BLENDNAME}morph.nii.gz + temp2.nii.gz temp.nii.gz
+  ConvertToJpg  ${BASEA}${BASEB}${BLENDNAME}morph.nii.gz ${BASEA}${BASEB}${BLENDNAME}morph.jpg
   rm  -f  ${BASEA}${BASEB}${BLENDNAME}morph.nii.gz
 
    done
diff --git a/Scripts/guidedregistration.sh b/Scripts/guidedregistration.sh
index 88eefe24..018351e6 100755
--- a/Scripts/guidedregistration.sh
+++ b/Scripts/guidedregistration.sh
@@ -6,12 +6,9 @@ echo " the template = fixed.nii   ,   the individual = moving.nii "
 echo " iterations should be of the form  100x100x10 "
 exit
 fi
-if [ ${#ANTSPATH} -le 3 ] ; then
-  echo we guess at your ants path
-  export ANTSPATH=${ANTSPATH:="$HOME/bin/ants/"} # EDIT THIS
-fi
-if [ ! -s ${ANTSPATH}/ANTS ] ; then
-  echo we cant find the ANTS program -- does not seem to exist.  please \(re\)define \$ANTSPATH in your environment.
+if ! command -v ANTS &> /dev/null
+then
+  echo we cant find the ANTS program -- does not seem to exist.  please \(re\)define \$PATH in your environment.
   exit
 fi
 
@@ -23,8 +20,6 @@ OUT=$5
 ITS=$6
 DIM=$7
 
-#ANTSPATH='/Users/stnava/Code/bin/ants/'
-
 if  [ ${#FIX} -lt 1 -o  ! -f $FIX ]
 then
 echo " Problem with specified Fixed Image => User Specified Value = $FIX "
@@ -63,11 +58,11 @@ INTENSITY=CC[ $FIX,${MOV},${INTWT},4]
 
 #  == Important Parameters end? ==
 
- ${ANTSPATH}ANTS $DIM -o $OUT  -i $ITS -t SyN[ 0.25 ]  -r Gauss[ 3,0 ] -m $INTENSITY   -m   $LM
+ANTS $DIM -o $OUT  -i $ITS -t SyN[ 0.25 ]  -r Gauss[ 3,0 ] -m $INTENSITY   -m   $LM
 
- ${ANTSPATH}WarpImageMultiTransform $DIM $MOV ${OUT}toTemplate.nii.gz ${OUT}Warp.nii.gz ${OUT}Affine.txt  -R $FIX
+WarpImageMultiTransform $DIM $MOV ${OUT}toTemplate.nii.gz ${OUT}Warp.nii.gz ${OUT}Affine.txt  -R $FIX
 
- ${ANTSPATH}WarpImageMultiTransform $DIM  $FIX ${OUT}toMov.nii.gz -i ${OUT}Affine.txt  ${OUT}InverseWarp.nii.gz  -R $MOV
+WarpImageMultiTransform $DIM  $FIX ${OUT}toMov.nii.gz -i ${OUT}Affine.txt  ${OUT}InverseWarp.nii.gz  -R $MOV
 
- ${ANTSPATH}WarpImageMultiTransform $DIM $FIXH  ${OUT}hipp.nii.gz -i ${OUT}Affine.txt  ${OUT}InverseWarp.nii.gz  -R $MOV --UseNN
+WarpImageMultiTransform $DIM $FIXH  ${OUT}hipp.nii.gz -i ${OUT}Affine.txt  ${OUT}InverseWarp.nii.gz  -R $MOV --UseNN
 
diff --git a/Scripts/landmarkmatch.sh b/Scripts/landmarkmatch.sh
index 6e1f9653..87833400 100755
--- a/Scripts/landmarkmatch.sh
+++ b/Scripts/landmarkmatch.sh
@@ -10,8 +10,7 @@ hippocampus, then  this is known as "partial matching" as in Pluta, et al Hippoc
 exit
 fi
 
-#ANTSPATH="/mnt/aibs1/avants/bin/ants/"
-ITS=$5
+TS=$5
 LMWT=$6
 INTWT=1
 
@@ -51,14 +50,14 @@ do
 PRE=$OUT
 TOUT=${PRE}locmod.nii.gz
 echo " DOING $TOUT "
-${ANTSPATH}ThresholdImage 3 $i ${PRE}tempb.nii.gz 30.5 32.5
-${ANTSPATH}MultiplyImages 3 $i  ${PRE}tempb.nii.gz $TOUT
-${ANTSPATH}ThresholdImage 3 $i ${PRE}tempb.nii.gz 20.5 22.5
-${ANTSPATH}MultiplyImages 3 $i ${PRE}tempb.nii.gz ${PRE}tempb.nii
-${ANTSPATH}ImageMath 3 $TOUT + $TOUT ${PRE}tempb.nii.gz
-${ANTSPATH}ThresholdImage 3 $i ${PRE}tempb.nii.gz 8.5 10.5
-${ANTSPATH}MultiplyImages 3 $i ${PRE}tempb.nii.gz ${PRE}tempb.nii.gz
-${ANTSPATH}ImageMath 3 $TOUT + $TOUT ${PRE}tempb.nii.gz
+ThresholdImage 3 $i ${PRE}tempb.nii.gz 30.5 32.5
+MultiplyImages 3 $i  ${PRE}tempb.nii.gz $TOUT
+ThresholdImage 3 $i ${PRE}tempb.nii.gz 20.5 22.5
+MultiplyImages 3 $i ${PRE}tempb.nii.gz ${PRE}tempb.nii
+ImageMath 3 $TOUT + $TOUT ${PRE}tempb.nii.gz
+ThresholdImage 3 $i ${PRE}tempb.nii.gz 8.5 10.5
+MultiplyImages 3 $i ${PRE}tempb.nii.gz ${PRE}tempb.nii.gz
+ImageMath 3 $TOUT + $TOUT ${PRE}tempb.nii.gz
 done
 else
 FIXHMOD=$FIXH
@@ -80,17 +79,17 @@ STEPL=0.25
 INTENSITY=PR[ $FIX,${MOV},${INTWT},4]
 if [ $LMWT -le 0 ]
 then
-exe="${ANTSPATH}ANTS 3  -o $OUT  -i $ITS -t SyN[ ${STEPL}]  -r Gauss[ 3,0 ]   -m $INTENSITY   "
+exe="ANTS 3  -o $OUT  -i $ITS -t SyN[ ${STEPL}]  -r Gauss[ 3,0 ]   -m $INTENSITY   "
 else
-exe="${ANTSPATH}ANTS 3  -o $OUT  -i $ITS -t SyN[ ${STEPL}]  -r Gauss[ 3,0 ]   -m   $LM  -m $INTENSITY    "
+exe="ANTS 3  -o $OUT  -i $ITS -t SyN[ ${STEPL}]  -r Gauss[ 3,0 ]   -m   $LM  -m $INTENSITY    "
 fi
 echo " $exe "
 
  $exe
 
- ${ANTSPATH}WarpImageMultiTransform 3 $MOV ${OUT}deformed.nii.gz  ${OUT}Warp.nii.gz ${OUT}Affine.txt  -R $FIX
- ${ANTSPATH}WarpImageMultiTransform 3 $MOVH  ${OUT}label.nii.gz   ${OUT}Warp.nii.gz ${OUT}Affine.txt  -R $FIX --use-NN
- ${ANTSPATH}WarpImageMultiTransform 3 $FIXH ${OUT}labelinv.nii.gz  -i  ${OUT}Affine.txt  ${OUT}InverseWarp.nii.gz   -R $MOV --use-NN
+ WarpImageMultiTransform 3 $MOV ${OUT}deformed.nii.gz  ${OUT}Warp.nii.gz ${OUT}Affine.txt  -R $FIX
+ WarpImageMultiTransform 3 $MOVH  ${OUT}label.nii.gz   ${OUT}Warp.nii.gz ${OUT}Affine.txt  -R $FIX --use-NN
+ WarpImageMultiTransform 3 $FIXH ${OUT}labelinv.nii.gz  -i  ${OUT}Affine.txt  ${OUT}InverseWarp.nii.gz   -R $MOV --use-NN
 
 
 
diff --git a/Scripts/lohmann.sh b/Scripts/lohmann.sh
index 0ee3fbef..434ef7ce 100755
--- a/Scripts/lohmann.sh
+++ b/Scripts/lohmann.sh
@@ -7,22 +7,9 @@ if [ $NUMPARAMS -lt 2 ]
 then
 echo " USAGE ::  "
 echo "  sh   $0 ImageDimension  image.ext   "
-echo " be sure to set ANTSPATH environment variable "
 exit
 fi
 
-ANTSPATH=/mnt/aibs1/avants/bin/ants/
-if [  ${#ANTSPATH} -le 0 ]
-then
-echo " Please set ANTSPATH=LocationOfYourAntsBinaries "
-echo " Either set this in your profile or directly, here in the script. "
-echo " For example : "
-echo " ANTSPATH=/home/yourname/bin/ants/ "
-exit
-else
-echo " ANTSPATH is $ANTSPATH "
-fi
-
 #initialization, here, is unbiased
 DIM=$1
 
@@ -43,48 +30,48 @@ fi
 OUTPUTNAME=` echo $FIXED | cut -d '.' -f 1 `
 
 if [[ ! -s ${OUTPUTNAME}repaired.nii.gz ]] ; then
-${ANTSPATH}/N3BiasFieldCorrection $DIM $FIXED ${OUTPUTNAME}repaired.nii.gz 4
+N3BiasFieldCorrection $DIM $FIXED ${OUTPUTNAME}repaired.nii.gz 4
 fi
-${ANTSPATH}/ThresholdImage $DIM  ${OUTPUTNAME}repaired.nii.gz ${OUTPUTNAME}mask.nii.gz 0.1 99999
+ThresholdImage $DIM  ${OUTPUTNAME}repaired.nii.gz ${OUTPUTNAME}mask.nii.gz 0.1 99999
 
 WM=${OUTPUTNAME}seg.nii.gz
 if [[ ! -s $WM ]] ; then
-  ${ANTSPATH}/Apocrita $DIM -x ${OUTPUTNAME}mask.nii.gz  -m [ 0.5,1,0,0 ] -o [ ${OUTPUTNAME}seg.nii.gz ] -i Otsu[ ${OUTPUTNAME}repaired.nii.gz,3 ] -h 0
-  ${ANTSPATH}/ThresholdImage $DIM $WM $WM 3 3
-  ${ANTSPATH}/ImageMath $DIM $WM GetLargestComponent $WM
+  Apocrita $DIM -x ${OUTPUTNAME}mask.nii.gz  -m [ 0.5,1,0,0 ] -o [ ${OUTPUTNAME}seg.nii.gz ] -i Otsu[ ${OUTPUTNAME}repaired.nii.gz,3 ] -h 0
+  ThresholdImage $DIM $WM $WM 3 3
+  ImageMath $DIM $WM GetLargestComponent $WM
 fi
 OUT=${OUTPUTNAME}
 if [[ ! -s  ${OUT}max.nii.gz ]] ; then
 # the closing operation - arachnoid surface
-${ANTSPATH}/ImageMath 3 ${OUT}max.nii.gz MD $WM  15
-${ANTSPATH}/ImageMath 3 ${OUT}max.nii.gz ME ${OUT}max.nii.gz  15
+ImageMath 3 ${OUT}max.nii.gz MD $WM  15
+ImageMath 3 ${OUT}max.nii.gz ME ${OUT}max.nii.gz  15
 
 # unfolded or lissencephalic surface
 # we would prefer to do this in a topology preserving way
-${ANTSPATH}/ImageMath 3 ${OUT}min.nii.gz ME $WM 5
-${ANTSPATH}/ImageMath 3 ${OUT}min.nii.gz MD ${OUT}min.nii.gz 5
+ImageMath 3 ${OUT}min.nii.gz ME $WM 5
+ImageMath 3 ${OUT}min.nii.gz MD ${OUT}min.nii.gz 5
 
 # distance transform from arachnoid surface to inside of brain
 # perhaps should be a geodesic distance transform
-${ANTSPATH}/ImageMath 3 ${OUT}max.nii.gz Neg ${OUT}max.nii
-${ANTSPATH}/ImageMath 3 ${OUT}dist.nii.gz D ${OUT}max.nii
+ImageMath 3 ${OUT}max.nii.gz Neg ${OUT}max.nii
+ImageMath 3 ${OUT}dist.nii.gz D ${OUT}max.nii
 fi
 # multiply the distance transform by the "unfolded" surface
 # this gives the "feature" surface/image that could be input
 # to an image registration similarity metric
-${ANTSPATH}/ImageMath 3 ${OUT}lohmann.nii.gz m ${OUT}dist.nii.gz ${OUT}min.nii.gz
+ImageMath 3 ${OUT}lohmann.nii.gz m ${OUT}dist.nii.gz ${OUT}min.nii.gz
 
 # surface stuff for visualization
-${ANTSPATH}/ImageMath 3 ${OUT}surf.nii.gz ME ${OUT}min.nii.gz 2
-${ANTSPATH}/ImageMath 3 ${OUT}surf.nii.gz - ${OUT}min.nii.gz ${OUT}surf.nii.gz
-${ANTSPATH}/ImageMath 3 ${OUT}maxvals.nii.gz m ${OUT}lohmann.nii.gz ${OUT}surf.nii.gz
+ImageMath 3 ${OUT}surf.nii.gz ME ${OUT}min.nii.gz 2
+ImageMath 3 ${OUT}surf.nii.gz - ${OUT}min.nii.gz ${OUT}surf.nii.gz
+ImageMath 3 ${OUT}maxvals.nii.gz m ${OUT}lohmann.nii.gz ${OUT}surf.nii.gz
 
 # find sulci using curvature of the WM/lohmann surface
-	${ANTSPATH}/SurfaceCurvature ${OUT}lohmann.nii.gz ${OUT}lohmannk.nii.gz 1.5
+	SurfaceCurvature ${OUT}lohmann.nii.gz ${OUT}lohmannk.nii.gz 1.5
 
-${ANTSPATH}/ThresholdImage 3 ${OUT}lohmann.nii.gz ${OUT}lohmann.nii.gz 0.001 9999
-${ANTSPATH}/ImageMath 3 ${OUT}lohmannk.nii.gz Normalize ${OUT}lohmannk.nii.gz
-${ANTSPATH}/ImageMath 3 ${OUT}lohmannk.nii.gz m ${OUT}lohmannk.nii.gz ${OUT}lohmann.nii.gz
+ThresholdImage 3 ${OUT}lohmann.nii.gz ${OUT}lohmann.nii.gz 0.001 9999
+ImageMath 3 ${OUT}lohmannk.nii.gz Normalize ${OUT}lohmannk.nii.gz
+ImageMath 3 ${OUT}lohmannk.nii.gz m ${OUT}lohmannk.nii.gz ${OUT}lohmann.nii.gz
 
 
 exit
diff --git a/Scripts/multi_template_script.sh b/Scripts/multi_template_script.sh
index dc45962e..3b5368c0 100755
--- a/Scripts/multi_template_script.sh
+++ b/Scripts/multi_template_script.sh
@@ -5,9 +5,9 @@ if [ ${#ANTSPATH} -lt 3 ] ; then
  echo $0 PATH_TO_ANTS_BINARIES image_to_label.nii.gz
  exit
 fi
-ANTSPATH=${ANTSPATH}/
-if [ ! -s ${ANTSPATH}/ants.sh ] ; then
-  echo you need the file ${ANTSPATH}/ants.sh - exiting
+if ! command -v ants.sh &> /dev/null
+then
+  echo you need the file ants.sh - exiting
   exit
 fi
 
@@ -25,8 +25,8 @@ LIST_OF_IMAGES=" image1.nii.gz image2.nii.gz "
 LIST_OF_LABELS=( image1_labels.nii.gz image2_labels.nii.gz )
 LIST_OF_OUTPUT=( image1_output image2_output  )
 for  labeled_img in $LIST_OF_IMAGES ; do
-  sh ${ANTSPATH}/ants.sh 3  $labeled_img  $Image_To_Be_Labeled ${LIST_OF_OUTPUT[${ct}]} $FASTITERATIONS ${LIST_OF_LABELS[${ct}]}
+  sh ants.sh 3  $labeled_img  $Image_To_Be_Labeled ${LIST_OF_OUTPUT[${ct}]} $FASTITERATIONS ${LIST_OF_LABELS[${ct}]}
   let ct=$ct+1
 done
 ls *labeled.nii.gz > labeled_list.txt
-${ANTSPATH}/ImageSetStatistics 3 labeled_list.txt  new_subject_labels.nii.gz  1
+ImageSetStatistics 3 labeled_list.txt  new_subject_labels.nii.gz  1
diff --git a/Scripts/optimalsmooth.sh b/Scripts/optimalsmooth.sh
index 9ea3c795..6cb038cf 100755
--- a/Scripts/optimalsmooth.sh
+++ b/Scripts/optimalsmooth.sh
@@ -5,7 +5,6 @@ if [ $# -lt 1 ] ; then
 exit
 fi
 
-export ANTSPATH=${ANTSPATH:="$HOME/bin/ants/"}
 SUB=$1
 TH=${SUB}thicknorm.nii.gz
 JA=${SUB}logjacobian.nii
@@ -13,5 +12,5 @@ MK=${SUB}mask.nii.gz
 OUTT=${SUB}smooththick.nii.gz
 OUTJ=${SUB}smoothjac.nii.gz
 REPS=5
-  ${ANTSPATH}SurfaceBasedSmoothing $TH 1.5 $MK $OUTT $REPS
-  ${ANTSPATH}SurfaceBasedSmoothing $JA 1.5 $MK $OUTJ $REPS
+  SurfaceBasedSmoothing $TH 1.5 $MK $OUTT $REPS
+  SurfaceBasedSmoothing $JA 1.5 $MK $OUTJ $REPS
diff --git a/Scripts/phantomstudy.sh b/Scripts/phantomstudy.sh
index 84bbab5e..d1f454f1 100755
--- a/Scripts/phantomstudy.sh
+++ b/Scripts/phantomstudy.sh
@@ -1,23 +1,21 @@
 #!/bin/bash
 
-ANTSPATH="/Users/stnava/Code/bin/ants/"
-
 #initialization, here, is unbiased
 count=0
 for x in  phantomAwmgm.jpg phantomBwmgm.jpg phantomCwmgm.jpg phantomDwmgm.jpg phantomEwmgm.jpg phantomFwmgm.jpg phantomGwmgm.jpg phantomHwmgm.jpg
 do
     count=`expr $count + 1`					# Increment the counter
    echo " count is $count  and file is $x "
-    ${ANTSPATH}/ANTS 2 -m PR[ phantomtemplate.jpg,$x,1,4 ]   -i 20x161x161x161  -o TEST{$count}  -t SyN[ 2 ] -r Gauss[ 3,0.]
+    ANTS 2 -m PR[ phantomtemplate.jpg,$x,1,4 ]   -i 20x161x161x161  -o TEST{$count}  -t SyN[ 2 ] -r Gauss[ 3,0.]
 #
 #  -t SyN[ 1,2,0.05 ] -r Gauss[ 3,0.25]
-    ${ANTSPATH}/WarpImageMultiTransform 2  $x  TEST{$count}registered.nii  TEST{$count}Warp.nii TEST{$count}Affine.txt
+    WarpImageMultiTransform 2  $x  TEST{$count}registered.nii  TEST{$count}Warp.nii TEST{$count}Affine.txt
 done
 
 # to look at the stack of results, do this:
 
-${ANTSPATH}/StackSlices volo.hdr -1 -1 0 *$1
-${ANTSPATH}/StackSlices volr.hdr -1 -1 0 *registered.nii
+StackSlices volo.hdr -1 -1 0 *$1
+StackSlices volr.hdr -1 -1 0 *registered.nii
 
 count=0
 for x in  phantomAwmgm.jpg phantomBwmgm.jpg phantomCwmgm.jpg phantomDwmgm.jpg phantomEwmgm.jpg phantomFwmgm.jpg phantomGwmgm.jpg phantomHwmgm.jpg
@@ -25,11 +23,11 @@ do
     count=`expr $count + 1`					# Increment the counter
    echo " count is $count  and file is $x "
  echo "    CreateJacobianDeterminantImage  2   TEST{$count}Warp.nii  TEST{$count}logjac.nii  1 "
-   ${ANTSPATH}/CreateJacobianDeterminantImage  2   TEST{$count}Warp.nii  TEST{$count}logjac.nii  1
-#    ${ANTSPATH}/SmoothImage  2 TEST{$count}logjac.nii  1  TEST{$count}logjac.nii
+   CreateJacobianDeterminantImage  2   TEST{$count}Warp.nii  TEST{$count}logjac.nii  1
+#    SmoothImage  2 TEST{$count}logjac.nii  1  TEST{$count}logjac.nii
 done
 
 
-${ANTSPATH}/ThresholdImage 2 phantomtemplate.jpg mask.nii 100 200
+ThresholdImage 2 phantomtemplate.jpg mask.nii 100 200
 #  use the GLM with mask
- ${ANTSPATH}/GLM 2  mask.nii designmat.txt contrast.txt Result.nii 1000 TEST*logjac.nii
+ GLM 2  mask.nii designmat.txt contrast.txt Result.nii 1000 TEST*logjac.nii
diff --git a/Scripts/shapeupdatetotemplate.sh b/Scripts/shapeupdatetotemplate.sh
index 32d85185..e54e58d9 100755
--- a/Scripts/shapeupdatetotemplate.sh
+++ b/Scripts/shapeupdatetotemplate.sh
@@ -3,47 +3,18 @@
 # trap keyboard interrupt (control-c)
 trap control_c SIGINT
 
-function setPath {
-    cat <<SETPATH
+WARP=antsApplyTransforms
+AVERAGE_AFFINE_PROGRAM=AverageAffineTransform # NoRigid
 
---------------------------------------------------------------------------------------
-Error locating ANTS
---------------------------------------------------------------------------------------
-It seems that the ANTSPATH environment variable is not set. Please add the ANTSPATH
-variable. This can be achieved by editing the .bash_profile in the home directory.
-Add:
-
-ANTSPATH=/home/yourname/bin/ants/
-
-Or the correct location of the ANTS binaries.
-
-Alternatively, edit this script ( `basename $0` ) to set up this parameter correctly.
-
-SETPATH
-    exit 1
-}
-
-# Uncomment the line below in case you have not set the ANTSPATH variable in your environment.
-# export ANTSPATH=${ANTSPATH:="$HOME/bin/ants/"} # EDIT THIS
-
-#ANTSPATH=YOURANTSPATH
-if [[ ${#ANTSPATH} -le 3 ]];
-  then
-    setPath >&2
-  fi
-
-WARP=${ANTSPATH}/antsApplyTransforms
-AVERAGE_AFFINE_PROGRAM=${ANTSPATH}/AverageAffineTransform # NoRigid
-
-if [[ ! -s ${WARP} ]];
+if ! command -v ${WARP} &> /dev/null
   then
-    echo "antsApplyTransforms program can't be found. Please (re)define \$ANTSPATH in your environment."
+    echo "antsApplyTransforms program can't be found. Please (re)define \$PATH in your environment."
     exit
   fi
 
-if [[ ! -s ${AVERAGE_AFFINE_PROGRAM} ]];
+if ! command -v ${AVERAGE_AFFINE_PROGRAM} &> /dev/null
   then
-    echo "AverageAffineTransform* program can't be found. Please (re)define \$ANTSPATH in your environment."
+    echo "AverageAffineTransform* program can't be found. Please (re)define \$PATH in your environment."
     exit
   fi
 
@@ -92,7 +63,7 @@ while getopts "d:t:o:g:w:s:y:h:" OPT
 done
 
 if [[ $useaff -eq 1 ]] ; then
-  AVERAGE_AFFINE_PROGRAM=${ANTSPATH}/AverageAffineTransformNoRigid
+  AVERAGE_AFFINE_PROGRAM=AverageAffineTransformNoRigid
 fi
 
 
@@ -167,8 +138,8 @@ function shapeupdatetotemplate() {
     echo "--------------------------------------------------------------------------------------"
     echo " shapeupdatetotemplate---voxel-wise averaging of the warped images to the current template"
     date
-    #echo "   ${ANTSPATH}/AverageImages $dim ${template} 1 ${templatename}${whichtemplate}*WarpedToTemplate.nii.gz    "
-    #echo "    ${ANTSPATH}/ImageSetStatistics $dim ${whichtemplate}WarpedToTemplateList.txt ${template} 0"
+    #echo "   AverageImages $dim ${template} 1 ${templatename}${whichtemplate}*WarpedToTemplate.nii.gz    "
+    #echo "    ImageSetStatistics $dim ${whichtemplate}WarpedToTemplateList.txt ${template} 0"
     echo "--------------------------------------------------------------------------------------"
     imagelist=(`ls ${outputname}template${whichtemplate}*WarpedToTemplate.nii.gz`)
     if [[ ${#imagelist[@]} -eq 0 ]] ; then
@@ -191,18 +162,18 @@ function shapeupdatetotemplate() {
           echo
           echo "--------------------------------------------------------------------------------------"
           echo " shapeupdatetotemplate---voxel-wise averaging of the inverse warp fields (from subject to template)"
-          echo "   ${ANTSPATH}/AverageImages $dim ${templatename}${whichtemplate}warp.nii.gz 0 `ls ${outputname}*Warp.nii.gz | grep -v "InverseWarp"`"
+          echo "   AverageImages $dim ${templatename}${whichtemplate}warp.nii.gz 0 `ls ${outputname}*Warp.nii.gz | grep -v "InverseWarp"`"
           date
           echo "--------------------------------------------------------------------------------------"
-          ${ANTSPATH}/AverageImages $dim ${templatename}${whichtemplate}warp.nii.gz 0 `ls ${outputname}*Warp.nii.gz | grep -v "InverseWarp"`
+          AverageImages $dim ${templatename}${whichtemplate}warp.nii.gz 0 `ls ${outputname}*Warp.nii.gz | grep -v "InverseWarp"`
 
           echo
           echo "--------------------------------------------------------------------------------------"
           echo " shapeupdatetotemplate---scale the averaged inverse warp field by the gradient step"
-          echo "   ${ANTSPATH}/MultiplyImages $dim ${templatename}${whichtemplate}warp.nii.gz ${gradientstep} ${templatename}${whichtemplate}warp.nii.gz"
+          echo "   MultiplyImages $dim ${templatename}${whichtemplate}warp.nii.gz ${gradientstep} ${templatename}${whichtemplate}warp.nii.gz"
           date
           echo "--------------------------------------------------------------------------------------"
-          ${ANTSPATH}/MultiplyImages $dim ${templatename}${whichtemplate}warp.nii.gz ${gradientstep} ${templatename}${whichtemplate}warp.nii.gz
+          MultiplyImages $dim ${templatename}${whichtemplate}warp.nii.gz ${gradientstep} ${templatename}${whichtemplate}warp.nii.gz
         fi
 
         echo
@@ -218,7 +189,7 @@ function shapeupdatetotemplate() {
         if [[ $NWARPS -ne 0 ]];
           then
             ${WARP} -d ${dim} -e vector -i ${templatename}0warp.nii.gz -o ${templatename}0warp.nii.gz -t [ ${templatename}0GenericAffine.mat,1 ] -r ${template}
-            ${ANTSPATH}/MeasureMinMaxMean ${dim} ${templatename}0warp.nii.gz ${templatename}warplog.txt 1
+            MeasureMinMaxMean ${dim} ${templatename}0warp.nii.gz ${templatename}warplog.txt 1
           fi
       fi
 
diff --git a/Scripts/sliceBySliceOperation.sh b/Scripts/sliceBySliceOperation.sh
index 996a53f9..6cfa0f2f 100755
--- a/Scripts/sliceBySliceOperation.sh
+++ b/Scripts/sliceBySliceOperation.sh
@@ -5,35 +5,6 @@ VERSION="0.0.0 test"
 # trap keyboard interrupt (control-c)
 trap control_c SIGINT
 
-function setPath {
-    cat <<SETPATH
-
---------------------------------------------------------------------------------------
-Error locating ANTS
---------------------------------------------------------------------------------------
-It seems that the ANTSPATH environment variable is not set. Please add the ANTSPATH
-variable. This can be achieved by editing the .bash_profile in the home directory.
-Add:
-
-ANTSPATH=/home/yourname/bin/ants/
-
-Or the correct location of the ANTS binaries.
-
-Alternatively, edit this script ( `basename $0` ) to set up this parameter correctly.
-
-SETPATH
-    exit 1
-}
-
-# Uncomment the line below in case you have not set the ANTSPATH variable in your environment.
-# export ANTSPATH=${ANTSPATH:="$HOME/bin/ants/"} # EDIT THIS
-
-#ANTSPATH=YOURANTSPATH
-if [[ ${#ANTSPATH} -le 3 ]];
-  then
-    setPath >&2
-  fi
-
 PROGRAMS[0]=ExtractSliceFromImage
 PROGRAMS[1]=PrintHeader
 PROGRAMS[2]=TileImages
@@ -43,9 +14,9 @@ PROGRAMS[5]=N4BiasFieldCorrection
 
 for (( i = 0; i < ${#PROGRAMS[@]}; i++ ))
   do
-    if [[ ! -s "${ANTSPATH}/${PROGRAMS[$i]}" ]];
+    if ! command -v "${PROGRAMS[$i]}" &> /dev/null
       then
-        echo "The ${PROGRAMS[$i]} program can't be found. Please (re)define \$ANTSPATH in your environment."
+        echo "The ${PROGRAMS[$i]} program can't be found. Please (re)define \$PATH in your environment."
         exit
       fi
   done
@@ -135,7 +106,7 @@ PARAMETERS[4]=$9
 PARAMETERS[5]=$10
 PARAMETERS[6]=$11
 
-SIZE_STRING=$( ${ANTSPATH}/PrintHeader $INPUT_IMAGE 2 )
+SIZE_STRING=$( PrintHeader $INPUT_IMAGE 2 )
 SIZE=( ${SIZE_STRING//x/ } )
 
 if [[ ${#SIZE[@]} -ne 3 ]];
@@ -169,7 +140,7 @@ for (( i = 0; i < $NUMBER_OF_SLICES; i++ ))
 
     OUTPUT_SLICE="${TMP_OUTPUT_DIR}/${OUTPUT_SLICE}Slice${i}.nii.gz"
 
-    ${ANTSPATH}/ExtractSliceFromImage 3 $INPUT_IMAGE $OUTPUT_SLICE $WHICH_DIRECTION $i
+    ExtractSliceFromImage 3 $INPUT_IMAGE $OUTPUT_SLICE $WHICH_DIRECTION $i
 
     ALL_OUTPUT_SLICES[$i]=$OUTPUT_SLICE
 
@@ -178,19 +149,19 @@ for (( i = 0; i < $NUMBER_OF_SLICES; i++ ))
       mv ${OUTPUT_SLICE} ${OUTPUT_DIR}
       ;;
     "Convolve")
-      ${ANTSPATH}/ImageMath 2 $OUTPUT_SLICE Convolve $OUTPUT_SLICE ${PARAMETERS[0]} ${PARAMETERS[1]}
+      ImageMath 2 $OUTPUT_SLICE Convolve $OUTPUT_SLICE ${PARAMETERS[0]} ${PARAMETERS[1]}
       ;;
     "DenoiseImage")
-      ${ANTSPATH}/DenoiseImage -d 2 -i $OUTPUT_SLICE -o $OUTPUT_SLICE -v 0
+      DenoiseImage -d 2 -i $OUTPUT_SLICE -o $OUTPUT_SLICE -v 0
       ;;
     "N4BiasFieldCorrection")
-      ${ANTSPATH}/N4BiasFieldCorrection -d 2 -i $OUTPUT_SLICE -o $OUTPUT_SLICE -v 0 -s 2
+      N4BiasFieldCorrection -d 2 -i $OUTPUT_SLICE -o $OUTPUT_SLICE -v 0 -s 2
       ;;
     "RescaleImage")
-      ${ANTSPATH}/ImageMath 2 $OUTPUT_SLICE RescaleImage $OUTPUT_SLICE ${PARAMETERS[0]} ${PARAMETERS[1]}
+      ImageMath 2 $OUTPUT_SLICE RescaleImage $OUTPUT_SLICE ${PARAMETERS[0]} ${PARAMETERS[1]}
       ;;
     "TruncateImageIntensity")
-      ${ANTSPATH}/ImageMath 2 $OUTPUT_SLICE TruncateImageIntensity $OUTPUT_SLICE ${PARAMETERS[0]} ${PARAMETERS[1]} ${PARAMETERS[2]} ${PARAMETERS[3]}
+      ImageMath 2 $OUTPUT_SLICE TruncateImageIntensity $OUTPUT_SLICE ${PARAMETERS[0]} ${PARAMETERS[1]} ${PARAMETERS[2]} ${PARAMETERS[3]}
       ;;
     *)
       echo "The operation '$OPERATION' is not an option.  See usage: '$0 -h 1'"
@@ -206,7 +177,7 @@ PERMUTATION_ORDER[2]='0 1 2'
 
 if [[ $OPERATION != "ExtractAllSlices" ]];
   then
-    ${ANTSPATH}/TileImages 3 $TMP_OUTPUT_FILE 1x1x0 ${ALL_OUTPUT_SLICES[@]}
-    ${ANTSPATH}/PermuteFlipImageOrientationAxes 3 $TMP_OUTPUT_FILE $TMP_OUTPUT_FILE ${PERMUTATION_ORDER[$WHICH_DIRECTION]} 0 0 0 0
-    ${ANTSPATH}/CopyImageHeaderInformation $INPUT_IMAGE $TMP_OUTPUT_FILE $OUTPUT_IMAGE 1 1 1
+    TileImages 3 $TMP_OUTPUT_FILE 1x1x0 ${ALL_OUTPUT_SLICES[@]}
+    PermuteFlipImageOrientationAxes 3 $TMP_OUTPUT_FILE $TMP_OUTPUT_FILE ${PERMUTATION_ORDER[$WHICH_DIRECTION]} 0 0 0 0
+    CopyImageHeaderInformation $INPUT_IMAGE $TMP_OUTPUT_FILE $OUTPUT_IMAGE 1 1 1
   fi
-- 
2.39.2 (Apple Git-143)

